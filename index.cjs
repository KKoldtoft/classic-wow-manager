// index.cjs
require('dotenv').config();

const express = require('express');
const session = require('express-session');
const passport = require('passport');
const DiscordStrategy = require('passport-discord').Strategy;
const { Pool } = require('pg');
const path = require('path');
const axios = require('axios');
const { S3Client, PutObjectCommand, ListObjectsV2Command, GetObjectCommand, HeadObjectCommand } = require('@aws-sdk/client-s3');
const multer = require('multer');
const fs = require('fs');
const cloudinary = require('cloudinary').v2;
// multer-storage-cloudinary has shipped with multiple CJS export styles across versions:
// - v4+:   { CloudinaryStorage }
// - v2.x:  module.exports = CloudinaryStorage
// Make startup resilient across environments (Heroku/local) by supporting both.
const multerStorageCloudinary = require('multer-storage-cloudinary');
const CloudinaryStorage =
  (multerStorageCloudinary && multerStorageCloudinary.CloudinaryStorage) ||
  multerStorageCloudinary;
const WebSocket = require('ws');
// Chat: Socket.IO (initialized after server listen)
let attachChatIo = null;
let setOutboundHandler = null;
try {
  const mod = require('./scripts/chat-socket.cjs');
  attachChatIo = mod.createIo;
  setOutboundHandler = mod.setOutboundHandler;
} catch (_) { attachChatIo = null; setOutboundHandler = null; }
let createDiscordBridge = null;
let getVoiceStateMap = null;
let getMemberEvents = null;
try { 
  const bridgeModule = require('./scripts/chat-discord-bridge.cjs');
  createDiscordBridge = bridgeModule.createDiscordBridge; 
  getVoiceStateMap = bridgeModule.getVoiceStateMap;
  getMemberEvents = bridgeModule.getMemberEvents;
  console.log('[init] Discord bridge module loaded:', { 
    hasCreateDiscordBridge: !!createDiscordBridge, 
    hasGetVoiceStateMap: !!getVoiceStateMap,
    hasGetMemberEvents: !!getMemberEvents
  });
} catch (err) { 
  console.error('[init] Failed to load Discord bridge module:', err?.message || err);
  createDiscordBridge = null; 
  getVoiceStateMap = null;
  getMemberEvents = null;
}

// Fallback voiceStateMap if bridge module not available
const fallbackVoiceStateMap = new Map();

// Helper to get the active voice state map
function getActiveVoiceStateMap() {
  if (getVoiceStateMap) {
    try { return getVoiceStateMap(); } catch (_) {}
  }
  return fallbackVoiceStateMap;
}
const zlib = require('zlib');

// --- Utility: timeout + retry wrapper for outbound HTTP (Discord/webhooks)
async function fetchWithTimeout(url, options = {}, timeoutMs = 10000) {
	const controller = new AbortController();
	const timer = setTimeout(() => controller.abort(), timeoutMs);
	try {
		const opts = { ...options, signal: controller.signal };
		return await fetch(url, opts);
	} finally {
		clearTimeout(timer);
	}
}

async function discordFetch(url, options = {}, retry = { maxRetries: 3, timeoutMs: 10000 }) {
	const maxRetries = typeof retry.maxRetries === 'number' ? retry.maxRetries : 3;
	const timeoutMs = typeof retry.timeoutMs === 'number' ? retry.timeoutMs : 10000;
	let attempt = 0;
	let backoff = 500;
	while (true) {
		try {
			const res = await fetchWithTimeout(url, options, timeoutMs);
			if (res.status === 429) {
				const retryAfter = Number(res.headers.get('retry-after') || '0');
				const waitMs = retryAfter > 0 ? Math.ceil(retryAfter * 1000) : Math.min(10000, backoff);
				if (attempt >= maxRetries) return res;
				await new Promise(r => setTimeout(r, waitMs));
				attempt += 1;
				backoff *= 2;
				continue;
			}
			return res;
		} catch (err) {
			if (attempt >= maxRetries) throw err;
			await new Promise(r => setTimeout(r, Math.min(5000, backoff)));
			attempt += 1;
			backoff *= 2;
		}
	}
}
// Rewards engine module (registers canonical endpoints)
let registerRewardsEngine;
try { registerRewardsEngine = require('./rewardsEngine.cjs'); } catch (_) { registerRewardsEngine = null; }

// --- Warcraft Logs API (v2 GraphQL) Configuration ---
const WCL_TOKEN_URL = 'https://www.warcraftlogs.com/oauth/token';
const WCL_API_URL = 'https://classic.warcraftlogs.com/api/v2/client'; // default for Classic
const WCL_CLIENT_ID = process.env.WCL_CLIENT_ID;
const WCL_CLIENT_SECRET = process.env.WCL_CLIENT_SECRET;

let wclAccessToken = null;
let wclTokenExpiresAt = 0; // epoch ms
const reportMetaCache = new Map(); // key: `${apiUrl}::${reportCode}` -> { actorsById, abilitiesById, fetchedAt }

// Live View feature removed

async function getWclAccessToken() {
  if (!WCL_CLIENT_ID || !WCL_CLIENT_SECRET) {
    throw new Error('Missing WCL_CLIENT_ID or WCL_CLIENT_SECRET env vars');
  }
  const now = Date.now();
  if (wclAccessToken && now < (wclTokenExpiresAt - 60000)) {
    return wclAccessToken;
  }
  const form = new URLSearchParams();
  form.append('grant_type', 'client_credentials');
  const response = await axios.post(WCL_TOKEN_URL, form, {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    auth: { username: WCL_CLIENT_ID, password: WCL_CLIENT_SECRET },
    timeout: 20000
  });
  const data = response.data || {};
  if (!data.access_token) {
    throw new Error('Failed to obtain Warcraft Logs access token');
  }
  wclAccessToken = data.access_token;
  const expiresInSec = typeof data.expires_in === 'number' ? data.expires_in : 3600;
  wclTokenExpiresAt = now + (expiresInSec * 1000);
  return wclAccessToken;
}

function getWclApiUrlFromInput(input) {
  const str = String(input || '');
  const lower = str.toLowerCase();
  // Handle raw host paths without scheme, or full URLs
  if (lower.includes('vanilla.warcraftlogs.com')) return 'https://vanilla.warcraftlogs.com/api/v2/client';
  if (lower.includes('classic.warcraftlogs.com')) return 'https://classic.warcraftlogs.com/api/v2/client';
  if (lower.includes('www.warcraftlogs.com') || lower.includes('warcraftlogs.com/reports/')) return 'https://www.warcraftlogs.com/api/v2/client';
  // Try URL parsing as a fallback (in case of other subdomains)
  try {
    const u = new URL(str.startsWith('http') ? str : `https://${str}`);
    const host = (u.hostname || '').toLowerCase();
    if (host.includes('vanilla.warcraftlogs.com')) return 'https://vanilla.warcraftlogs.com/api/v2/client';
    if (host.includes('classic.warcraftlogs.com')) return 'https://classic.warcraftlogs.com/api/v2/client';
    if (host.includes('www.warcraftlogs.com')) return 'https://www.warcraftlogs.com/api/v2/client';
  } catch (_) {}
  return WCL_API_URL; // default to Classic
}

function extractWclReportCode(input) {
  if (!input || typeof input !== 'string') return null;
  const trimmed = input.trim();
  const match = trimmed.match(/\/reports\/([A-Za-z0-9]{16,})/);
  if (match && match[1]) return match[1];
  const codeOnly = trimmed.replace(/^https?:\/\//i, '').split(/[?#\s]/)[0];
  if (/^[A-Za-z0-9]+$/.test(codeOnly)) return codeOnly;
  return null;
}

async function fetchWclEventsPage(params) {
  const { reportCode, startTime, endTime, apiUrl } = params;
  const token = await getWclAccessToken();
  const query = `query($code: String!, $start: Float!, $end: Float!) {
    reportData {
      report(code: $code) {
        startTime
        events(startTime: $start, endTime: $end) {
          data
          nextPageTimestamp
        }
      }
    }
  }`;
  const variables = { code: reportCode, start: Math.max(0, Number(startTime || 0)), end: Math.max(0, Number(endTime || 0)) };
  let resp;
  try {
    resp = await axios.post(apiUrl || WCL_API_URL, { query, variables }, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
  } catch (err) {
    const status = err.response && err.response.status;
    const data = err.response && err.response.data;
    const details = typeof data === 'object' ? JSON.stringify(data) : String(data || '');
    throw new Error(`HTTP error from WCL API ${status || ''}: ${details}`.trim());
  }
  const body = resp.data;
  if (body.errors) {
    const message = body.errors.map(e => e.message).join('; ');
    throw new Error(`Warcraft Logs GraphQL error: ${message}`);
  }
  const report = body && body.data && body.data.reportData && body.data.reportData.report;
  if (!report || !report.events) {
    throw new Error('Invalid Warcraft Logs response');
  }
  return {
    reportStartTime: report.startTime,
    events: Array.isArray(report.events.data) ? report.events.data : [],
    nextPageTimestamp: report.events.nextPageTimestamp != null ? report.events.nextPageTimestamp : null
  };
}

async function fetchWclEarliestFightStart(params) {
  const { reportCode, apiUrl } = params;
  const token = await getWclAccessToken();
  const query = `query($code: String!) {\n    reportData {\n      report(code: $code) {\n        fights { startTime }\n      }\n    }\n  }`;
  const variables = { code: reportCode };
  const resp = await axios.post(apiUrl || WCL_API_URL, { query, variables }, {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    timeout: 20000
  });
  const body = resp.data;
  if (body.errors) {
    return 0; // fallback to start
  }
  const fights = body && body.data && body.data.reportData && body.data.reportData.report && body.data.reportData.report.fights;
  if (!Array.isArray(fights) || fights.length === 0) return 0;
  let minStart = Infinity;
  for (const f of fights) {
    if (f && typeof f.startTime === 'number' && f.startTime < minStart) minStart = f.startTime;
  }
  if (!isFinite(minStart)) return 0;
  return Math.max(0, Math.floor(minStart));
}

async function fetchWclReportMeta(params) {
  const { reportCode, apiUrl } = params;
  const cacheKey = `${apiUrl || WCL_API_URL}::${reportCode}`;
  const cached = reportMetaCache.get(cacheKey);
  if (cached && (Date.now() - cached.fetchedAt) < 60 * 60 * 1000) { // 1 hour
    return cached;
  }
  const token = await getWclAccessToken();
  const query = `query($code: String!) {\n    reportData {\n      report(code: $code) {\n        masterData {\n          actors { id name type subType }\n          abilities { gameID name type }\n        }\n      }\n    }\n  }`;
  const variables = { code: reportCode };
  let resp;
  try {
    resp = await axios.post(apiUrl || WCL_API_URL, { query, variables }, {
      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
      timeout: 30000
    });
  } catch (err) {
    // On failure, return empty meta to avoid blocking
    return { actorsById: {}, abilitiesById: {}, fetchedAt: Date.now(), partial: true };
  }
  const body = resp.data;
  const report = body && body.data && body.data.reportData && body.data.reportData.report;
  const master = report && report.masterData;
  const actors = (master && Array.isArray(master.actors)) ? master.actors : [];
  const abilities = (master && Array.isArray(master.abilities)) ? master.abilities : [];
  const actorsById = {};
  for (const a of actors) {
    if (a && a.id != null) actorsById[a.id] = { name: a.name || String(a.id), type: a.type || null, subType: a.subType || null };
  }
  const abilitiesById = {};
  for (const ab of abilities) {
    if (ab && ab.gameID != null) abilitiesById[ab.gameID] = { name: ab.name || String(ab.gameID), type: ab.type || null };
  }
  const meta = { actorsById, abilitiesById, fetchedAt: Date.now() };
  reportMetaCache.set(cacheKey, meta);
  return meta;
}

async function fetchWclFights(params) {
  const { reportCode, apiUrl } = params;
  const token = await getWclAccessToken();
  const query = `query($code: String!) {\n    reportData {\n      report(code: $code) {\n        fights { id encounterID name startTime endTime kill }\n      }\n    }\n  }`;
  const variables = { code: reportCode };
  let resp;
  try {
    resp = await axios.post(apiUrl || WCL_API_URL, { query, variables }, {
      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
      timeout: 30000
    });
  } catch (err) {
    const status = err.response && err.response.status;
    const data = err.response && err.response.data;
    const details = typeof data === 'object' ? JSON.stringify(data) : String(data || '');
    throw new Error(`HTTP error from WCL API ${status || ''}: ${details}`.trim());
  }
  const body = resp.data;
  if (body.errors) {
    const message = body.errors.map(e => e.message).join('; ');
    throw new Error(`Warcraft Logs GraphQL error: ${message}`);
  }
  const fights = body && body.data && body.data.reportData && body.data.reportData.report && body.data.reportData.report.fights;
  return Array.isArray(fights) ? fights : [];
}

const app = express();

// --- Simple in-memory SSE broadcaster ---
const sseTopics = new Map(); // topic -> Set(res)

function getTopic(scope, eventId) {
  const s = String(scope || 'global');
  const e = String(eventId || 'all');
  return `${s}:${e}`;
}

function broadcastUpdate(scope, eventId, data) {
  try {
    const topic = getTopic(scope, eventId);
    const set = sseTopics.get(topic);
    if (!set || set.size === 0) return;
    const payload = JSON.stringify({
      scope,
      eventId,
      type: data && data.type || 'update',
      data: data || {},
      ts: Date.now()
    });
    for (const res of Array.from(set)) {
      try { res.write(`data: ${payload}\n\n`); } catch { set.delete(res); }
    }
  } catch (e) { console.warn('SSE broadcast error', e); }
}

// SSE Connection management and cleanup
const sseConnections = new Map(); // Track connections per IP
const MAX_CONNECTIONS_PER_IP = 3;
const SSE_TIMEOUT_MS = 60000; // 1 minute instead of 3 minutes
const SSE_HEARTBEAT_MS = 15000; // 15 seconds

function cleanupSSEConnection(res, topic, ip, heartbeat, idleTimer, maxIdleTimer) {
  try {
    if (heartbeat) clearInterval(heartbeat);
    if (idleTimer) clearTimeout(idleTimer);
    if (maxIdleTimer) clearTimeout(maxIdleTimer);
    
    // Remove from topic set
    const set = sseTopics.get(topic);
    if (set) set.delete(res);
    
    // Remove from IP tracking
    if (ip) {
      const ipConnections = sseConnections.get(ip) || new Set();
      ipConnections.delete(res);
      if (ipConnections.size === 0) {
        sseConnections.delete(ip);
      } else {
        sseConnections.set(ip, ipConnections);
      }
    }
    
    // Close connection if not already closed
    if (!res.destroyed && !res.finished) {
      try {
        res.write('event: close\ndata: {"reason":"cleanup"}\n\n');
        res.end();
      } catch {}
    }
  } catch (error) {
    console.warn('SSE cleanup error:', error);
  }
}

app.get('/api/updates/stream', (req, res) => {
  // Temporarily disabled
  return res.status(410).json({ error: 'SSE temporarily disabled' });
  if (!req.isAuthenticated || !req.isAuthenticated()) {
    // Allow anonymous read if desired; else enforce auth similar to other pages
    // return res.status(401).end();
  }
  
  const ip = (req.headers['x-forwarded-for'] || req.socket.remoteAddress || '').toString().split(',')[0].trim();
  
  // Check connection limit per IP
  const ipConnections = sseConnections.get(ip) || new Set();
  if (ipConnections.size >= MAX_CONNECTIONS_PER_IP) {
    console.log(`üö´ SSE connection limit reached for IP: ${ip} (${ipConnections.size}/${MAX_CONNECTIONS_PER_IP})`);
    return res.status(429).json({ error: 'Too many SSE connections from this IP' });
  }
  
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.flushHeaders && res.flushHeaders();

  const scope = String(req.query.scope || 'global');
  const eventId = String(req.query.eventId || 'all');
  const topic = getTopic(scope, eventId);
  
  console.log(`üîå SSE connection opened: ${ip} ‚Üí ${scope}:${eventId}`);

  let set = sseTopics.get(topic);
  if (!set) { set = new Set(); sseTopics.set(topic, set); }
  
  // Close any existing connection from this IP for this topic
  try {
    let found = null;
    for (const r of set) { if (r._sseIp === ip) { found = r; break; } }
    if (found) { 
      console.log(`üîÑ Replacing existing SSE connection for IP: ${ip}`);
      cleanupSSEConnection(found, topic, ip, found._heartbeat, found._idleTimer, found._maxIdleTimer);
    }
    res._sseIp = ip;
  } catch {}
  
  set.add(res);
  ipConnections.add(res);
  sseConnections.set(ip, ipConnections);

  // Initial ping
  try { 
    res.write(`data: ${JSON.stringify({ 
      scope, 
      eventId, 
      type: 'connected', 
      ts: Date.now(),
      timeout: SSE_TIMEOUT_MS 
    })}\n\n`); 
  } catch {}

  // Heartbeat with error handling
  const heartbeat = setInterval(() => {
    if (res.destroyed || res.finished) {
      clearInterval(heartbeat);
      return;
    }
    try { 
      res.write(': heartbeat\n\n'); 
    } catch (error) { 
      console.log(`üíî SSE heartbeat failed for ${ip}: ${error.message}`);
      clearInterval(heartbeat);
      cleanupSSEConnection(res, topic, ip, heartbeat, null, null);
    }
  }, SSE_HEARTBEAT_MS);
  
  // Shorter idle timeout (1 minute)
  const idleTimer = setTimeout(() => { 
    console.log(`‚è∞ SSE idle timeout for ${ip} after ${SSE_TIMEOUT_MS}ms`);
    cleanupSSEConnection(res, topic, ip, heartbeat, idleTimer, null);
  }, SSE_TIMEOUT_MS);
  
  // Maximum connection time (5 minutes hard limit)
  const maxIdleTimer = setTimeout(() => {
    console.log(`üîí SSE max connection time reached for ${ip} (5 minutes)`);
    cleanupSSEConnection(res, topic, ip, heartbeat, idleTimer, maxIdleTimer);
  }, 300000);

  // Store timer references for cleanup
  res._heartbeat = heartbeat;
  res._idleTimer = idleTimer;
  res._maxIdleTimer = maxIdleTimer;
  res._sseStartTime = Date.now();

  req.on('close', () => {
    console.log(`üîå SSE connection closed: ${ip} (duration: ${Date.now() - res._sseStartTime}ms)`);
    cleanupSSEConnection(res, topic, ip, heartbeat, idleTimer, maxIdleTimer);
  });
  
  req.on('error', (error) => {
    console.log(`‚ùå SSE connection error for ${ip}: ${error.message}`);
    cleanupSSEConnection(res, topic, ip, heartbeat, idleTimer, maxIdleTimer);
  });
  
  res.on('error', (error) => {
    console.log(`‚ùå SSE response error for ${ip}: ${error.message}`);
    cleanupSSEConnection(res, topic, ip, heartbeat, idleTimer, maxIdleTimer);
  });
});
const PORT = process.env.PORT || 3000;

app.set('trust proxy', 1);

// IP whitelist removed - all traffic allowed

// --- Cloudinary Configuration ---
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// --- Database Configuration ---
const connectionString = process.env.DATABASE_URL;
const isProduction = process.env.NODE_ENV === 'production';

const pool = new Pool({
  connectionString: connectionString,
  ssl: isProduction ? { rejectUnauthorized: false } : false,
  // Critical: Limit connections to prevent exhaustion
  max: 20, // Maximum pool size
  min: 2,  // Minimum pool size
  idleTimeoutMillis: 30000, // Close idle connections after 30s
  connectionTimeoutMillis: 10000, // Timeout for getting connection from pool
  acquireTimeoutMillis: 15000, // Timeout for acquiring connection
  // Handle connection errors gracefully
  allowExitOnIdle: false
});

let dbConnectionStatus = 'Connecting...';

pool.connect()
  .then(async client => {
    console.log('Connected to PostgreSQL database!');
    dbConnectionStatus = 'Connected';
    client.release();
    
    // Initialize events cache table
initializeEventsCacheTable();

// Initialize RPB tracking table
initializeRPBTrackingTable();

// Initialize Raid-Helper events cache table
initializeRaidHelperEventsCacheTable();

    // Initialize event endpoints JSON storage table
initializeEventEndpointsJsonTable();

    // Initialize raid durations table
initializeRaidDurationsTable();

    // Initialize assignments tables
    initializeAssignmentsTables();

// Migrate player confirmed logs table
migratePlayerConfirmedLogsTable();

    // Initialize rewards snapshot tables (entries + event header)
    initializeRewardsSnapshotTablesOnStartup();

    // Initialize authentication/user tables for local role storage
    initializeAuthTables();
    // Initialize member events table for roster page
    initializeMemberEventsTable();
    // Initialize polls tables and seed initial poll
    await initializePollsTables();
    await ensureInitialPoll();
  })
  .catch(err => {
    console.error('Error connecting to PostgreSQL database:', err.stack);
    dbConnectionStatus = 'Failed to Connect';
  });

// Function to create events cache table if it doesn't exist
async function initializeEventsCacheTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS events_cache (
        id SERIAL PRIMARY KEY,
        cache_key VARCHAR(100) UNIQUE NOT NULL,
        events_data JSONB NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        expires_at TIMESTAMP NOT NULL
      )
    `);
    console.log('‚úÖ Events cache table initialized');
  } catch (error) {
    console.error('‚ùå Error creating events cache table:', error);
  }
}

// Create local user and role tables for Discord-authenticated users
async function initializeAuthTables() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS discord_users (
        discord_id VARCHAR(32) PRIMARY KEY,
        username TEXT,
        discriminator TEXT,
        avatar TEXT,
        email TEXT,
        last_login_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`);

    await pool.query(`
      CREATE TABLE IF NOT EXISTS app_user_roles (
        discord_id VARCHAR(32) REFERENCES discord_users(discord_id) ON DELETE CASCADE,
        role_key TEXT NOT NULL,
        granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        granted_by TEXT,
        PRIMARY KEY (discord_id, role_key)
      )`);

    await pool.query(`CREATE INDEX IF NOT EXISTS idx_app_user_roles_role ON app_user_roles(role_key)`);
    console.log('‚úÖ Auth tables initialized (discord_users, app_user_roles)');
  } catch (error) {
    console.error('‚ùå Error creating auth tables:', error);
  }
}

// Create discord_member_events table for tracking server joins/leaves
async function initializeMemberEventsTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS discord_member_events (
        id SERIAL PRIMARY KEY,
        event_type VARCHAR(20) NOT NULL,
        discord_id VARCHAR(32) NOT NULL,
        username TEXT NOT NULL,
        discriminator VARCHAR(10),
        tag TEXT,
        avatar_url TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      )`);
    
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_discord_member_events_created ON discord_member_events(created_at DESC)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_discord_member_events_discord_id ON discord_member_events(discord_id)`);
    console.log('‚úÖ Discord member events table initialized');
  } catch (error) {
    console.error('‚ùå Error creating discord_member_events table:', error);
  }
}

// Initialize simple polls tables for front-page voting
async function initializePollsTables() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS polls (
        poll_id VARCHAR(100) PRIMARY KEY,
        question TEXT NOT NULL,
        is_active BOOLEAN DEFAULT TRUE,
        created_by_id TEXT,
        created_by_name TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      )
    `);
    await pool.query(`
      CREATE TABLE IF NOT EXISTS poll_options (
        id SERIAL PRIMARY KEY,
        poll_id VARCHAR(100) REFERENCES polls(poll_id) ON DELETE CASCADE,
        option_key TEXT NOT NULL,
        option_text TEXT NOT NULL,
        sort_index INTEGER DEFAULT 0,
        UNIQUE(poll_id, option_key)
      )
    `);
    await pool.query(`
      CREATE TABLE IF NOT EXISTS poll_votes (
        id SERIAL PRIMARY KEY,
        poll_id VARCHAR(100) REFERENCES polls(poll_id) ON DELETE CASCADE,
        voter_discord_id TEXT NOT NULL,
        voter_username TEXT,
        voter_discriminator TEXT,
        voter_display_name TEXT,
        option_key TEXT NOT NULL,
        voted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(poll_id, voter_discord_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_poll_votes_poll ON poll_votes(poll_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_poll_votes_option ON poll_votes(poll_id, option_key)`);
    console.log('‚úÖ Polls tables initialized');
  } catch (error) {
    console.error('‚ùå Error creating polls tables:', error);
  }
}

// Seed initial poll if it does not exist
async function ensureInitialPoll() {
  const pollId = 'orc_vote_monitor_setup_v1';
  const question = 'When we are raiding, do you have a second monitor in clear view that you can use to keep assignments, live logs, or other relevant content visible?';
  try {
    const existing = await pool.query(`SELECT 1 FROM polls WHERE poll_id = $1 LIMIT 1`, [pollId]);
    if (existing.rows.length > 0) return; // already exists
    await pool.query(
      `INSERT INTO polls (poll_id, question, is_active, created_by_id, created_by_name)
       VALUES ($1,$2,TRUE,$3,$4)`,
      [pollId, question, 'system', 'System']
    );
    const options = [
      { key: 'multi_monitor', text: 'Yes, I have a multi-monitor setup' },
      { key: 'second_monitor_bad', text: "Yes, but it's kind of shit" },
      { key: 'second_monitor_non_wow', text: 'Yes, but I use it for something non-WoW related' },
      { key: 'single_monitor', text: 'No, I only have one monitor' }
    ];
    let sort = 0;
    for (const opt of options) {
      await pool.query(
        `INSERT INTO poll_options (poll_id, option_key, option_text, sort_index)
         VALUES ($1,$2,$3,$4)
         ON CONFLICT (poll_id, option_key) DO NOTHING`,
        [pollId, opt.key, opt.text, sort++]
      );
    }
    console.log(`‚úÖ Seeded initial poll ${pollId}`);
  } catch (error) {
    console.error('‚ùå Error seeding initial poll:', error);
  }
}

// Initialize rewards snapshot tables (legacy set used by raidlogs admin/ui)
async function initializeRewardsSnapshotTablesOnStartup() {
  try {
    // Header/event row (one per event)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS rewards_snapshot_events (
        event_id VARCHAR(255) PRIMARY KEY,
        locked_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        locked_by_id VARCHAR(255),
        locked_by_name VARCHAR(255)
      )
    `);

    // Entries (row-per-entry)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS rewards_and_deductions_points (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(255) NOT NULL,
        panel_key VARCHAR(100) NOT NULL,
        panel_name VARCHAR(255) NOT NULL,
        discord_user_id VARCHAR(255),
        character_name VARCHAR(255) NOT NULL,
        character_class VARCHAR(50),
        ranking_number_original INTEGER,
        point_value_original INTEGER,
        character_details_original TEXT,
        primary_numeric_original INTEGER,
        aux_json JSONB,
        point_value_edited INTEGER,
        character_details_edited TEXT,
        primary_numeric_edited INTEGER,
        edited_by_id VARCHAR(255),
        edited_by_name VARCHAR(255),
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Helpful indexes
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_rewards_points_event ON rewards_and_deductions_points (event_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_rewards_points_panel ON rewards_and_deductions_points (event_id, panel_key)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_rewards_points_discord ON rewards_and_deductions_points (discord_user_id)`);
    await pool.query(`ALTER TABLE rewards_and_deductions_points ADD COLUMN IF NOT EXISTS panel_id TEXT`);

    // Add published/version and dashboard header fields on the event header row
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published BOOLEAN DEFAULT FALSE`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_at TIMESTAMP`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_by_id TEXT`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_by_name TEXT`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS total_gold_pot BIGINT`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS shared_gold_pot BIGINT`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS raid_duration_minutes INTEGER`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS bosses_killed INTEGER`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS last_boss TEXT`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS wow_logs_url TEXT`);
    await pool.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS rpb_archive_url TEXT`);

    console.log('‚úÖ Rewards snapshot tables initialized');
  } catch (error) {
    console.error('‚ùå Error initializing rewards snapshot tables:', error);
  }
}

// Function to create per-event endpoints JSON storage table
async function initializeEventEndpointsJsonTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS event_endpoints_json (
        event_id VARCHAR(50) PRIMARY KEY,
        wcl_summary_json JSONB,
        event_roles_json JSONB,
        realms_json JSONB,
        fights_json JSONB,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    await pool.query(`ALTER TABLE event_endpoints_json ADD COLUMN IF NOT EXISTS realms_json JSONB`);
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_event_endpoints_updated ON event_endpoints_json(updated_at)
    `);
    console.log('‚úÖ Event endpoints JSON table initialized');
  } catch (error) {
    console.error('‚ùå Error creating event_endpoints_json table:', error);
  }
}

// Assignments tables initialization
async function initializeAssignmentsTables() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS raid_assignments (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(100) NOT NULL,
        dungeon TEXT NOT NULL,
        wing TEXT NOT NULL DEFAULT '',
        boss TEXT NOT NULL,
        strategy_text TEXT,
        image_url TEXT,
        image_url_full TEXT,
        boss_icon_url TEXT,
        video_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(event_id, dungeon, wing, boss)
      );
    `);
    await pool.query(`
      CREATE TABLE IF NOT EXISTS raid_assignment_entries (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(100) NOT NULL,
        dungeon TEXT NOT NULL,
        wing TEXT NOT NULL DEFAULT '',
        boss TEXT NOT NULL,
        character_name TEXT NOT NULL,
        class_name TEXT,
        class_color TEXT,
        spec_name TEXT,
        spec_emote TEXT,
        marker_icon_url TEXT,
        assignment TEXT,
        sort_index INTEGER DEFAULT 0,
        character_discord_id TEXT,
        accept_status TEXT,
        accept_set_by TEXT,
        accept_updated_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);
    await pool.query(`
      CREATE TABLE IF NOT EXISTS raid_assignment_entry_accepts (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(100) NOT NULL,
        dungeon TEXT NOT NULL,
        wing TEXT NOT NULL DEFAULT '',
        boss TEXT NOT NULL,
        character_name TEXT NOT NULL,
        accept_status TEXT,
        accept_set_by TEXT,
        accept_updated_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(event_id, dungeon, wing, boss, character_name)
      );
    `);
    // Ensure new columns exist when upgrading
    await pool.query(`ALTER TABLE raid_assignment_entries ADD COLUMN IF NOT EXISTS marker_icon_url TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entries ADD COLUMN IF NOT EXISTS character_discord_id TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entries ADD COLUMN IF NOT EXISTS accept_status TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entries ADD COLUMN IF NOT EXISTS accept_set_by TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entries ADD COLUMN IF NOT EXISTS accept_updated_at TIMESTAMP`);
    await pool.query(`ALTER TABLE raid_assignments ADD COLUMN IF NOT EXISTS video_url TEXT`);
    await pool.query(`ALTER TABLE raid_assignments ADD COLUMN IF NOT EXISTS image_url_full TEXT`);
    await pool.query(`ALTER TABLE raid_assignments ADD COLUMN IF NOT EXISTS boss_icon_url TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entry_accepts ADD COLUMN IF NOT EXISTS accept_status TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entry_accepts ADD COLUMN IF NOT EXISTS accept_set_by TEXT`);
    await pool.query(`ALTER TABLE raid_assignment_entry_accepts ADD COLUMN IF NOT EXISTS accept_updated_at TIMESTAMP`);
    console.log('‚úÖ Assignments tables initialized');
  } catch (error) {
    console.error('‚ùå Error initializing assignments tables:', error);
  }
}

// Function to create RPB tracking table if it doesn't exist
async function initializeRPBTrackingTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS rpb_tracking (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(100) NOT NULL,
        log_url TEXT NOT NULL,
        rpb_status VARCHAR(20) DEFAULT 'pending',
        rpb_completed_at TIMESTAMP,
        archive_url TEXT,
        archive_name VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(event_id, log_url)
      )
    `);
    console.log('‚úÖ RPB tracking table initialized');
  } catch (error) {
    console.error('‚ùå Error creating RPB tracking table:', error);
  }
}

// Function to create Raid-Helper events cache table if it doesn't exist
async function initializeRaidHelperEventsCacheTable() {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS raid_helper_events_cache (
        event_id VARCHAR(50) PRIMARY KEY,
        event_data JSONB NOT NULL,
        cached_at TIMESTAMP DEFAULT NOW(),
        last_accessed TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Create indexes for better performance
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_raid_events_cached 
      ON raid_helper_events_cache(cached_at)
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_raid_events_accessed 
      ON raid_helper_events_cache(last_accessed)
    `);
    
    console.log('‚úÖ Raid-Helper events cache table initialized');
  } catch (error) {
    console.error('‚ùå Error creating Raid-Helper events cache table:', error);
  }
}

// Events cache helper functions
const EVENTS_CACHE_TTL = 60 * 60 * 1000; // 1 hour in milliseconds
const HISTORIC_EVENTS_CACHE_TTL = 60 * 60 * 1000; // 1 hour in milliseconds
const EVENTS_CACHE_KEY = 'raid_helper_events';
const HISTORIC_EVENTS_CACHE_KEY = 'raid_helper_historic_events';
const HISTORIC_24M_EVENTS_CACHE_TTL = 60 * 60 * 1000; // 1 hour in milliseconds
const HISTORIC_24M_EVENTS_CACHE_KEY = 'raid_helper_historic_events_24m';

async function getCachedEvents() {
  try {
    const result = await pool.query(
      'SELECT events_data, expires_at FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()',
      [EVENTS_CACHE_KEY]
    );
    
    if (result.rows.length > 0) {
      console.log('üíæ Using cached events data');
      return result.rows[0].events_data;
    }
    
    console.log('üîÑ No valid cached events found - will fetch fresh data');
    return null;
  } catch (error) {
    console.error('‚ùå Error retrieving cached events:', error);
    return null;
  }
}

// Function to migrate player_confirmed_logs table to support multiple characters per user
async function migratePlayerConfirmedLogsTable() {
  try {
    console.log('üîß Checking player_confirmed_logs table structure...');
    
    // Check if table exists
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'player_confirmed_logs'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üìù player_confirmed_logs table does not exist yet - will be created with correct structure');
      return;
    }
    
    // Check current primary key constraint
    const currentPK = await pool.query(`
      SELECT constraint_name, constraint_type 
      FROM information_schema.table_constraints 
      WHERE table_name = 'player_confirmed_logs' 
      AND constraint_type = 'PRIMARY KEY';
    `);
    
    if (currentPK.rows.length > 0) {
      // Check if it's the old constraint (raid_id, discord_id) vs new (raid_id, discord_id, character_name)
      const pkColumns = await pool.query(`
        SELECT column_name 
        FROM information_schema.key_column_usage 
        WHERE table_name = 'player_confirmed_logs' 
        AND constraint_name = $1
        ORDER BY ordinal_position;
      `, [currentPK.rows[0].constraint_name]);
      
      const columnNames = pkColumns.rows.map(row => row.column_name);
      console.log('üîç Current primary key columns:', columnNames);
      
      if (columnNames.length === 2 && columnNames.includes('raid_id') && columnNames.includes('discord_id')) {
        console.log('üîß Migrating primary key to include character_name...');
        
        await pool.query('BEGIN');
        try {
          // Drop the old constraint
          await pool.query(`ALTER TABLE player_confirmed_logs DROP CONSTRAINT ${currentPK.rows[0].constraint_name}`);
          
          // Add new primary key constraint
          await pool.query(`ALTER TABLE player_confirmed_logs ADD PRIMARY KEY (raid_id, discord_id, character_name)`);
          
          await pool.query('COMMIT');
          console.log('‚úÖ Successfully migrated player_confirmed_logs primary key');
        } catch (error) {
          await pool.query('ROLLBACK');
          console.error('‚ùå Failed to migrate primary key:', error);
          console.log('‚ö†Ô∏è Continuing with error handling in place for old constraint');
        }
      } else {
        console.log('‚úÖ Primary key structure is already correct');
      }
    }
    
  } catch (error) {
    console.error('‚ùå Error checking player_confirmed_logs migration:', error);
  }
}

async function setCachedEvents(eventsData) {
  try {
    const expiresAt = new Date(Date.now() + EVENTS_CACHE_TTL);
    
    await pool.query(`
      INSERT INTO events_cache (cache_key, events_data, expires_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (cache_key) 
      DO UPDATE SET 
        events_data = EXCLUDED.events_data,
        created_at = CURRENT_TIMESTAMP,
        expires_at = EXCLUDED.expires_at
    `, [EVENTS_CACHE_KEY, JSON.stringify(eventsData), expiresAt]);
    
    console.log('üíæ Events cached successfully, expires at:', expiresAt.toISOString());
  } catch (error) {
    console.error('‚ùå Error caching events:', error);
  }
}

async function getCachedHistoricEvents() {
  try {
    const result = await pool.query(
      'SELECT events_data, expires_at FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()',
      [HISTORIC_EVENTS_CACHE_KEY]
    );
    
    if (result.rows.length > 0) {
      console.log('üíæ Using cached historic events data');
      return result.rows[0].events_data;
    }
    
    console.log('üîÑ No valid cached historic events found - will fetch fresh data');
    return null;
  } catch (error) {
    console.error('‚ùå Error retrieving cached historic events:', error);
    return null;
  }
}

async function setCachedHistoricEvents(eventsData) {
  try {
    const expiresAt = new Date(Date.now() + HISTORIC_EVENTS_CACHE_TTL);
    
    await pool.query(`
      INSERT INTO events_cache (cache_key, events_data, expires_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (cache_key) 
      DO UPDATE SET 
        events_data = EXCLUDED.events_data,
        created_at = CURRENT_TIMESTAMP,
        expires_at = EXCLUDED.expires_at
    `, [HISTORIC_EVENTS_CACHE_KEY, JSON.stringify(eventsData), expiresAt]);
    
    console.log('üíæ Historic events cached successfully, expires at:', expiresAt.toISOString());
  } catch (error) {
    console.error('‚ùå Error caching historic events:', error);
  }
}

async function getCachedHistoricEvents24m() {
  try {
    const result = await pool.query(
      'SELECT events_data, expires_at FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()',
      [HISTORIC_24M_EVENTS_CACHE_KEY]
    );
    if (result.rows.length > 0) {
      console.log('üíæ Using cached 24-month historic events data');
      return result.rows[0].events_data;
    }
    console.log('üîÑ No valid cached 24-month historic events found - will fetch fresh data');
    return null;
  } catch (error) {
    console.error('‚ùå Error retrieving cached 24-month historic events:', error);
    return null;
  }
}

async function setCachedHistoricEvents24m(eventsData) {
  try {
    const expiresAt = new Date(Date.now() + HISTORIC_24M_EVENTS_CACHE_TTL);
    await pool.query(`
      INSERT INTO events_cache (cache_key, events_data, expires_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (cache_key) 
      DO UPDATE SET 
        events_data = EXCLUDED.events_data,
        created_at = CURRENT_TIMESTAMP,
        expires_at = EXCLUDED.expires_at
    `, [HISTORIC_24M_EVENTS_CACHE_KEY, JSON.stringify(eventsData), expiresAt]);
    console.log('üíæ 24-month historic events cached successfully, expires at:', expiresAt.toISOString());
  } catch (error) {
    console.error('‚ùå Error caching 24-month historic events:', error);
  }
}

// Raid-Helper individual event cache helper functions
const RAID_HELPER_EVENT_CACHE_TTL_HOURS = 6; // 6 hours default TTL

async function getCachedRaidHelperEvent(eventId, maxAgeHours = RAID_HELPER_EVENT_CACHE_TTL_HOURS) {
    try {
        const result = await pool.query(`
            SELECT event_data, cached_at 
            FROM raid_helper_events_cache 
            WHERE event_id = $1 
            AND cached_at > NOW() - INTERVAL '${maxAgeHours} hours'
        `, [eventId]);
        
        if (result.rows.length > 0) {
            // Update last_accessed timestamp
            await pool.query(`
                UPDATE raid_helper_events_cache 
                SET last_accessed = NOW() 
                WHERE event_id = $1
            `, [eventId]);
            
            console.log(`üì¶ [CACHE] Hit for event ${eventId} (cached: ${result.rows[0].cached_at})`);
            return result.rows[0].event_data;
        }
        
        console.log(`üîç [CACHE] Miss for event ${eventId}`);
        return null;
    } catch (error) {
        console.error(`‚ùå [CACHE] Error checking cache for event ${eventId}:`, error);
        return null;
    }
}

async function setCachedRaidHelperEvent(eventId, eventData) {
    try {
        await pool.query(`
            INSERT INTO raid_helper_events_cache (event_id, event_data, cached_at, last_accessed)
            VALUES ($1, $2, NOW(), NOW())
            ON CONFLICT (event_id) 
            DO UPDATE SET 
                event_data = $2,
                cached_at = NOW(),
                last_accessed = NOW()
        `, [eventId, JSON.stringify(eventData)]);
        
        console.log(`üíæ [CACHE] Stored event ${eventId}`);
    } catch (error) {
        console.error(`‚ùå [CACHE] Error storing event ${eventId}:`, error);
    }
}

async function cleanupRaidHelperEventCache(olderThanDays = 365) {
    try {
        const result = await pool.query(`
            DELETE FROM raid_helper_events_cache 
            WHERE cached_at < NOW() - INTERVAL '${olderThanDays} days'
            RETURNING event_id
        `);
        
        if (result.rows.length > 0) {
            console.log(`üßπ [CACHE] Cleaned up ${result.rows.length} old Raid-Helper event cache entries`);
        }
        
        return result.rows.length;
    } catch (error) {
        console.error('‚ùå [CACHE] Error cleaning up Raid-Helper event cache:', error);
        return 0;
    }
}

async function fetchEventsFromAPI() {
  const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
  if (!raidHelperApiKey) {
    throw new Error('RAID_HELPER_API_KEY is not set in environment variables.');
  }

  const discordGuildId = '777268886939893821';
  const nowUnixTimestamp = Math.floor(Date.now() / 1000);
  const oneYearInSeconds = 365 * 24 * 60 * 60;
  const futureUnixTimestamp = nowUnixTimestamp + oneYearInSeconds;

  console.log('üåê Fetching fresh events from Raid-Helper API...');

  const response = await axios.get(
    `https://raid-helper.dev/api/v3/servers/${discordGuildId}/events`,
    {
      headers: {
        'Authorization': `${raidHelperApiKey}`,
        'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
      },
      params: {
        StartTimeFilter: nowUnixTimestamp,
        EndTimeFilter: futureUnixTimestamp,
      }
    }
  );

  const events = response.data.postedEvents || [];
  if (events.length > 0) {
    console.log('üìä Sample event structure:', JSON.stringify(events[0], null, 2));
  }
  
  return events;
}

async function fetchHistoricEventsFromAPI() {
  const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
  if (!raidHelperApiKey) {
    throw new Error('RAID_HELPER_API_KEY is not set in environment variables.');
  }

  const discordGuildId = '777268886939893821';
  const nowUnixTimestamp = Math.floor(Date.now() / 1000);
  const oneYearInSeconds = 365 * 24 * 60 * 60;
  const pastUnixTimestamp = nowUnixTimestamp - oneYearInSeconds;

      console.log('üåê Fetching historic events from Raid-Helper API (last year)...');

  const response = await axios.get(
    `https://raid-helper.dev/api/v3/servers/${discordGuildId}/events`,
    {
      headers: {
        'Authorization': `${raidHelperApiKey}`,
        'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
      },
      params: {
        StartTimeFilter: pastUnixTimestamp,
        EndTimeFilter: nowUnixTimestamp,
      }
    }
  );

  return response.data.postedEvents || [];
}

// Generic helper: fetch historic events within the past N months
async function fetchHistoricEventsFromAPIWithinMonths(months) {
  const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
  if (!raidHelperApiKey) {
    throw new Error('RAID_HELPER_API_KEY is not set in environment variables.');
  }

  const discordGuildId = '777268886939893821';
  const nowUnixTimestamp = Math.floor(Date.now() / 1000);
  const days = Math.max(1, Math.floor(months * 30));
  const pastUnixTimestamp = nowUnixTimestamp - (days * 24 * 60 * 60);

  console.log(`üåê Fetching historic events from Raid-Helper API (last ${months} months)...`);

  const response = await axios.get(
    `https://raid-helper.dev/api/v3/servers/${discordGuildId}/events`,
    {
      headers: {
        'Authorization': `${raidHelperApiKey}`,
        'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
      },
      params: {
        StartTimeFilter: pastUnixTimestamp,
        EndTimeFilter: nowUnixTimestamp,
      }
    }
  );

  return response.data.postedEvents || [];
}

async function enrichEventsWithChannelNames(events) {
  // Use global cache for channel names (10 minute TTL)
  if (!global.channelNameCache) {
    global.channelNameCache = new Map();
  }
  const channelNameCache = global.channelNameCache;
  const CACHE_TTL = 10 * 60 * 1000; // 10 minutes
  
  // CRITICAL: Filter and sort events exactly like the frontend does
  const today = new Date();
  const upcomingEvents = events.filter(event => {
    if (!event.startTime) return false;
    const eventStartDate = new Date(parseInt(event.startTime) * 1000);
    return eventStartDate >= today;
  }).sort((a, b) => parseInt(a.startTime) - parseInt(b.startTime));
  
  // OPTIMIZATION: Only enrich the first 10 upcoming events to avoid rate limits
  const eventsToEnrich = upcomingEvents.slice(0, 10);
  const remainingEvents = upcomingEvents.slice(10);
  
  console.log(`üìä Filtered to ${upcomingEvents.length} upcoming events, processing ${eventsToEnrich.length} for channel names, skipping ${remainingEvents.length}`);
  
  // Helper function to fetch channel name with retry and rate limit handling
  const fetchChannelNameWithRetry = async (eventId, maxRetries = 3) => {
    const cacheKey = `channel_${eventId}`;
    const cached = channelNameCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
      console.log(`üíæ Using cached channelName for event ${eventId}: "${cached.channelName}"`);
      return cached.channelName;
    }
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîÑ Fetching channelName for event ${eventId} (attempt ${attempt}/${maxRetries})`);
        
        const eventDetailResponse = await axios.get(
          `https://raid-helper.dev/api/v2/events/${eventId}`,
          {
            headers: {
              'Authorization': `${process.env.RAID_HELPER_API_KEY}`,
              'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
            },
            timeout: 8000
          }
        );
        
        const channelName = eventDetailResponse.data.channelName;
        console.log(`üì° API Response for event ${eventId}: channelName="${channelName}"`);
        
        if (channelName && 
            channelName.trim() && 
            channelName !== eventId &&
            !channelName.match(/^\d+$/)) {
          console.log(`‚úÖ Valid channelName found: "${channelName}"`);
          
          channelNameCache.set(cacheKey, {
            channelName: channelName,
            timestamp: Date.now()
          });
          
          return channelName;
        }
        
        console.log(`‚ö†Ô∏è Invalid or empty channelName: "${channelName}"`);
        
        channelNameCache.set(cacheKey, {
          channelName: null,
          timestamp: Date.now()
        });
        
        return null;
        
      } catch (error) {
        console.log(`‚ùå Attempt ${attempt} failed for event ${eventId}:`, error.message);
        
        if (error.response && error.response.status === 429) {
          const rateLimitDelay = attempt * 2000;
          console.log(`üö¶ Rate limit hit, waiting ${rateLimitDelay}ms before retry...`);
          if (attempt < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, rateLimitDelay));
            continue;
          }
        }
        
        if (attempt === maxRetries) {
          console.log(`üí• All ${maxRetries} attempts failed for event ${eventId}`);
          
          channelNameCache.set(cacheKey, {
            channelName: null,
            timestamp: Date.now()
          });
          
          return null;
        }
        
        const delay = attempt * 1500;
        console.log(`‚è≥ Waiting ${delay}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    return null;
  };
  
  // Enrich events with channel names
  const enrichedEvents = [];
  const startTime = Date.now();
  const TOTAL_TIMEOUT = 30000; // 30 second total timeout
  
  for (let i = 0; i < eventsToEnrich.length; i++) {
    const event = eventsToEnrich[i];
    
    if (Date.now() - startTime > TOTAL_TIMEOUT) {
      console.log(`‚è∞ Timeout reached, skipping remaining ${eventsToEnrich.length - i} events`);
      for (let j = i; j < eventsToEnrich.length; j++) {
        enrichedEvents.push({
          ...eventsToEnrich[j],
          channelName: null
        });
      }
      break;
    }
    
    try {
      const channelName = await fetchChannelNameWithRetry(event.id);
      console.log(`üìã Final result for event ${event.id}: channelName = "${channelName}"`);
      
      enrichedEvents.push({
        ...event,
        channelName: channelName
      });
      
      if (i < eventsToEnrich.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 750));
      }
      
    } catch (error) {
      console.log(`üíÄ Critical error processing event ${event.id}:`, error);
      enrichedEvents.push({
        ...event,
        channelName: null
      });
    }
  }
  
  // Add remaining upcoming events without channel names
  remainingEvents.forEach(event => {
    enrichedEvents.push({
      ...event,
      channelName: null
    });
  });
  
  // Add all past events without channel names
  const pastEvents = events.filter(event => {
    if (!event.startTime) return true;
    const eventStartDate = new Date(parseInt(event.startTime) * 1000);
    return eventStartDate < today;
  });
  
  pastEvents.forEach(event => {
    enrichedEvents.push({
      ...event,
      channelName: null
    });
  });
  
  const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`‚è±Ô∏è Channel name processing completed in ${processingTime}s`);
  
  const totalEvents = enrichedEvents.length;
  const totalUpcomingEvents = upcomingEvents.length;
  const processedEvents = eventsToEnrich.length;
  const eventsWithChannelNames = enrichedEvents.filter(e => e.channelName).length;
  const successRate = processedEvents > 0 ? ((eventsWithChannelNames / processedEvents) * 100).toFixed(1) : 0;
  
  console.log(`üìà Channel name fetch summary: ${eventsWithChannelNames}/${processedEvents} processed upcoming events (${successRate}% success rate), ${totalUpcomingEvents} total upcoming, ${totalEvents} total returned`);
  
  return enrichedEvents;
}

// Initialize raid durations table for storing calculated durations
async function initializeRaidDurationsTable() {
    try {
        await pool.query(`
            CREATE TABLE IF NOT EXISTS raid_durations (
                event_id VARCHAR(50) PRIMARY KEY,
                duration_minutes INTEGER NOT NULL,
                calculated_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW()
            )
        `);
        console.log('‚úÖ Raid durations table initialized');
    } catch (error) {
        console.error('‚ùå Error creating raid durations table:', error);
    }
}

// Channel name helpers: prefer database over live Discord API
async function getChannelNameMapFromDb() {
  try {
    const res = await pool.query(`SELECT channel_id, channel_name FROM channel_filters WHERE channel_name IS NOT NULL AND channel_name <> ''`);
    const map = new Map();
    for (const row of res.rows) {
      map.set(String(row.channel_id), String(row.channel_name));
    }
    return map;
  } catch (e) {
    console.warn('‚ö†Ô∏è Could not load channel names from DB:', e.message);
    return new Map();
  }
}

async function upsertChannelName(channelId, channelName) {
  try {
    if (!channelId || !channelName) return;
    await pool.query(`
      INSERT INTO channel_filters (channel_id, channel_name, is_visible, updated_at)
      VALUES ($1, $2, TRUE, CURRENT_TIMESTAMP)
      ON CONFLICT (channel_id)
      DO UPDATE SET channel_name = EXCLUDED.channel_name, updated_at = CURRENT_TIMESTAMP
    `, [String(channelId), String(channelName)]);
  } catch (_) {}
}

// Function to enrich events with Discord channel names (MUCH MORE RELIABLE)
async function enrichEventsWithDiscordChannelNames(events) {
  const discordGuildId = '777268886939893821';
  
  console.log(`üîÑ Starting Discord channel enrichment for ${events.length} events`);
  
  // Get channel names from DB (no live Discord calls)
  const channelNameMap = await getChannelNameMapFromDb();
  console.log(`üíæ DB provided ${channelNameMap.size} channel mappings`);
  
  // Debug: Show first few channel mappings
  const sampleChannels = Array.from(channelNameMap.entries()).slice(0, 3);
  console.log('üìç Sample channel mappings:', sampleChannels);
  
  // Apply channel names to events
  let usedDbCount = 0;
  let fallbackCount = 0;
  const enrichedEvents = events.map(event => {
    const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
    
    // Debug: Log channel ID detection for first few events
    if (events.indexOf(event) < 3) {
      console.log(`üîç Event ${event.id}: channelId="${channelId}", has mapping: ${channelNameMap.has(channelId)}`);
    }
    
    if (channelId && channelNameMap.has(channelId)) {
      usedDbCount++;
      return {
        ...event,
        channelName: channelNameMap.get(channelId), // No # prefix here - frontend adds it
        channelId: channelId
      };
    }
    
    // Fallback for unknown channels - no # prefix
    if (channelId && !channelNameMap.has(channelId)) fallbackCount++;
    return {
      ...event,
      channelName: event.channelName || (channelId ? `channel-${channelId.slice(-4)}` : null),
      channelId: channelId || null
    };
  });
  
  console.log(`üéØ Enriched ${enrichedEvents.length} events with channel names from DB or fallbacks`);
  console.log(`   ‚Ü≥ usedDbCount=${usedDbCount}, fallbackCount=${fallbackCount}`);
  return enrichedEvents;
}

// Function to filter events to historic (last year) and enrich with channel names
async function enrichHistoricEventsWithDiscordChannelNames(events) {
  console.log(`üîÑ Starting historic events filtering and enrichment for ${events.length} events`);
  
  // CRITICAL: Filter to historic events (past events, last year)
  const now = new Date();
  const oneYearAgo = new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000));
  const historicEvents = events.filter(event => {
    if (!event.startTime) return false;
    const eventStartDate = new Date(parseInt(event.startTime) * 1000);
    return eventStartDate < now && eventStartDate >= oneYearAgo;
  }).sort((a, b) => parseInt(b.startTime) - parseInt(a.startTime)); // Sort newest first
  
  console.log(`üìä Filtered to ${historicEvents.length} historic events (last year) from ${events.length} total`);
  
  // Now enrich with Discord channel names
  return await enrichEventsWithDiscordChannelNames(historicEvents);
}

// Filter to historic events within the past N months and enrich with channel names
async function enrichHistoricEventsWithDiscordChannelNamesWithinMonths(events, months) {
  console.log(`üîÑ Starting historic events filtering and enrichment for ${events.length} events (last ${months} months)`);
  const now = new Date();
  const cutoff = new Date(now.getTime() - (Math.max(1, Math.floor(months * 30)) * 24 * 60 * 60 * 1000));
  const historicEvents = events
    .filter(event => {
      if (!event.startTime) return false;
      const eventStartDate = new Date(parseInt(event.startTime) * 1000);
      return eventStartDate < now && eventStartDate >= cutoff;
    })
    .sort((a, b) => parseInt(b.startTime) - parseInt(a.startTime));

  console.log(`üìä Filtered to ${historicEvents.length} historic events (last ${months} months) from ${events.length} total`);
  return await enrichEventsWithDiscordChannelNames(historicEvents);
}

// --- Session Configuration ---
const pgSession = require('connect-pg-simple')(session);
app.use(session({
  store: new pgSession({
    pool: pool,
    tableName: 'session',
    createTableIfMissing: true,
    ttl: 30 * 24 * 60 * 60 // keep sessions for 30 days in store
  }),
  name: 'sid',
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  rolling: true, // refresh cookie expiration on every response
  proxy: true,
  cookie: {
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days cookie lifetime
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax'
  }
}));

// --- Passport.js Configuration ---
app.use(passport.initialize());
app.use(passport.session());

passport.serializeUser((user, done) => {
  done(null, user);
});

passport.deserializeUser((obj, done) => {
  done(null, obj);
});

passport.use(new DiscordStrategy({
    clientID: process.env.DISCORD_CLIENT_ID,
    clientSecret: process.env.DISCORD_CLIENT_SECRET,
    callbackURL: `${process.env.APP_BASE_URL}/auth/discord/callback`,
    scope: ['identify']
},
(accessToken, refreshToken, profile, done) => {
    // Store the access token in the profile for later use
    profile.accessToken = accessToken;
    profile.refreshToken = refreshToken;
    return done(null, profile);
}));

// --- Role-Based Access Control Functions ---

// Your Discord server ID - update this with your actual server ID
const DISCORD_GUILD_ID = '777268886939893821'; // Your guild ID from the events API

// Define management role - the only role that matters (override via env)
const MANAGEMENT_ROLE_NAME = (process.env.MANAGEMENT_ROLE_NAME || 'Management');
// Helper role for roster-only privileges
const HELPER_ROLE_NAME = (process.env.HELPER_ROLE_NAME || 'Helper');
// Optional: prefer matching by Role ID to avoid needing guild roles name mapping
const MANAGEMENT_ROLE_ID = process.env.MANAGEMENT_ROLE_ID || null;
const HELPER_ROLE_ID = process.env.HELPER_ROLE_ID || null;

// Local DB-backed role helpers (preferred)
async function userHasAppRole(discordId, roleKey) {
    try {
        if (!discordId) return false;
        const res = await pool.query(`SELECT 1 FROM app_user_roles WHERE discord_id = $1 AND role_key = $2 LIMIT 1`, [String(discordId), String(roleKey)]);
        return res && res.rowCount > 0;
    } catch (_) { return false; }
}

async function hasManagementRoleById(discordId) { return userHasAppRole(discordId, 'management'); }
async function hasHelperRoleById(discordId) { return userHasAppRole(discordId, 'helper'); }

async function getUserPermissionsFromDb(discordId) {
    const [isMgmt, isHelper] = await Promise.all([
        hasManagementRoleById(discordId),
        hasHelperRoleById(discordId)
    ]);
    return { hasManagementRole: !!isMgmt, hasHelperRole: !!isHelper };
}

// Legacy Discord role-fetch helpers (no longer used)
async function discordApiCallWithBackoff(url, options = {}, retryOptions = {}) {
    const maxRetries = retryOptions.maxRetries || 3;
    const baseDelay = retryOptions.baseDelay || 1000;
    const maxDelay = retryOptions.maxDelay || 10000;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            const response = await axios.get(url, {
                ...options,
                timeout: 10000
            });
            return response;
        } catch (error) {
            const status = error.response?.status;
            const isLastAttempt = attempt === maxRetries;
            
            // Log the error for monitoring
            console.log(`üîç Discord API attempt ${attempt + 1}/${maxRetries + 1} failed:`, {
                status,
                statusText: error.response?.statusText,
                url: url.replace(/Bearer\s+[\w.-]+/, 'Bearer [REDACTED]')
            });
            
            // Don't retry certain errors
            if (status === 403 || status === 404 || isLastAttempt) {
                throw error;
            }
            
            // Calculate backoff delay
            let delay = baseDelay * Math.pow(2, attempt);
            
            // Handle rate limiting: honor Retry-After without capping
            if (status === 429) {
                const retryAfterHeader = error.response?.headers['retry-after'];
                const retryAfterFromBody = (error.response?.data && typeof error.response.data.retry_after === 'number')
                    ? error.response.data.retry_after
                    : null;
                const retryAfterSec = retryAfterHeader != null ? Number(retryAfterHeader) : retryAfterFromBody;
                if (retryAfterSec && !Number.isNaN(retryAfterSec) && retryAfterSec > 0) {
                    const delayMs = Math.ceil(retryAfterSec * 1000);
                    console.log(`‚è≥ Rate limited (429) - honoring Retry-After: ${delayMs}ms`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                    continue;
                }
            }
            
            // Handle 401 errors with exponential backoff (token might be temporarily invalid)
            if (status === 401) {
                delay = Math.min(delay * 1.5, maxDelay);
                console.log(`üîê 401 Unauthorized - applying backoff delay: ${delay}ms`);
            }
            
            // Cap the delay for non-429 cases
            delay = Math.min(delay, maxDelay);
            
            console.log(`‚è≥ Retrying Discord API call in ${delay}ms (attempt ${attempt + 1}/${maxRetries + 1})`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Function to fetch user's guild member data including roles (with caching and backoff)
async function fetchUserGuildMember(accessToken, guildId) {
    // Create cache key based on full access token and guild ID to avoid collisions
    const cacheKey = `${accessToken}__${guildId}`;
    
    // Check cache first
    const cached = userMemberCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp) < USER_CACHE_TTL) {
        console.log(`üíæ Using cached user member data (${cached.data.roles.length} roles)`);
        return cached.data;
    }

    // Await in-flight request for same user/guild if present
    if (userMemberInFlight.has(cacheKey)) {
        console.log('‚è≥ Awaiting in-flight guild member fetch');
        try { return await userMemberInFlight.get(cacheKey); } catch (_) {}
    }

    try {
        console.log(`üîç Fetching guild member data for guild ${guildId}`);
        const inFlight = (async () => {
            const response = await discordApiCallWithBackoff(
                `https://discord.com/api/v10/users/@me/guilds/${guildId}/member`,
                {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
                    }
                },
                {
                    maxRetries: 3,
                    baseDelay: 1000,
                    maxDelay: 8000
                }
            );
            console.log(`‚úÖ Guild member data received`);
            return response.data;
        })();
        userMemberInFlight.set(cacheKey, inFlight);
        const data = await inFlight;
        // Cache the successful response
        userMemberCache.set(cacheKey, {
            data,
            timestamp: Date.now()
        });
        return data;
    } catch (error) {
        console.error('‚ùå Error fetching guild member data after retries:', {
            status: error.response?.status,
            statusText: error.response?.statusText,
            data: error.response?.data,
            message: error.message
        });
        
        // If we have stale cached data and it's any retryable error, use the stale data
        if ((error.response?.status === 429 || error.response?.status === 401 || error.response?.status === 500) && cached) {
            console.log(`‚ö†Ô∏è Using stale cached data due to ${error.response?.status} error (${Math.floor((Date.now() - cached.timestamp) / 1000)}s old)`);
            return cached.data;
        }
        
        return null;
    } finally {
        userMemberInFlight.delete(cacheKey);
    }
}

// Cache for guild roles to avoid repeated API calls
let guildRolesCache = null;
let guildRolesCacheTime = 0;

// Cache for user member data to avoid repeated API calls
const userMemberCache = new Map();
// Track in-flight user member requests to deduplicate concurrent calls
const userMemberInFlight = new Map();
// Short-lived cache for aggregated /user response per access token
const userInfoCache = new Map(); // accessToken -> { value, timestamp }
// Allow overriding cache TTLs; default to short TTLs in non-production to avoid confusion while testing
const USER_CACHE_TTL = process.env.USER_CACHE_TTL_MS ? parseInt(process.env.USER_CACHE_TTL_MS, 10) : (process.env.NODE_ENV === 'production' ? 15 * 60 * 1000 : 60 * 1000);
const USER_INFO_TTL = process.env.USER_INFO_TTL_MS ? parseInt(process.env.USER_INFO_TTL_MS, 10) : (process.env.NODE_ENV === 'production' ? 2 * 60 * 1000 : 30 * 1000);
const GUILD_CACHE_TTL = process.env.GUILD_CACHE_TTL_MS ? parseInt(process.env.GUILD_CACHE_TTL_MS, 10) : (process.env.NODE_ENV === 'production' ? 10 * 60 * 1000 : 60 * 1000);

// Clean up old cache entries every 30 minutes
setInterval(() => {
    const now = Date.now();
    let cleanedCount = 0;
    
    for (const [key, value] of userMemberCache.entries()) {
        if (now - value.timestamp > USER_CACHE_TTL * 2) { // Remove entries older than 30 minutes
            userMemberCache.delete(key);
            cleanedCount++;
        }
    }
    
    if (cleanedCount > 0) {
        console.log(`üßπ Cleaned up ${cleanedCount} old cache entries`);
    }
}, 30 * 60 * 1000); // Run every 30 minutes

// Compute both Management and Helper permissions from a single member fetch
async function getUserPermissionsCombined(accessToken) {
    // Check short-lived /user cache
    const cachedInfo = userInfoCache.get(accessToken);
    if (cachedInfo && (Date.now() - cachedInfo.timestamp) < USER_INFO_TTL) {
        return cachedInfo.value;
    }

    const memberData = await fetchUserGuildMember(accessToken, DISCORD_GUILD_ID);
    let hasMgmt = false;
    let hasHelp = false;
    if (memberData && Array.isArray(memberData.roles)) {
        // Prefer ID checks when configured
        if (MANAGEMENT_ROLE_ID) {
            hasMgmt = memberData.roles.some(rid => String(rid) === String(MANAGEMENT_ROLE_ID));
        }
        if (HELPER_ROLE_ID) {
            hasHelp = memberData.roles.some(rid => String(rid) === String(HELPER_ROLE_ID));
        }
        // Resolve by role name if needed
        if ((!MANAGEMENT_ROLE_ID || !hasMgmt) || (!HELPER_ROLE_ID || !hasHelp)) {
            const roles = await fetchGuildRoles(DISCORD_GUILD_ID);
            const roleMap = new Map(roles.map(role => [role.id, role.name]));
            const userRoleNames = memberData.roles.map(roleId => roleMap.get(roleId)).filter(Boolean);
            if (!hasMgmt) {
                hasMgmt = userRoleNames.some(name => (name || '').toLowerCase() === MANAGEMENT_ROLE_NAME.toLowerCase());
            }
            if (!hasHelp) {
                hasHelp = userRoleNames.some(name => (name || '').toLowerCase() === HELPER_ROLE_NAME.toLowerCase());
            }
        }
    }
    const value = { hasManagementRole: !!hasMgmt, hasHelperRole: !!hasHelp };
    userInfoCache.set(accessToken, { value, timestamp: Date.now() });
    return value;
}

// Function to fetch guild roles to map role IDs to names (with one retry on failure)
async function fetchGuildRoles(guildId, attempt = 1) {
    // Check cache first
    if (guildRolesCache && (Date.now() - guildRolesCacheTime) < GUILD_CACHE_TTL) {
        console.log(`üíæ Using cached guild roles (${guildRolesCache.length} roles)`);
        return guildRolesCache;
    }

    try {
        console.log(`üîç Fetching guild roles for guild ${guildId}`);
        console.log(`ü§ñ Bot token configured: ${process.env.DISCORD_BOT_TOKEN ? 'Yes' : 'No'}`);
        
        if (!process.env.DISCORD_BOT_TOKEN) {
            console.log('‚ö†Ô∏è No bot token configured - cannot fetch guild roles');
            return [];
        }
        
        const response = await discordApiCallWithBackoff(
            `https://discord.com/api/v10/guilds/${guildId}/roles`,
            {
                headers: {
                    'Authorization': `Bot ${process.env.DISCORD_BOT_TOKEN}`,
                    'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
                }
            },
            {
                maxRetries: 2,
                baseDelay: 500,
                maxDelay: 5000
            }
        );
        
        console.log(`‚úÖ Guild roles received: ${response.data.length} roles`);
        
        // Cache the results
        guildRolesCache = response.data;
        guildRolesCacheTime = Date.now();
        
        return response.data;
    } catch (error) {
        console.error('‚ùå Error fetching guild roles:', {
            status: error.response?.status,
            statusText: error.response?.statusText,
            data: error.response?.data,
            message: error.message,
            botTokenExists: !!process.env.DISCORD_BOT_TOKEN
        });
        if (attempt < 2 && process.env.DISCORD_BOT_TOKEN) {
            console.log('üîÅ Retrying guild roles fetch once...');
            await new Promise(r => setTimeout(r, 300));
            return fetchGuildRoles(guildId, attempt + 1);
        }
        return [];
    }
}

// Check if user has Management role
async function hasManagementRole(accessToken) {
    const memberData = await fetchUserGuildMember(accessToken, DISCORD_GUILD_ID);
    if (!memberData || !memberData.roles) {
        console.log('‚ùå No member data or roles found');
        return false;
    }
    // If a specific role ID is provided, prefer ID matching (no guild roles name lookup)
    if (MANAGEMENT_ROLE_ID) {
        const hasById = memberData.roles.some(rid => String(rid) === String(MANAGEMENT_ROLE_ID));
        console.log(`üîç Checking for Management role by ID (${MANAGEMENT_ROLE_ID}): ${hasById ? '‚úÖ FOUND' : '‚ùå NOT FOUND'}`);
        return hasById;
    }

    // Fallback: resolve by role name via guild roles list
    const guildRoles = await fetchGuildRoles(DISCORD_GUILD_ID);
    if (guildRoles.length === 0) {
        console.log('‚ö†Ô∏è No guild roles available - cannot verify Management role by name');
        return false;
    }
    const roleMap = new Map(guildRoles.map(role => [role.id, role.name]));
    const userRoleNames = memberData.roles.map(roleId => roleMap.get(roleId)).filter(Boolean);
    console.log(`üë§ User's role names: [${userRoleNames.join(', ')}]`);
    const hasByName = userRoleNames.some(name => (name || '').toLowerCase() === MANAGEMENT_ROLE_NAME.toLowerCase());
    console.log(`üîç Checking for "${MANAGEMENT_ROLE_NAME}" role by name: ${hasByName ? '‚úÖ FOUND' : '‚ùå NOT FOUND'}`);
    return hasByName;
}

// Check if user has Helper role (roster-only privileges)
async function hasHelperRole(accessToken) {
    const memberData = await fetchUserGuildMember(accessToken, DISCORD_GUILD_ID);
    if (!memberData || !memberData.roles) {
        console.log('‚ùå No member data or roles found');
        return false;
    }
    // Prefer ID matching when configured
    if (HELPER_ROLE_ID) {
        const hasById = memberData.roles.some(rid => String(rid) === String(HELPER_ROLE_ID));
        console.log(`üîç Checking for Helper role by ID (${HELPER_ROLE_ID}): ${hasById ? '‚úÖ FOUND' : '‚ùå NOT FOUND'}`);
        return hasById;
    }

    // Fallback: resolve by role name via guild roles list
    const guildRoles = await fetchGuildRoles(DISCORD_GUILD_ID);
    if (guildRoles.length === 0) {
        console.log('‚ö†Ô∏è No guild roles available - cannot verify Helper role by name');
        return false;
    }
    const roleMap = new Map(guildRoles.map(role => [role.id, role.name]));
    const userRoleNames = memberData.roles.map(roleId => roleMap.get(roleId)).filter(Boolean);
    console.log(`üë§ User's role names: [${userRoleNames.join(', ')}]`);
    const hasByName = userRoleNames.some(name => (name || '').toLowerCase() === HELPER_ROLE_NAME.toLowerCase());
    console.log(`üîç Checking for "${HELPER_ROLE_NAME}" role by name: ${hasByName ? '‚úÖ FOUND' : '‚ùå NOT FOUND'}`);
    return hasByName;
}

// Utility: clear cached role data for a specific user access token and global roles cache
function clearRoleCachesForAccessToken(accessToken) {
    try {
        const prefix = `${accessToken}__`;
        for (const key of userMemberCache.keys()) {
            if (key.startsWith(prefix)) userMemberCache.delete(key);
        }
        guildRolesCache = null;
        guildRolesCacheTime = 0;
        console.log('üßπ Cleared role caches for current session');
    } catch (_) {}
}

// Middleware to require Management role
async function requireManagement(req, res, next) {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Authentication required' });
    }

    const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ message: 'Management role required' });
    }

    next();
}

// Middleware: allow Management or Helper (roster-only access)
async function requireRosterManager(req, res, next) {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Authentication required' });
    }
    const isMgmt = await hasManagementRoleById(req.user.id);
    const isHelper = await hasHelperRoleById(req.user.id);
    if (!isMgmt && !isHelper) {
        return res.status(403).json({ message: 'Management or Helper role required' });
    }
    next();
}

// --- Express Routes ---

// Add the JSON middleware to parse request bodies (raise limit for large JSON blobs)
app.use(express.json({ limit: '15mb' }));

// üéØ Discord API endpoints removed - we now get channel names directly from Raid-Helper API!

// Critical: Place express.static as the FIRST middleware to handle static files.
app.use(express.static('public'));

// Serve the migration helper page
app.get('/fix-rewards', (req, res) => {
    res.sendFile(path.join(__dirname, 'fix_heroku_rewards.html'));
});

// Explicit route for chat widget script to avoid SPA catch-all interference
app.get('/widget/site-chat.js', (req, res) => {
  res.type('application/javascript');
  res.sendFile(path.join(__dirname, 'public', 'widget', 'site-chat.js'));
});

// Route to serve the Roster page for specific event IDs - HIGH PRIORITY
app.get('/event/:eventId/roster', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'roster.html'));
});

// Serve Gold and Loot pages with event-scoped URLs

app.get('/event/:eventId/gold', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'gold.html'));
});

app.get('/event/:eventId/loot', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'loot.html'));
});

// Event-scoped Logs page
app.get('/event/:eventId/logs', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'logs.html'));
});

app.get('/players', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'players.html'));
});

app.get('/admin', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

app.get('/admin/points', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'admin-points.html'));
});

app.get('/admin/raid-channels', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'admin-raid-channels.html'));
});

app.get('/voice-check', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'voice-check.html'));
});

app.get('/guild-members', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'guild-members.html'));
});

app.get('/user-settings', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'user-settings.html'));
});

app.get('/logs', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'logs.html'));
});

app.get('/rpb_import', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'rpb_import.html'));
});

app.get('/gold', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'gold.html'));
});

app.get('/loot', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'loot.html'));
});

app.get('/livehost', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'livehost.html'));
});

app.get('/live', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'live.html'));
});

app.get('/history', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'history.html'));
});

// Admin-only raidlogs page (heavy compute)
app.get('/raidlogs_admin', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.redirect('/');
  }
  try {
    const ok = await hasManagementRoleById(req.user.id);
    if (!ok) return res.status(403).send('Management role required');
  } catch {
    return res.status(403).send('Management role required');
  }
  res.sendFile(path.join(__dirname, 'public', 'raidlogs.html'));
});

// Preserve legacy route for now but redirect non-management away
app.get('/raidlogs', async (req, res) => {
  return res.sendFile(path.join(__dirname, 'public', 'raidlogs_view.html'));
});

// Event-scoped public viewer
app.get('/event/:eventId/raidlogs', async (req, res) => {
  return res.sendFile(path.join(__dirname, 'public', 'raidlogs_view.html'));
});

// Event-scoped admin page (heavy compute)
app.get('/event/:eventId/raidlogs_admin', async (req, res) => {
  if (!req.isAuthenticated()) return res.redirect('/');
  try {
    const ok = await hasManagementRoleById(req.user.id);
    if (!ok) return res.status(403).send('Management role required');
  } catch { return res.status(403).send('Management role required'); }
  return res.sendFile(path.join(__dirname, 'public', 'raidlogs.html'));
});

// Debug table page (management only)
app.get('/event/:eventId/debug-table', async (req, res) => {
  if (!req.isAuthenticated()) return res.redirect('/');
  try {
    const ok = await hasManagementRoleById(req.user.id);
    if (!ok) return res.status(403).send('Management role required');
  } catch { return res.status(403).send('Management role required'); }
  return res.sendFile(path.join(__dirname, 'public', 'debug-table.html'));
});

// API endpoint to fetch rewards_and_deductions_points table data
app.get('/api/rewards-snapshot-table/:eventId', async (req, res) => {
  if (!req.isAuthenticated()) return res.status(401).json({ error: 'Authentication required' });
  try {
    const ok = await hasManagementRoleById(req.user.id);
    if (!ok) return res.status(403).json({ error: 'Management role required' });
  } catch { return res.status(403).json({ error: 'Management role required' }); }
  
  const { eventId } = req.params;
  try {
    const result = await pool.query(
      `SELECT * FROM rewards_and_deductions_points 
       WHERE event_id = $1 
       ORDER BY panel_key, ranking_number_original NULLS LAST, character_name`,
      [eventId]
    );
    
    res.json({
      success: true,
      eventId,
      rowCount: result.rows.length,
      data: result.rows
    });
  } catch (error) {
    console.error('Error fetching rewards snapshot table:', error);
    res.status(500).json({ error: 'Failed to fetch table data', details: error.message });
  }
});

app.get('/stats', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'stats.html'));
});

app.get('/rules', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'rules.html'));
});

app.get('/faq', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'faq.html'));
});

app.get('/itemlog', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'itemlog.html'));
});

// Minimal live view page
// Live pages removed

// Simple Discord test page
app.get('/discordtest', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'discordtest.html'));
});


// All API and authentication routes should come AFTER express.static AND specific HTML routes
app.get('/auth/discord', (req, res, next) => {
	// Build a safe return path to embed in the OAuth state parameter
	const returnToParam = typeof req.query.returnTo === 'string' ? req.query.returnTo : null;
	let safeReturnTo = '/';
	if (returnToParam && returnToParam.startsWith('/')) {
		safeReturnTo = returnToParam;
	} else if (typeof req.headers.referer === 'string') {
		try {
			const refererUrl = new URL(req.headers.referer);
			const refererPath = refererUrl.pathname + refererUrl.search + refererUrl.hash;
			if (refererPath && refererPath.startsWith('/')) {
				safeReturnTo = refererPath;
			}
		} catch (_) {
			// Ignore invalid referer header
		}
	}
	// Stash on request for the authenticate call to use as state
	req.oauthReturnState = encodeURIComponent(safeReturnTo);
	return next();
}, (req, res, next) => passport.authenticate('discord', { state: req.oauthReturnState })(req, res, next));

app.get('/auth/discord/callback',
  passport.authenticate('discord', {
    failureRedirect: '/'
  }),
  (req, res) => {
    (async () => {
      try {
        // Upsert the authenticated Discord user locally
        const u = req.user || {};
        const discordId = String(u.id || '');
        if (discordId) {
          await pool.query(`
            INSERT INTO discord_users (discord_id, username, discriminator, avatar, email, last_login_at, updated_at)
            VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
            ON CONFLICT (discord_id)
            DO UPDATE SET
              username = EXCLUDED.username,
              discriminator = EXCLUDED.discriminator,
              avatar = EXCLUDED.avatar,
              email = EXCLUDED.email,
              last_login_at = CURRENT_TIMESTAMP,
              updated_at = CURRENT_TIMESTAMP
          `, [discordId, u.username || null, u.discriminator || null, u.avatar || null, u.email || null]);
        }
      } catch (e) {
        console.error('‚ö†Ô∏è Failed to upsert discord user:', e.message);
      } finally {
        // Prefer the OAuth state param as source of truth for return path
        const state = typeof req.query.state === 'string' ? req.query.state : '';
        let destination = '/';
        try {
          const decoded = decodeURIComponent(state || '');
          if (decoded && decoded.startsWith('/')) destination = decoded;
        } catch (_) {}
        res.redirect(destination);
      }
    })();
  }
);

// --- Discord test API endpoints ---
// Sends a DM saying "Hello world" to a hard-coded Discord user ID for testing
app.post('/api/discord/test/dm', async (req, res) => {
    try {
        const botToken = process.env.DISCORD_BOT_TOKEN;
        if (!botToken) {
            return res.status(500).json({ ok: false, error: 'DISCORD_BOT_TOKEN not set' });
        }

        const targetUserId = '492023474437619732';
        // 1) Create (or fetch) a DM channel with the user
        const dmResponse = await discordFetch('https://discord.com/api/v10/users/@me/channels', {
            method: 'POST',
            headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ recipient_id: targetUserId })
        }, { maxRetries: 3, timeoutMs: 10000 });

        if (!dmResponse.ok) {
            const errText = await dmResponse.text();
            return res.status(dmResponse.status).json({ ok: false, step: 'create_dm', error: errText });
        }

        const dmChannel = await dmResponse.json();
        const channelId = dmChannel.id;

        // 2) Send the message
        const msgResponse = await discordFetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
            method: 'POST',
            headers: {
                'Authorization': `Bot ${botToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ content: 'Hello world' })
        }, { maxRetries: 3, timeoutMs: 10000 });

        if (!msgResponse.ok) {
            const errText = await msgResponse.text();
            return res.status(msgResponse.status).json({ ok: false, step: 'send_message', error: errText });
        }

        return res.json({ ok: true });
    } catch (err) {
        return res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
});

// Posts "Hello world" to a specific webhook URL for testing
app.post('/api/discord/test/webhook', async (req, res) => {
    try {
        const webhookUrl = 'https://discord.com/api/webhooks/1407621923462189107/mucb9o6-PDBTB3A-m0KNGJ-FBeeCKCpoxPkSqSlhWKpGDpNCGgW8KoEpRNCr569649zX';
        const response = await fetchWithTimeout(webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ content: 'Hello world' })
        }, 10000);

        if (!response.ok) {
            const errText = await response.text();
            return res.status(response.status).json({ ok: false, error: errText });
        }

        return res.json({ ok: true });
    } catch (err) {
        return res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
});

// --- Simple Polls API ---
// Fetch poll with options and aggregate counts; also include myVote when authenticated
app.get('/api/polls/:pollId', async (req, res) => {
  const { pollId } = req.params;
  let client;
  try {
    client = await pool.connect();
    const pollRes = await client.query(`SELECT poll_id, question, is_active, created_at FROM polls WHERE poll_id = $1`, [pollId]);
    if (pollRes.rows.length === 0) return res.status(404).json({ ok: false, error: 'Poll not found' });
    const poll = pollRes.rows[0];
    const optsRes = await client.query(`SELECT option_key, option_text, sort_index FROM poll_options WHERE poll_id = $1 ORDER BY sort_index, id`, [pollId]);
    const countsRes = await client.query(`SELECT option_key, COUNT(*)::int AS count FROM poll_votes WHERE poll_id = $1 GROUP BY option_key`, [pollId]);
    const countMap = new Map(countsRes.rows.map(r => [r.option_key, Number(r.count)||0]));
    let myVote = null;
    if (req.isAuthenticated && req.isAuthenticated()) {
      const me = await client.query(`SELECT option_key FROM poll_votes WHERE poll_id = $1 AND voter_discord_id = $2 LIMIT 1`, [pollId, String(req.user.id)]);
      if (me.rows.length > 0) myVote = me.rows[0].option_key;
    }
    res.json({ ok: true, poll: { id: poll.poll_id, question: poll.question, is_active: !!poll.is_active }, options: optsRes.rows.map(o => ({ key: o.option_key, text: o.option_text, count: countMap.get(o.option_key) || 0 })), myVote });
  } catch (err) {
    res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  } finally { if (client) client.release(); }
});

// Cast or change vote; requires authentication
app.post('/api/polls/:pollId/vote', async (req, res) => {
  const { pollId } = req.params;
  const { optionKey } = req.body || {};
  if (!req.isAuthenticated || !req.isAuthenticated()) {
    return res.status(401).json({ ok: false, error: 'Login required' });
  }
  if (!optionKey || typeof optionKey !== 'string') {
    return res.status(400).json({ ok: false, error: 'optionKey is required' });
  }
  let client;
  try {
    client = await pool.connect();
    // Validate poll and option
    const pollRes = await client.query(`SELECT poll_id, is_active FROM polls WHERE poll_id = $1`, [pollId]);
    if (pollRes.rows.length === 0) return res.status(404).json({ ok: false, error: 'Poll not found' });
    if (!pollRes.rows[0].is_active) return res.status(400).json({ ok: false, error: 'Poll is closed' });
    const optRes = await client.query(`SELECT 1 FROM poll_options WHERE poll_id = $1 AND option_key = $2`, [pollId, optionKey]);
    if (optRes.rows.length === 0) return res.status(400).json({ ok: false, error: 'Invalid optionKey' });

    await client.query(`
      INSERT INTO poll_votes (poll_id, voter_discord_id, voter_username, voter_discriminator, voter_display_name, option_key)
      VALUES ($1,$2,$3,$4,$5,$6)
      ON CONFLICT (poll_id, voter_discord_id)
      DO UPDATE SET option_key = EXCLUDED.option_key, voted_at = NOW()
    `, [
      pollId,
      String(req.user.id),
      req.user.username || null,
      req.user.discriminator || null,
      (req.user.username ? `${req.user.username}#${req.user.discriminator||''}` : null),
      optionKey
    ]);

    // Return updated tallies
    const countsRes = await client.query(`SELECT option_key, COUNT(*)::int AS count FROM poll_votes WHERE poll_id = $1 GROUP BY option_key`, [pollId]);
    const countMap = new Map(countsRes.rows.map(r => [r.option_key, Number(r.count)||0]));
    const optsRes = await client.query(`SELECT option_key, option_text, sort_index FROM poll_options WHERE poll_id = $1 ORDER BY sort_index, id`, [pollId]);
    res.json({ ok: true, myVote: optionKey, options: optsRes.rows.map(o => ({ key: o.option_key, text: o.option_text, count: countMap.get(o.option_key) || 0 })) });
  } catch (err) {
    res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  } finally { if (client) client.release(); }
});

// Remove current user's vote
app.delete('/api/polls/:pollId/vote', async (req, res) => {
  const { pollId } = req.params;
  if (!req.isAuthenticated || !req.isAuthenticated()) {
    return res.status(401).json({ ok: false, error: 'Login required' });
  }
  let client;
  try {
    client = await pool.connect();
    await client.query(`DELETE FROM poll_votes WHERE poll_id = $1 AND voter_discord_id = $2`, [pollId, String(req.user.id)]);
    // Return updated tallies
    const countsRes = await client.query(`SELECT option_key, COUNT(*)::int AS count FROM poll_votes WHERE poll_id = $1 GROUP BY option_key`, [pollId]);
    const countMap = new Map(countsRes.rows.map(r => [r.option_key, Number(r.count)||0]));
    const optsRes = await client.query(`SELECT option_key, option_text, sort_index FROM poll_options WHERE poll_id = $1 ORDER BY sort_index, id`, [pollId]);
    res.json({ ok: true, myVote: null, options: optsRes.rows.map(o => ({ key: o.option_key, text: o.option_text, count: countMap.get(o.option_key) || 0 })) });
  } catch (err) {
    res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  } finally { if (client) client.release(); }
});

// Announce invites for the current event (test version posts a simple embed to a hard-coded webhook)
app.post('/api/discord/announce-invites', requireRosterManager, async (req, res) => {
  const { eventId, invitePerson, mentionContent, mentionUserIds } = req.body || {};
  if (!eventId) return res.status(400).json({ ok: false, error: 'eventId is required' });
  if (!invitePerson || !String(invitePerson).trim()) return res.status(400).json({ ok: false, error: 'invitePerson is required' });
  let webhookUrl = null;
  let client;
  try {
    client = await pool.connect();
    // Derive isNax flag using the same logic as channel-flags
    let isNax = false;
    let channelId = null;
    let channelName = null;
    try {
      const ev = await client.query('SELECT event_data FROM raid_helper_events_cache WHERE event_id = $1', [String(eventId)]);
      if (ev.rows.length > 0) {
        const data = ev.rows[0].event_data || {};
        channelId = data.channelId || data.channelID || data.channel_id || null;
        channelName = data.channelName || data.channel_name || null;
      }
      if (channelId) {
        const cf = await client.query('SELECT is_nax FROM channel_filters WHERE channel_id = $1', [channelId]);
        if (cf.rows.length > 0) isNax = !!cf.rows[0].is_nax;
      }
      // Heuristic fallback if DB flag missing
      if (!isNax && channelName) {
        const lower = String(channelName).toLowerCase();
        if (lower.includes('nax') || lower.includes('naxx')) isNax = true;
      }
    } catch (_) {}

    // Fallbacks to resolve channel for upcoming events if not in per-event cache
    if (!channelId) {
      // Fallback 1: look into cached upcoming events blob for channelId
      try {
        const cached = await client.query(
          `SELECT events_data FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()`,
          ['raid_helper_events']
        );
        if (cached.rows.length > 0) {
          const eventsBlob = cached.rows[0].events_data || {};
          const list = Array.isArray(eventsBlob.postedEvents) ? eventsBlob.postedEvents : (Array.isArray(eventsBlob) ? eventsBlob : []);
          const match = list.find(e => String(e.id) === String(eventId));
          if (match) {
            channelId = match.channelId || match.channelID || match.channel_id || null;
            channelName = match.channelName || match.channel_name || null;
          }
        }
      } catch (_) {}

      // Fallback 2: query v3 servers endpoint directly
      if (!channelId) {
        try {
          const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
          const guildId = process.env.DISCORD_GUILD_ID || '777268886939893821';
          if (raidHelperApiKey) {
            const nowUnixTimestamp = Math.floor(Date.now() / 1000);
            const oneYearInSeconds = 365 * 24 * 60 * 60;
            const futureUnixTimestamp = nowUnixTimestamp + oneYearInSeconds;
            const resp = await axios.get(`https://raid-helper.dev/api/v3/servers/${guildId}/events`, {
              headers: { 'Authorization': `${raidHelperApiKey}`, 'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)' },
              params: { StartTimeFilter: nowUnixTimestamp - 7 * 24 * 3600, EndTimeFilter: futureUnixTimestamp },
              timeout: 10000
            });
            const events = resp.data && Array.isArray(resp.data.postedEvents) ? resp.data.postedEvents : [];
            const match = events.find(e => String(e.id) === String(eventId));
            if (match) {
              channelId = match.channelId || match.channelID || match.channel_id || null;
              channelName = match.channelName || match.channel_name || null;
            }
          }
        } catch (_) {}
      }
    }

    // Lookup channel-specific webhook if configured (after resolving channelId via fallbacks)
    try {
      if (channelId) {
        const w = await client.query('SELECT webhook_url FROM channel_filters WHERE channel_id = $1', [channelId]);
        if (w.rows.length > 0 && w.rows[0].webhook_url) webhookUrl = String(w.rows[0].webhook_url);
      }
    } catch (_) {}
    const raidName = isNax ? 'Nax' : 'AQ40+';
    const encodedEventId = encodeURIComponent(String(eventId));
    const assignmentsUrl = `https://www.1principles.net/event/${encodedEventId}/assignments`;

    const descriptionParts = [];
    descriptionParts.push(`Please whisper ${invitePerson} the keyword \"inv\" for an automatic invite.`);
    descriptionParts.push(`- ${invitePerson}`);
    descriptionParts.push('');
    descriptionParts.push('Once the summon team is ready, you can write \"123\" in the raid chat for a summon.');
    descriptionParts.push('');
    descriptionParts.push('**Remember your stuff:**');
    descriptionParts.push('‚Ä¢ Consumables & Flasks');
    descriptionParts.push('‚Ä¢ Frost and Shadow protection potions');
    descriptionParts.push('‚Ä¢ World Buffs');
    descriptionParts.push('‚Ä¢ Frost Resistance gear');
    descriptionParts.push('‚Ä¢ Target Dummies, sappers and dynamite');
    descriptionParts.push('‚Ä¢ Goblin Rocket Helmet');
    descriptionParts.push('‚Ä¢ 2 √ó Zanza flasks');
    descriptionParts.push('');
    descriptionParts.push('**Assignments:**');
    // Use generic label to avoid mislabeling if flags are stale
    descriptionParts.push(`If you have not read your assignments yet, go to [assignments](${assignmentsUrl}) and read through and confirm your assignments by clicking the grey checkmark icon next to your personal assignments (you must be logged in to confirm).`);
    descriptionParts.push('');
    descriptionParts.push('**Last chance:**');
    descriptionParts.push('In order to get a full gold cut, you must be in the raid and ready to pull, no later than 10 minutes before start.');

    const embed = {
      title: `üö®üö® Invites are up! üö®üö®`,
      description: descriptionParts.join('\n'),
      color: 0x5865F2,
      url: assignmentsUrl,
      thumbnail: { url: 'https://www.1principles.net/images/1p_logo.png' },
      timestamp: new Date().toISOString(),
      footer: { text: '1Principles' }
    };

    // Build proper Discord mentions using user IDs when provided
    let content = undefined;
    let allowed_mentions = undefined;
    const ids = Array.isArray(mentionUserIds) ? mentionUserIds.filter(Boolean).map(String) : [];
    if (ids.length > 0) {
      content = ids.map(id => `<@${id}>`).join(' ');
      allowed_mentions = { parse: [], users: ids };
    } else if (mentionContent && String(mentionContent).trim()) {
      content = String(mentionContent);
    }

    const payload = content ? { content, embeds: [embed], allowed_mentions } : { embeds: [embed] };
    // Require a webhook URL
    if (!webhookUrl) {
      return res.status(400).json({ ok: false, error: 'No webhook configured for this channel' });
    }
    const response = await fetchWithTimeout(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }, 10000);
    if (!response.ok) {
      const errText = await response.text();
      return res.status(response.status).json({ ok: false, error: errText });
    }
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  } finally {
    if (client) client.release();
  }
});

// Send gold cut confirmation DM (embed) to a specific user
// Frontend composes rewards/deductions from the Gold page and sends here.
app.post('/api/discord/prompt-goldcuts', requireRosterManager, async (req, res) => {
  try {
    const botToken = process.env.DISCORD_BOT_TOKEN;
    if (!botToken) {
      return res.status(500).json({ ok: false, error: 'DISCORD_BOT_TOKEN not set' });
    }

    const body = req.body || {};
    const userId = body.userId ? String(body.userId) : '';
    const playerName = body.playerName ? String(body.playerName) : '';
    const eventId = body.eventId ? String(body.eventId) : '';
    const rewards = Array.isArray(body.rewards) ? body.rewards : [];
    const deductions = Array.isArray(body.deductions) ? body.deductions : [];
    const totalPoints = Number(body.totalPoints) || 0;
    const totalGold = Number(body.totalGold) || 0;
    if (!userId) {
      return res.status(400).json({ ok: false, error: 'userId is required' });
    }

    // 1) Ensure DM channel exists
    const dmResponse = await discordFetch('https://discord.com/api/v10/users/@me/channels', {
      method: 'POST',
      headers: {
        'Authorization': `Bot ${botToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ recipient_id: userId })
    }, { maxRetries: 3, timeoutMs: 10000 });
    if (!dmResponse.ok) {
      const errText = await dmResponse.text();
      return res.status(dmResponse.status).json({ ok: false, step: 'create_dm', error: errText });
    }
    const dmJson = await dmResponse.json();
    const dmChannelId = dmJson && dmJson.id;
    if (!dmChannelId) {
      return res.status(500).json({ ok: false, error: 'Failed to create DM channel' });
    }

    const title = 'Confirm your gold cut';
    const description = 'Please check that all your rewards and deductions are correct. If you find any errors, let us know on Discord immediately. We will start paying out gold in 5 minutes. Any issues reported after payouts begin will not be compensated.';

    const fmt = (n) => `${n > 0 ? '' : ''}${Math.trunc(n)}`;
    const iconFor = (pts, gld) => {
      const p = Number(pts) || 0; const g = Number(gld) || 0;
      if (p < 0 || g < 0) return 'üî¥';
      if (p > 0 || g > 0) return 'üü¢';
      return '‚ö™';
    };
    const mkField = (label, pts, gld, forceSign) => {
      const icon = forceSign === 'pos' ? 'üü¢' : (forceSign === 'neg' ? 'üî¥' : iconFor(pts, gld));
      return {
        name: `${String(label || '')} ${icon}`,
        value: `${fmt(pts)} pts / ${fmt(gld)} gold`,
        inline: true
      };
    };

    const fields = [];
    // Player will be shown as author (above title/description) instead of a field
    if (rewards.length) {
      rewards.forEach(it => {
        const label = it && (it.label || it.title) || '';
        const pts = Number(it && (it.points != null ? it.points : it.pts)) || 0;
        const gld = Number(it && it.gold) || 0;
        fields.push(mkField(label, pts, gld, 'pos'));
      });
    }
    if (deductions.length) {
      deductions.forEach(it => {
        const label = it && (it.label || it.title) || '';
        const pts = Number(it && (it.points != null ? it.points : it.pts)) || 0;
        const gld = Number(it && it.gold) || 0;
        fields.push(mkField(label, pts, gld, 'neg'));
      });
    }
    // Totals block: compact single field
    const totalsPts = Math.trunc(totalPoints);
    const totalsGold = Math.trunc(totalGold).toLocaleString();
    fields.push({ name: 'Your totals', value: `üßÆ ${totalsPts} pts ‚Ä¢ ü™ô ${totalsGold} gold`, inline: false });

    if (eventId) {
      const encodedEventId = encodeURIComponent(eventId);
      const goldUrl = `https://www.1principles.net/event/${encodedEventId}/gold`;
      const logsUrl = `https://www.1principles.net/event/${encodedEventId}/raidlogs`;
      fields.push({ name: 'Links', value: `[Go to Gold page](${goldUrl})\n[Go to Raidlogs page](${logsUrl})`, inline: false });
    }

    const embed = {
      title,
      description,
      color: 0xF59E0B,
      fields,
      thumbnail: { url: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1758109057/gready_orc_zvosup.jpg' },
      timestamp: new Date().toISOString()
    };
    if (playerName) {
      embed.author = { name: `Player: ${playerName}` };
    }
    const payload = { embeds: [embed] };

    const msgResponse = await discordFetch(`https://discord.com/api/v10/channels/${dmChannelId}/messages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bot ${botToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    }, { maxRetries: 3, timeoutMs: 10000 });
    if (!msgResponse.ok) {
      const errText = await msgResponse.text();
      return res.status(msgResponse.status).json({ ok: false, step: 'send_message', error: errText });
    }
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  }
});

// Prompt a specific user via DM to confirm (test version sends a simple message)
app.post('/api/discord/prompt-confirmation', requireRosterManager, async (req, res) => {
  try {
    const botToken = process.env.DISCORD_BOT_TOKEN;
    if (!botToken) {
      return res.status(500).json({ ok: false, error: 'DISCORD_BOT_TOKEN not set' });
    }
    const body = req.body || {};
    const userId = body.userId ? String(body.userId) : '';
    const message = body.message || 'Hello World 456';
    const eventId = body.eventId ? String(body.eventId) : null;
    if (!userId) {
      return res.status(400).json({ ok: false, error: 'userId is required' });
    }

    // 1) Ensure DM channel exists
    const dmResponse = await discordFetch('https://discord.com/api/v10/users/@me/channels', {
      method: 'POST',
      headers: {
        'Authorization': `Bot ${botToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ recipient_id: userId })
    }, { maxRetries: 3, timeoutMs: 10000 });
    if (!dmResponse.ok) {
      const errText = await dmResponse.text();
      return res.status(dmResponse.status).json({ ok: false, step: 'create_dm', error: errText });
    }
    const dmJson = await dmResponse.json();
    const dmChannelId = dmJson && dmJson.id;
    if (!dmChannelId) {
      return res.status(500).json({ ok: false, error: 'Failed to create DM channel' });
    }

    // Compose context-aware message
    let finalMessage = message;
    if (eventId) {
      try {
        // Build day/date/time string and roster link
        const encodedEventId = encodeURIComponent(String(eventId));
        const rosterLink = `https://www.1principles.net/event/${encodedEventId}/roster`;
        // Attempt to get event time and channel
        let startsAtUtc = null;
        let channelId = null;
        let channelName = null;
        let isNax = false;
        const ev = await pool.query(`SELECT event_data FROM raid_helper_events_cache WHERE event_id = $1`, [eventId]);
        if (ev.rows.length > 0) {
          const data = ev.rows[0].event_data || {};
          // Try to extract a start timestamp from multiple possible fields
          const timeCandidates = [data.startsAt, data.startTime, data.time, data.date, data.scheduledTime, data.scheduled_at, data.start_timestamp, data.timestamp];
          for (const t of timeCandidates) {
            if (startsAtUtc) break;
            if (t == null) continue;
            if (typeof t === 'number') {
              const secs = t > 1e12 ? Math.floor(t / 1000) : t;
              startsAtUtc = new Date(secs * 1000);
            } else if (typeof t === 'string') {
              const digits = t.match(/^\d{10,13}$/) ? Number(t) : NaN;
              if (!isNaN(digits)) {
                const secs = digits > 1e12 ? Math.floor(digits / 1000) : digits;
                startsAtUtc = new Date(secs * 1000);
              } else {
                const d = new Date(t);
                if (!isNaN(d.getTime())) startsAtUtc = d;
              }
            }
            if (startsAtUtc && isNaN(startsAtUtc.getTime())) startsAtUtc = null;
          }
          channelId = data.channelId || data.channelID || data.channel_id || null;
          channelName = data.channelName || data.channel_name || null;
          // Try determine isNax from DB flag if channelId present
          try {
            if (channelId) {
              const cf = await pool.query('SELECT is_nax FROM channel_filters WHERE channel_id = $1', [channelId]);
              if (cf.rows.length > 0) isNax = !!cf.rows[0].is_nax;
            }
            if (!isNax && channelName) {
              const lower = String(channelName).toLowerCase();
              if (lower.includes('nax') || lower.includes('naxx')) isNax = true;
            }
          } catch (_) {}
        }
        // Fallback 1 for time: try events cache blob posted events
        if (!startsAtUtc) {
          try {
            const cached = await pool.query(
              `SELECT events_data FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()`,
              ['raid_helper_events']
            );
            if (cached.rows.length > 0) {
              const eventsBlob = cached.rows[0].events_data || {};
              const list = Array.isArray(eventsBlob.postedEvents) ? eventsBlob.postedEvents : (Array.isArray(eventsBlob) ? eventsBlob : []);
              const match = list.find(e => String(e.id) === String(eventId));
              if (match) {
                const mc = [match.startsAt, match.startTime, match.time, match.date, match.scheduledTime, match.scheduled_at, match.start_timestamp, match.timestamp];
                for (const t of mc) {
                  if (startsAtUtc) break;
                  if (t == null) continue;
                  if (typeof t === 'number') {
                    const secs = t > 1e12 ? Math.floor(t / 1000) : t;
                    startsAtUtc = new Date(secs * 1000);
                  } else if (typeof t === 'string') {
                    const digits = t.match(/^\d{10,13}$/) ? Number(t) : NaN;
                    if (!isNaN(digits)) {
                      const secs = digits > 1e12 ? Math.floor(digits / 1000) : digits;
                      startsAtUtc = new Date(secs * 1000);
                    } else {
                      const d = new Date(t);
                      if (!isNaN(d.getTime())) startsAtUtc = d;
                    }
                  }
                  if (startsAtUtc && isNaN(startsAtUtc.getTime())) startsAtUtc = null;
                }
                // Also consider isNax from this match if still unknown
                try {
                  if (!isNax) {
                    const cname = match.channelName || match.channel_name || null;
                    if (cname) {
                      const lower = String(cname).toLowerCase();
                      if (lower.includes('nax') || lower.includes('naxx')) isNax = true;
                    }
                  }
                } catch (_) {}
              }
            }
          } catch (_) {}
        }
        // Fallback 2 for time: query v3 servers endpoint
        if (!startsAtUtc) {
          try {
            const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
            const guildId = process.env.DISCORD_GUILD_ID || '777268886939893821';
            if (raidHelperApiKey) {
              const nowUnixTimestamp = Math.floor(Date.now() / 1000);
              const oneYearInSeconds = 365 * 24 * 60 * 60;
              const futureUnixTimestamp = nowUnixTimestamp + oneYearInSeconds;
              const resp = await axios.get(`https://raid-helper.dev/api/v3/servers/${guildId}/events`, {
                headers: { 'Authorization': `${raidHelperApiKey}`, 'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)' },
                params: { StartTimeFilter: nowUnixTimestamp - 7 * 24 * 3600, EndTimeFilter: futureUnixTimestamp },
                timeout: 10000
              });
              const events = resp.data && Array.isArray(resp.data.postedEvents) ? resp.data.postedEvents : [];
              const match = events.find(e => String(e.id) === String(eventId));
              if (match) {
                const mc = [match.startsAt, match.startTime, match.time, match.date, match.scheduledTime, match.scheduled_at, match.start_timestamp, match.timestamp];
                for (const t of mc) {
                  if (startsAtUtc) break;
                  if (t == null) continue;
                  if (typeof t === 'number') {
                    const secs = t > 1e12 ? Math.floor(t / 1000) : t;
                    startsAtUtc = new Date(secs * 1000);
                  } else if (typeof t === 'string') {
                    const digits = t.match(/^\d{10,13}$/) ? Number(t) : NaN;
                    if (!isNaN(digits)) {
                      const secs = digits > 1e12 ? Math.floor(digits / 1000) : digits;
                      startsAtUtc = new Date(secs * 1000);
                    } else {
                      const d = new Date(t);
                      if (!isNaN(d.getTime())) startsAtUtc = d;
                    }
                  }
                  if (startsAtUtc && isNaN(startsAtUtc.getTime())) startsAtUtc = null;
                }
                // Also consider isNax from this match if still unknown
                try {
                  if (!isNax) {
                    const cname = match.channelName || match.channel_name || null;
                    if (cname) {
                      const lower = String(cname).toLowerCase();
                      if (lower.includes('nax') || lower.includes('naxx')) isNax = true;
                    }
                  }
                } catch (_) {}
              }
            }
          } catch (_) {}
        }
        // If unknown, show explicit placeholder instead of current time
        let dayDateTime;
        if (startsAtUtc) {
          const dt = startsAtUtc;
          const tz = 'Europe/Copenhagen';
          const weekday = dt.toLocaleDateString('en-GB', { weekday: 'long', timeZone: tz });
          const ddmmyyyy = dt.toLocaleDateString('en-GB', { timeZone: tz }).replace(/\//g, '-');
          const defaultStart = isNax ? '20:30' : '20:00';
          dayDateTime = `${weekday} the ${ddmmyyyy} at ${defaultStart}`;
        } else {
          dayDateTime = '[start time not found]';
        }
        const channelJump = channelId ? `https://discord.com/channels/${process.env.DISCORD_GUILD_ID || '@me'}/${channelId}` : (channelName ? `#${channelName}` : '#raid-channel');
        finalMessage = `You have not yet confirmed your spot for ${dayDateTime}.`;
      } catch (_) {}
    }

    // 2) Send the DM (as an embed for cleaner formatting and masked links)
    let payload;
    if (eventId) {
      // Recompute pieces used for masked links
      const encodedEventId = encodeURIComponent(String(eventId));
      const rosterLink = `https://www.1principles.net/event/${encodedEventId}/roster`;
      const ev2 = await pool.query(`SELECT event_data FROM raid_helper_events_cache WHERE event_id = $1`, [eventId]);
      let channelId2 = null;
      let channelName2 = null;
      if (ev2.rows.length > 0) {
        const data2 = ev2.rows[0].event_data || {};
        channelId2 = data2.channelId || data2.channelID || data2.channel_id || null;
        channelName2 = data2.channelName || data2.channel_name || null;
      }
      // Fallback 1: look into cached upcoming events blob for channelId
      if (!channelId2) {
        try {
          const cached = await pool.query(
            `SELECT events_data FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()`,
            ['raid_helper_events']
          );
          if (cached.rows.length > 0) {
            const eventsBlob = cached.rows[0].events_data || {};
            const list = Array.isArray(eventsBlob.postedEvents) ? eventsBlob.postedEvents : (Array.isArray(eventsBlob) ? eventsBlob : []);
            const match = list.find(e => String(e.id) === String(eventId));
            if (match) {
              channelId2 = match.channelId || match.channelID || match.channel_id || null;
              channelName2 = match.channelName || match.channel_name || null;
            }
          }
        } catch (_) {}
      }
      // Fallback 2: query v3 servers endpoint directly
      if (!channelId2) {
        try {
          const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
          const guildId = process.env.DISCORD_GUILD_ID || '777268886939893821';
          if (raidHelperApiKey) {
            const nowUnixTimestamp = Math.floor(Date.now() / 1000);
            const oneYearInSeconds = 365 * 24 * 60 * 60;
            const futureUnixTimestamp = nowUnixTimestamp + oneYearInSeconds;
            const resp = await axios.get(`https://raid-helper.dev/api/v3/servers/${guildId}/events`, {
              headers: { 'Authorization': `${raidHelperApiKey}`, 'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)' },
              params: { StartTimeFilter: nowUnixTimestamp - 7 * 24 * 3600, EndTimeFilter: futureUnixTimestamp },
              timeout: 10000
            });
            const events = resp.data && Array.isArray(resp.data.postedEvents) ? resp.data.postedEvents : [];
            const match = events.find(e => String(e.id) === String(eventId));
            if (match) {
              channelId2 = match.channelId || match.channelID || match.channel_id || null;
              channelName2 = match.channelName || match.channel_name || null;
            }
          }
        } catch (_) {}
      }
      const guildId = process.env.DISCORD_GUILD_ID || '@me';
      const channelJump = channelId2 ? `https://discord.com/channels/${guildId}/${channelId2}` : null;
      const channelLabel = channelName2 ? `#${channelName2}` : 'raid channel';
      const channelPart = channelJump ? `[${channelLabel}](${channelJump})` : channelLabel;

      const embedDescription = `${finalMessage}\n\nPlease go to our ${channelPart} channel and confirm your spot, so we can complete the raid assignments and secure a clean and smooth raid.`;
      const embed = {
        title: 'Confirm your spot',
        description: embedDescription,
        color: 0xF59E0B,
        image: { url: 'https://res.cloudinary.com/duthjs0c3/image/upload/f_auto,q_auto,w_1280/v1755779009/8cc6a2d6-dafe-4348-969f-63fdb8d131f8_qflurq.png' },
        timestamp: new Date().toISOString()
      };
      payload = { embeds: [embed] };
    } else {
      payload = { content: finalMessage };
    }

    const msgResponse = await discordFetch(`https://discord.com/api/v10/channels/${dmChannelId}/messages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bot ${botToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    }, { maxRetries: 3, timeoutMs: 10000 });
    if (!msgResponse.ok) {
      const errText = await msgResponse.text();
      return res.status(msgResponse.status).json({ ok: false, step: 'send_message', error: errText });
    }
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  }
});

// Prompt a specific user via DM to invite (uses a red embed and includes channel/character/invite person)
app.post('/api/discord/prompt-invite', requireRosterManager, async (req, res) => {
  try {
    const botToken = process.env.DISCORD_BOT_TOKEN;
    if (!botToken) {
      return res.status(500).json({ ok: false, error: 'DISCORD_BOT_TOKEN not set' });
    }
    const body = req.body || {};
    const userId = body.userId ? String(body.userId) : '';
    const eventId = body.eventId ? String(body.eventId) : null;
    const characterName = body.characterName ? String(body.characterName) : null;
    const invitePerson = body.invitePerson ? String(body.invitePerson) : null;
    if (!userId) {
      return res.status(400).json({ ok: false, error: 'userId is required' });
    }
    if (!eventId) {
      return res.status(400).json({ ok: false, error: 'eventId is required' });
    }
    if (!characterName) {
      return res.status(400).json({ ok: false, error: 'characterName is required' });
    }
    if (!invitePerson) {
      return res.status(400).json({ ok: false, error: 'invitePerson is required' });
    }

    // 1) Ensure DM channel exists
    const dmResponse = await fetch('https://discord.com/api/v10/users/@me/channels', {
      method: 'POST',
      headers: {
        'Authorization': `Bot ${botToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ recipient_id: userId })
    });
    if (!dmResponse.ok) {
      const errText = await dmResponse.text();
      return res.status(dmResponse.status).json({ ok: false, step: 'create_dm', error: errText });
    }
    const dmJson = await dmResponse.json();
    const dmChannelId = dmJson && dmJson.id;
    if (!dmChannelId) {
      return res.status(500).json({ ok: false, error: 'Failed to create DM channel' });
    }

    // 2) Resolve channel info to produce a friendly channel label and jump link
    let channelId = null;
    let channelName = null;
    try {
      const ev = await pool.query(`SELECT event_data FROM raid_helper_events_cache WHERE event_id = $1`, [eventId]);
      if (ev.rows.length > 0) {
        const data = ev.rows[0].event_data || {};
        channelId = data.channelId || data.channelID || data.channel_id || null;
        channelName = data.channelName || data.channel_name || null;
      }
      if (!channelId) {
        try {
          const cached = await pool.query(
            `SELECT events_data FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()`,
            ['raid_helper_events']
          );
          if (cached.rows.length > 0) {
            const eventsBlob = cached.rows[0].events_data || {};
            const list = Array.isArray(eventsBlob.postedEvents) ? eventsBlob.postedEvents : (Array.isArray(eventsBlob) ? eventsBlob : []);
            const match = list.find(e => String(e.id) === String(eventId));
            if (match) {
              channelId = match.channelId || match.channelID || match.channel_id || null;
              channelName = match.channelName || match.channel_name || null;
            }
          }
        } catch (_) {}
      }
      if (!channelId) {
        try {
          const raidHelperApiKey = process.env.RAID_HELPER_API_KEY;
          const guildId = process.env.DISCORD_GUILD_ID || '777268886939893821';
          if (raidHelperApiKey) {
            const nowUnixTimestamp = Math.floor(Date.now() / 1000);
            const oneYearInSeconds = 365 * 24 * 60 * 60;
            const futureUnixTimestamp = nowUnixTimestamp + oneYearInSeconds;
            const resp = await axios.get(`https://raid-helper.dev/api/v3/servers/${guildId}/events`, {
              headers: { 'Authorization': `${raidHelperApiKey}`, 'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)' },
              params: { StartTimeFilter: nowUnixTimestamp - 7 * 24 * 3600, EndTimeFilter: futureUnixTimestamp },
              timeout: 10000
            });
            const events = resp.data && Array.isArray(resp.data.postedEvents) ? resp.data.postedEvents : [];
            const match = events.find(e => String(e.id) === String(eventId));
            if (match) {
              channelId = match.channelId || match.channelID || match.channel_id || null;
              channelName = match.channelName || match.channel_name || null;
            }
          }
        } catch (_) {}
      }
    } catch (_) {}

    const guildId = process.env.DISCORD_GUILD_ID || '@me';
    const channelJump = channelId ? `https://discord.com/channels/${guildId}/${channelId}` : null;
    const channelLabel = channelName ? `#${channelName}` : (channelId ? `#channel-${String(channelId).slice(-4)}` : '#raid-channel');
    const channelPart = channelJump ? `[${channelLabel}](${channelJump})` : channelLabel;

    // 3) Build and send embed
    const embedDescription = `The invites for ${channelPart} has started and we are still waiting for you to join.\n\nLog on ${characterName} and whisper ${invitePerson} the keyword "inv" for  invite. Once in the raid, write "123" in the raid chat to get a summon.`;
    const embed = {
      title: 'Time to join the raid!',
      description: embedDescription,
      color: 0xDC2626,
      image: { url: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1756283173/b3f33037-00cf-4558-94a1-611a6ca32072_devlqr.png' },
      timestamp: new Date().toISOString()
    };
    const payload = { embeds: [embed] };

    const msgResponse = await fetch(`https://discord.com/api/v10/channels/${dmChannelId}/messages`, {
      method: 'POST',
      headers: {
        'Authorization': `Bot ${botToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    if (!msgResponse.ok) {
      const errText = await msgResponse.text();
      return res.status(msgResponse.status).json({ ok: false, step: 'send_message', error: errText });
    }
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  }
});

app.get('/auth/logout', (req, res, next) => {
  req.logout((err) => {
    if (err) { return next(err); }
    res.redirect('/');
  });
});

app.get('/user', async (req, res) => {
  if (req.isAuthenticated()) {
    try {
      // Local DB roles only
      const perms = await getUserPermissionsFromDb(req.user.id);
      const isManagement = !!(perms && perms.hasManagementRole);
      const isHelper = !!(perms && perms.hasHelperRole);

      res.json({
        loggedIn: true,
        id: req.user.id,
        username: req.user.username,
        discriminator: req.user.discriminator,
        avatar: req.user.avatar,
        email: req.user.email,
        hasManagementRole: isManagement,
        hasHelperRole: isHelper,
        permissions: {
          canManage: isManagement,
          canManageRoster: (isManagement || isHelper)
        }
      });
    } catch (error) {
      console.error('Error fetching user permissions:', error);
      res.json({
        loggedIn: true,
        id: req.user.id,
        username: req.user.username,
        discriminator: req.user.discriminator,
        avatar: req.user.avatar,
        email: req.user.email,
        hasManagementRole: false,
        hasHelperRole: false,
        permissions: {
          canManage: false,
          canManageRoster: false
        }
      });
    }
  } else {
    res.json({ loggedIn: false });
  }
});

// Warcraft Logs events incremental polling endpoint
// Query params:
// - report: report code or full URL
// - cursor: nextPageTimestamp from previous response, or 0 to start
// - windowMs: how far ahead to request from cursor (default 15000ms)
app.get('/api/wcl/events', async (req, res) => {
  try {
    const reportInput = String(req.query.report || '');
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) {
      return res.status(400).json({ error: 'Missing or invalid report parameter' });
    }
    const cursor = Number(req.query.cursor || 0);
    const windowMs = Math.min(60000, Math.max(1000, Number(req.query.windowMs || 15000)));
    let start = Math.max(0, Math.floor(cursor));
    const apiUrl = getWclApiUrlFromInput(reportInput);
    // If first request and no data yet, jump to earliest fight start (buffered back by 5s)
    if (start === 0) {
      const earliest = await fetchWclEarliestFightStart({ reportCode, apiUrl });
      if (earliest > 0) {
        start = Math.max(0, earliest - 5000);
      }
    }
    const end = start + windowMs;

    const page = await fetchWclEventsPage({ reportCode, startTime: start, endTime: end, apiUrl });
    const meta = await fetchWclReportMeta({ reportCode, apiUrl });
    // Ensure monotonic next cursor: prefer API nextPageTimestamp; otherwise advance by window
    const nextCursor = page.nextPageTimestamp != null ? page.nextPageTimestamp : end;

    // Update shared live progress only when host advances (prevents viewers from racing ahead)
    try {
      if (activeLive && typeof activeLive.reportInput === 'string') {
        const sameReport = extractWclReportCode(activeLive.reportInput) === reportCode;
        if (sameReport && req.isAuthenticated && req.isAuthenticated()) {
          const isHost = activeLive.startedBy && String(req.user && req.user.id) === String(activeLive.startedBy.id);
          if (isHost) {
            const candidate = Math.max(start, nextCursor);
            if (typeof candidate === 'number' && (activeLive.currentCursorMs == null || candidate > activeLive.currentCursorMs)) {
              activeLive.currentCursorMs = candidate;
            }
          }
        }
      }
    } catch (_) {}

    // If a shared session is active for this report, update host-side snapshot using the raw events
    try {
      if (activeLive && extractWclReportCode(activeLive.reportInput) === reportCode) {
        const actors = meta.actorsById || {};
        const abilities = meta.abilitiesById || {};
        const stats = activeLive.stats;
        if (stats) {
          for (const ev of page.events) {
            const type = (ev.type || '').toLowerCase();
            const ts = ev.timestamp || 0;
            // Encounter markers
            if (type === 'encounterstart' || type === 'encounterend') {
              const name = ev.encounterName || ev.bossName || ev.name || '';
              stats.encounters.push({ name, type: type === 'encounterstart' ? 'start' : 'end', ts });
              if (type === 'encounterstart') {
                stats.encounter.name = name;
                stats.encounter.bySource = {};
              } else {
                stats.encounter.name = null;
              }
              continue;
            }
            const srcId = ev.sourceID || (ev.source && ev.source.id);
            const tgtId = ev.targetID || (ev.target && ev.target.id);
            const srcName = (srcId != null && actors[srcId] && actors[srcId].name) || (ev.source && ev.source.name) || (srcId != null ? `#${srcId}` : null);
            const tgtName = (tgtId != null && actors[tgtId] && actors[tgtId].name) || (ev.target && ev.target.name) || (tgtId != null ? `#${tgtId}` : null);
            const abilityId = ev.abilityGameID || (ev.ability && ev.ability.guid);
            const abilityName = (abilityId != null && abilities[abilityId] && abilities[abilityId].name) || (ev.ability && ev.ability.name) || null;

            // Totals (damage/heal)
            if (type === 'damage' || type === 'heal') {
              const ownerName = ev.source && ev.source.petOwner && ev.source.petOwner.name ? ev.source.petOwner.name : null;
              const tally = ownerName || srcName;
              if (tally) {
                const rec = stats.totalBySource[tally] || { dmg: 0, heal: 0, color: null };
                if (type === 'damage') rec.dmg += Number(ev.amount || 0);
                if (type === 'heal') rec.heal += Number(ev.amount || 0);
                stats.totalBySource[tally] = rec;
                if (stats.encounter && stats.encounter.name) {
                  const er = stats.encounter.bySource[tally] || { dmg: 0, heal: 0, color: rec.color };
                  if (type === 'damage') er.dmg += Number(ev.amount || 0);
                  if (type === 'heal') er.heal += Number(ev.amount || 0);
                  stats.encounter.bySource[tally] = er;
                }
              }
            }
            // Rolling buffers for death context per target
            if ((type === 'damage' || type === 'heal') && tgtName) {
              const key = `tgt:${tgtName.toLowerCase()}`;
              const buf = activeLive.buffers[key] || [];
              buf.push({ ts, type, source: srcName || '', ability: abilityName || '', amount: Number(ev.amount || 0) });
              // Trim to last 10s
              const cutoff = ts - 10000;
              while (buf.length && buf[0].ts < cutoff) buf.shift();
              activeLive.buffers[key] = buf;
            }
            // Death log: host records only assigned players (if we know the assigned set)
            if (type === 'death' && tgtName) {
              let allow = true;
              if (activeLive.assignedSet && activeLive.assignedSet.size > 0) {
                allow = activeLive.assignedSet.has(String(tgtName).toLowerCase());
              }
              if (allow) {
                const key = `${tgtName}@${ts}`;
                const bufKey = `tgt:${tgtName.toLowerCase()}`;
                const lines = (activeLive.buffers[bufKey] || []).slice();
                const lower = String(tgtName).toLowerCase();
                const color = (activeLive.assignedColors && activeLive.assignedColors[lower]) ? activeLive.assignedColors[lower] : null;
                stats.deaths.push({ name: tgtName, ts, color, lines, key });
              }
            }
          }
        }
      }
    } catch (_) {}

    res.json({
      reportStartTime: page.reportStartTime,
      events: page.events,
      nextCursor,
      meta: {
        actorsById: meta.actorsById || {},
        abilitiesById: meta.abilitiesById || {}
      }
    });
  } catch (err) {
    console.error('WCL events error:', err && err.message ? err.message : err);
    res.status(500).json({ error: 'Failed to fetch events', details: String(err && err.message ? err.message : err) });
  }
});

// Simple token status endpoint to debug OAuth
app.get('/api/wcl/token-status', async (req, res) => {
  try {
    const token = await getWclAccessToken();
    res.json({ ok: true, tokenPreview: `${token.slice(0, 8)}...`, expiresAt: wclTokenExpiresAt });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  }
});

// Live API removed

// Map of assigned characters for an event: name -> { class, spec, color, party_id, slot_id }
app.get('/api/events/:eventId/assigned-characters', async (req, res) => {
  try {
    const eventId = req.params.eventId;
    const result = await pool.query(
      `SELECT assigned_char_name, assigned_char_class, assigned_char_spec, player_color, party_id, slot_id
       FROM roster_overrides
       WHERE event_id = $1 AND assigned_char_name IS NOT NULL`,
      [eventId]
    );
    const map = {};
    for (const row of result.rows) {
      if (!row.assigned_char_name) continue;
      const key = String(row.assigned_char_name).toLowerCase();
      map[key] = {
        name: row.assigned_char_name,
        class: row.assigned_char_class || null,
        spec: row.assigned_char_spec || null,
        color: row.player_color || null,
        partyId: row.party_id || null,
        slotId: row.slot_id || null,
      };
    }
    res.json({ assigned: map });
  } catch (err) {
    console.error('assigned-characters error', err);
    res.status(500).json({ error: 'Failed to load assigned characters' });
  }
});

// Live control endpoints removed

// Fights listing for a report
app.get('/api/wcl/fights', async (req, res) => {
  try {
    const reportInput = String(req.query.report || '');
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) return res.status(400).json({ error: 'Missing or invalid report parameter' });
    const apiUrl = getWclApiUrlFromInput(reportInput);
    const fights = await fetchWclFights({ reportCode, apiUrl });
    res.json({ fights });
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch fights', details: String(err && err.message ? err.message : err) });
  }
});

// --- Persist full Warcraft Logs v2 event stream (independent of live) ---
async function ensureWclIngestTables(client) {
  // Create tables if they do not exist
  await client.query(`
    CREATE TABLE IF NOT EXISTS wcl_event_pages (
      id BIGSERIAL PRIMARY KEY,
      event_id TEXT NOT NULL,
      report_code TEXT NOT NULL,
      start_time BIGINT NOT NULL,
      end_time BIGINT NOT NULL,
      next_cursor BIGINT,
      events JSONB NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(event_id, report_code, start_time, end_time)
    );
  `);
  await client.query(`
    CREATE INDEX IF NOT EXISTS idx_wcl_event_pages_event_time ON wcl_event_pages(event_id, start_time);
  `);
  await client.query(`
    CREATE INDEX IF NOT EXISTS idx_wcl_event_pages_report_time ON wcl_event_pages(report_code, start_time);
  `);
  await client.query(`
    CREATE TABLE IF NOT EXISTS wcl_report_meta (
      report_code TEXT PRIMARY KEY,
      api_url TEXT,
      actors_by_id JSONB,
      abilities_by_id JSONB,
      fetched_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);
}

// --- R2 (S3-compatible) client ---
const R2_ENABLED = !!process.env.R2_ENDPOINT && !!process.env.R2_ACCESS_KEY_ID && !!process.env.R2_SECRET_ACCESS_KEY && !!process.env.R2_BUCKET;
let r2Client = null;
if (R2_ENABLED) {
  try {
    r2Client = new S3Client({
      region: 'auto',
      endpoint: process.env.R2_ENDPOINT,
      forcePathStyle: true,
      credentials: {
        accessKeyId: process.env.R2_ACCESS_KEY_ID,
        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY
      }
    });
  } catch (e) {
    console.warn('‚ö†Ô∏è Failed to initialize R2 client:', e && e.message ? e.message : e);
  }
}

async function ensureEventFolderMarkers(eventId, reportCode) {
  if (!R2_ENABLED || !r2Client) return;
  const payload = JSON.stringify({ eventId, reportCode, createdAt: new Date().toISOString(), note: 'folder visibility marker' });
  try {
    await putObjectWithTimeout({ Bucket: process.env.R2_BUCKET, Key: `${eventId}/_marker.json`, ContentType: 'application/json', Body: payload });
  } catch (_) {}
  try {
    await putObjectWithTimeout({ Bucket: process.env.R2_BUCKET, Key: `events/${eventId}/_marker.json`, ContentType: 'application/json', Body: payload });
  } catch (_) {}
  try {
    if (reportCode) {
      await putObjectWithTimeout({ Bucket: process.env.R2_BUCKET, Key: `events/${eventId}/${reportCode}/_marker.json`, ContentType: 'application/json', Body: payload });
    }
  } catch (_) {}
}

// Utility: PutObject with timeout and one retry
async function putObjectWithTimeout(params, timeoutMs) {
  const cmd = new PutObjectCommand(params);
  const ms = Math.max(5000, Number(timeoutMs || process.env.R2_UPLOAD_TIMEOUT || 60000));
  async function once() {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), ms);
    try {
      return await r2Client.send(cmd, { abortSignal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }
  try {
    return await once();
  } catch (err) {
    // Retry once after brief delay
    await new Promise(r => setTimeout(r, 500));
    return await once();
  }
}

// In-memory export tracker (simple)
const activeExports = new Map(); // key: `${eventId}::${reportCode}` -> { startedAt, lastCursor, pages, totalEvents, reportMaxEnd, done, error }

function makeExportKey(eventId, reportCode){ return `${eventId}::${reportCode}`; }

// Utility to export all events for a report/event as multiple JSONL page files uploaded to R2
async function exportFullEventsToR2(params) {
  const { eventId, reportCode, apiUrl } = params;
  if (!R2_ENABLED || !r2Client) return { ok: false, error: 'R2 not configured' };
  try { await ensureEventFolderMarkers(eventId, reportCode); } catch (_) {}
  // Upload each page as its own JSONL object to avoid large memory usage
  let startCursor = 0;
  let reportMaxEnd = null;
  try {
    const [earliestRes, fightsRes] = await Promise.allSettled([
      fetchWclEarliestFightStart({ reportCode, apiUrl }),
      fetchWclFights({ reportCode, apiUrl })
    ]);
    if (earliestRes.status === 'fulfilled') {
      const earliest = earliestRes.value;
      if (earliest > 0) startCursor = Math.max(0, earliest - 5000);
    }
    if (fightsRes.status === 'fulfilled') {
      const fights = fightsRes.value || [];
      for (const f of fights) {
        if (f && typeof f.endTime === 'number') reportMaxEnd = reportMaxEnd == null ? f.endTime : Math.max(reportMaxEnd, f.endTime);
      }
    }
  } catch {}
  const windowMs = 30000;
  let lastCursor = startCursor;
  let guard = 0;
  const uploaded = [];
  let totalEvents = 0;
  while (guard < 200000) {
    const end = lastCursor + windowMs;
    let page;
    try {
      page = await fetchWclEventsPage({ reportCode, startTime: lastCursor, endTime: end, apiUrl });
    } catch (err) {
      return { ok: false, error: `Failed to fetch events page: ${String(err && err.message ? err.message : err)}` };
    }
    const events = Array.isArray(page.events) ? page.events : [];
    totalEvents += events.length;
    // Serialize this page as JSONL
    if (events.length > 0) {
      let bodyStr = '';
      try {
        bodyStr = events.map(e => { try { return JSON.stringify(e); } catch { return ''; } }).filter(Boolean).join('\n');
      } catch {}
      const key = `events/${eventId}/${reportCode}/page_${lastCursor}_${end}.jsonl`;
      const gzBody = zlib.gzipSync(Buffer.from(bodyStr));
      try {
        await r2Client.send(new PutObjectCommand({
          Bucket: process.env.R2_BUCKET,
          Key: key,
          ContentType: 'application/jsonl',
          ContentEncoding: 'gzip',
          Body: gzBody
        }));
        uploaded.push({ key, start: lastCursor, end, count: events.length });
      } catch (err) {
        return { ok: false, error: `Failed to upload page to R2: ${String(err && err.message ? err.message : err)}` };
      }
    }
    const nextCursor = page.nextPageTimestamp != null ? page.nextPageTimestamp : end;
    if (nextCursor == null || nextCursor <= lastCursor) break;
    lastCursor = nextCursor;
    if (reportMaxEnd != null && lastCursor >= (reportMaxEnd + 60000)) break;
    guard++;
  }
  // Upload a small manifest to help consumers
  const manifestKey = `events/${eventId}/${reportCode}/manifest.json`;
  const manifest = {
    eventId,
    reportCode,
    totalEvents,
    startCursor,
    lastCursor,
    reportMaxEnd,
    windowMs,
    uploaded
  };
  try {
    await r2Client.send(new PutObjectCommand({
      Bucket: process.env.R2_BUCKET,
      Key: manifestKey,
      ContentType: 'application/json',
      Body: JSON.stringify(manifest)
    }));
  } catch {}
  return { ok: true, manifestKey, pages: uploaded.length, totalEvents };
}

// Background export with progress updates
async function exportFullEventsToR2Background(eventId, reportCode, apiUrl){
  const key = makeExportKey(eventId, reportCode);
  const state = { startedAt: Date.now(), lastCursor: 0, pages: 0, totalEvents: 0, reportMaxEnd: null, done: false, error: null, workers: [], processedMs: 0, totalDurationMs: null };
  activeExports.set(key, state);
  try {
    try { await ensureEventFolderMarkers(eventId, reportCode); } catch (_) {}
    // Determine start and end (parallelized)
    let startCursor = 0;
    let reportMaxEnd = null;
    try {
      const [earliestRes, fightsRes] = await Promise.allSettled([
        fetchWclEarliestFightStart({ reportCode, apiUrl }),
        fetchWclFights({ reportCode, apiUrl })
      ]);
      if (earliestRes.status === 'fulfilled') {
        const earliest = earliestRes.value;
        if (earliest > 0) startCursor = Math.max(0, earliest - 5000);
      }
      if (fightsRes.status === 'fulfilled') {
        const fights = fightsRes.value || [];
        for (const f of fights) {
          if (f && typeof f.endTime === 'number') reportMaxEnd = reportMaxEnd == null ? f.endTime : Math.max(reportMaxEnd, f.endTime);
        }
      }
    } catch {}
    state.reportMaxEnd = reportMaxEnd;

    // If report end unknown, fallback to sequential pipelined export
    if (reportMaxEnd == null) {
      const windowMs = 30000;
      let lastCursor = startCursor;
      let guard = 0;
      const inflight = new Set();
      async function limitUpload(promise) {
        inflight.add(promise);
        promise.finally(() => inflight.delete(promise));
        if (inflight.size >= 3) {
          await Promise.race(inflight);
        }
      }
      while (guard < 200000) {
        const end = lastCursor + windowMs;
        let page;
        try {
          page = await fetchWclEventsPage({ reportCode, startTime: lastCursor, endTime: end, apiUrl });
        } catch (err) {
          state.error = `Failed to fetch events page: ${String(err && err.message ? err.message : err)}`;
          break;
        }
        const events = Array.isArray(page.events) ? page.events : [];
        state.totalEvents += events.length;
        if (events.length > 0) {
          let bodyStr = '';
          try { bodyStr = events.map(e => { try { return JSON.stringify(e); } catch { return ''; } }).filter(Boolean).join('\n'); } catch {}
          const objKey = `events/${eventId}/${reportCode}/page_${lastCursor}_${end}.jsonl`;
          const gzBody = zlib.gzipSync(Buffer.from(bodyStr));
          const uploadPromise = r2Client.send(new PutObjectCommand({ Bucket: process.env.R2_BUCKET, Key: objKey, ContentType: 'application/jsonl', ContentEncoding: 'gzip', Body: gzBody }))
            .then(() => { state.pages += 1; })
            .catch((err) => { state.error = `Failed to upload page to R2: ${String(err && err.message ? err.message : err)}`; });
          await limitUpload(uploadPromise);
        }
        const nextCursor = page.nextPageTimestamp != null ? page.nextPageTimestamp : end;
        state.lastCursor = nextCursor;
        if (nextCursor == null || nextCursor <= lastCursor) break;
        lastCursor = nextCursor;
        guard++;
      }
      // Drain any remaining uploads
      if (inflight.size > 0) {
        await Promise.allSettled(Array.from(inflight));
      }
    } else {
      // Sharded concurrent export
      const reportStart = startCursor;
      const reportEnd = reportMaxEnd + 60000;
      const totalDurationMs = Math.max(0, reportEnd - reportStart);
      state.totalDurationMs = totalDurationMs;

      const concurrency = Math.max(1, Math.min(12, Number(process.env.R2_EXPORT_CONCURRENCY || 6)));
      const shardSize = Math.ceil(totalDurationMs / concurrency);
      const shards = [];
      for (let i = 0; i < concurrency; i++) {
        const s = reportStart + i * shardSize;
        const e = Math.min(reportEnd, s + shardSize);
        if (s < e) shards.push({ shardId: i, start: s, end: e });
      }

      const uploadInflight = new Set();
      async function limitUploadShard(promise) {
        uploadInflight.add(promise);
        promise.finally(() => uploadInflight.delete(promise));
        const limit = Math.max(1, Math.min(8, Number(process.env.R2_UPLOAD_POOL || 4)));
        if (uploadInflight.size >= limit) {
          await Promise.race(uploadInflight);
        }
      }

      function updateProcessed() {
        try {
          let sum = 0;
          for (const w of state.workers) {
            const dur = Math.max(0, Math.min(w.cursor, w.end) - w.start);
            sum += dur;
          }
          state.processedMs = sum;
        } catch {}
      }

      async function runShard(shard) {
        const worker = { id: shard.shardId, start: shard.start, end: shard.end, cursor: shard.start, pages: 0, chunks: 0, events: 0 };
        state.workers.push(worker);
        let windowMs = 60000;
        let guard = 0;
        let chunkBuffer = '';
        let chunkStart = worker.cursor;
        const CHUNK_TARGET = Math.max(128 * 1024, Number(process.env.R2_CHUNK_TARGET || (1 * 1024 * 1024)));
        while (guard < 200000 && worker.cursor < worker.end && !state.error) {
          const pageEnd = Math.min(worker.end, worker.cursor + windowMs);
          let page;
          try {
            page = await fetchWclEventsPage({ reportCode, startTime: worker.cursor, endTime: pageEnd, apiUrl });
            if (!page || typeof page !== 'object') throw new Error('Empty page');
          } catch (err) {
            // backoff simple and retry once
            try {
              await new Promise(r => setTimeout(r, 500));
              page = await fetchWclEventsPage({ reportCode, startTime: worker.cursor, endTime: pageEnd, apiUrl });
              if (!page || typeof page !== 'object') throw new Error('Empty page');
            } catch (e2) {
              state.error = `Failed to fetch events page (worker ${worker.id}): ${String(e2 && e2.message ? e2.message : e2)}`;
              break;
            }
          }
          const events = Array.isArray(page.events) ? page.events : [];
          worker.events += events.length;
          state.totalEvents += events.length;
          if (events.length > 0) {
            try {
              const jsonl = events.map(e => { try { return JSON.stringify(e); } catch { return ''; } }).filter(Boolean).join('\n');
              if (jsonl) {
                if (chunkBuffer) chunkBuffer += '\n' + jsonl; else chunkBuffer = jsonl;
              }
            } catch {}
          }

          // Adaptive windowing
          if (events.length < 200 && !page.nextPageTimestamp) {
            windowMs = Math.min(windowMs * 2, 10 * 60 * 1000);
          } else if (events.length > 3000 || page.nextPageTimestamp) {
            windowMs = Math.max(Math.floor(windowMs / 2), 10 * 1000);
          }

          // Advance cursor
          const nextCursor = page.nextPageTimestamp != null ? page.nextPageTimestamp : pageEnd;
          if (nextCursor == null || nextCursor <= worker.cursor) break;
          worker.cursor = nextCursor;
          worker.pages += 1;
          updateProcessed();

          // Flush chunk if large or shard ended
          const needFlush = chunkBuffer && (Buffer.byteLength(chunkBuffer) >= CHUNK_TARGET || worker.cursor >= worker.end);
          if (needFlush) {
            const cStart = chunkStart;
            const cEnd = worker.cursor;
            const keyName = `events/${eventId}/${reportCode}/chunk_${String(worker.id).padStart(2,'0')}_${cStart}_${cEnd}.jsonl`;
            const gzBody = zlib.gzipSync(Buffer.from(chunkBuffer));
            console.log('[R2 Export] Upload start', keyName, 'bytes=', gzBody.length);
            const uploadPromise = putObjectWithTimeout({ Bucket: process.env.R2_BUCKET, Key: keyName, ContentType: 'application/jsonl', ContentEncoding: 'gzip', Body: gzBody })
              .then(() => { worker.chunks += 1; state.pages += 1; console.log('[R2 Export] Upload complete', keyName); })
              .catch((err) => { state.error = `Failed to upload chunk to R2: ${String(err && err.message ? err.message : err)}`; console.warn('[R2 Export] Upload error', keyName, state.error); });
            await limitUploadShard(uploadPromise);
            chunkBuffer = '';
            chunkStart = worker.cursor;
          }

          guard++;
        }
        // Flush any remaining buffered lines for this shard
        if (!state.error && chunkBuffer) {
          const cStart = chunkStart;
          const cEnd = worker.cursor;
          const keyName = `events/${eventId}/${reportCode}/chunk_${String(worker.id).padStart(2,'0')}_${cStart}_${cEnd}.jsonl`;
          const gzBody = zlib.gzipSync(Buffer.from(chunkBuffer));
          console.log('[R2 Export] Final flush upload start', keyName, 'bytes=', gzBody.length);
          const uploadPromise = putObjectWithTimeout({ Bucket: process.env.R2_BUCKET, Key: keyName, ContentType: 'application/jsonl', ContentEncoding: 'gzip', Body: gzBody })
            .then(() => { worker.chunks += 1; state.pages += 1; console.log('[R2 Export] Final flush upload complete', keyName); })
            .catch((err) => { state.error = `Failed to upload chunk to R2: ${String(err && err.message ? err.message : err)}`; console.warn('[R2 Export] Final flush upload error', keyName, state.error); });
          await limitUploadShard(uploadPromise);
        }
      }

      await Promise.allSettled(shards.map(s => runShard(s)));
      // Drain uploads
      if (uploadInflight.size > 0) await Promise.allSettled(Array.from(uploadInflight));
    }
    // Write manifest
    try {
      const manifestKey = `events/${eventId}/${reportCode}/manifest.json`;
      const manifest = {
        eventId,
        reportCode,
        totalEvents: state.totalEvents,
        startCursor,
        lastCursor: state.lastCursor,
        reportMaxEnd,
        uploadedPages: state.pages,
        totalDurationMs: state.totalDurationMs,
        processedMs: state.processedMs,
        sharded: !!state.totalDurationMs,
        workers: Array.isArray(state.workers) ? state.workers.map(w => ({ id: w.id, start: w.start, end: w.end, cursor: w.cursor, pages: w.pages, chunks: w.chunks, events: w.events })) : [],
        r2: {
          endpoint: process.env.R2_ENDPOINT,
          bucket: process.env.R2_BUCKET
        }
      };
      console.log('[R2 Export] Writing manifest', manifestKey);
      await putObjectWithTimeout({ Bucket: process.env.R2_BUCKET, Key: manifestKey, ContentType: 'application/json', Body: JSON.stringify(manifest) });
      console.log('[R2 Export] Manifest written');
    } catch {}
    state.done = !state.error;
  } catch (err) {
    state.error = String(err && err.message ? err.message : err);
  } finally {
    activeExports.set(key, state);
  }
}

// Ingest all events for an event/report into paged storage
app.post('/api/wcl/events/ingest', express.json({ limit: '1mb' }), async (req, res) => {
  let client;
  try {
    const eventId = String(req.body && req.body.eventId || '').trim();
    const reportInput = String(req.body && req.body.report || '').trim();
    if (!eventId) return res.status(400).json({ ok: false, error: 'Missing eventId' });
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) return res.status(400).json({ ok: false, error: 'Invalid report parameter' });
    const apiUrl = getWclApiUrlFromInput(reportInput);

    client = await pool.connect();
    await ensureWclIngestTables(client);

    // Upsert report meta once
    try {
      const meta = await fetchWclReportMeta({ reportCode, apiUrl });
      await client.query(`
        INSERT INTO wcl_report_meta (report_code, api_url, actors_by_id, abilities_by_id, fetched_at)
        VALUES ($1, $2, $3, $4, NOW())
        ON CONFLICT (report_code)
        DO UPDATE SET api_url = EXCLUDED.api_url,
                      actors_by_id = EXCLUDED.actors_by_id,
                      abilities_by_id = EXCLUDED.abilities_by_id,
                      fetched_at = NOW();
      `, [reportCode, apiUrl, JSON.stringify(meta.actorsById || {}), JSON.stringify(meta.abilitiesById || {})]);
    } catch (_) {}

    // Determine starting cursor: resume from last stored end_time if exists; otherwise from earliest fight start - 5s
    let startCursor = 0;
    try {
      const existing = await client.query(`SELECT COALESCE(MAX(end_time), NULL) AS last_end FROM wcl_event_pages WHERE event_id = $1 AND report_code = $2`, [eventId, reportCode]);
      const lastEnd = existing && existing.rows && existing.rows[0] && existing.rows[0].last_end;
      if (lastEnd != null) {
        startCursor = Math.max(0, Number(lastEnd) || 0);
      } else {
        const earliest = await fetchWclEarliestFightStart({ reportCode, apiUrl });
        if (earliest > 0) startCursor = Math.max(0, earliest - 5000);
      }
    } catch (_) {}

    // Determine report cutoff using fights end times
    let reportMaxEnd = null;
    try {
      const fights = await fetchWclFights({ reportCode, apiUrl });
      for (const f of fights || []) {
        if (f && typeof f.endTime === 'number') reportMaxEnd = reportMaxEnd == null ? f.endTime : Math.max(reportMaxEnd, f.endTime);
      }
    } catch (_) {}

    const windowMs = 30000; // 30s pages
    let pagesStored = 0;
    let guard = 0;
    let lastCursor = startCursor;

    while (guard < 100000) { // hard guard
      const end = lastCursor + windowMs;
      let page;
      try {
        page = await fetchWclEventsPage({ reportCode, startTime: lastCursor, endTime: end, apiUrl });
      } catch (err) {
        return res.status(502).json({ ok: false, error: 'Failed to fetch events page', details: String(err && err.message ? err.message : err) });
      }

      const nextCursor = page.nextPageTimestamp != null ? page.nextPageTimestamp : end;
      // Store this page (idempotent by unique key)
      try {
        await client.query(`
          INSERT INTO wcl_event_pages (event_id, report_code, start_time, end_time, next_cursor, events)
          VALUES ($1, $2, $3, $4, $5, $6)
          ON CONFLICT (event_id, report_code, start_time, end_time) DO NOTHING;
        `, [eventId, reportCode, lastCursor, end, nextCursor, JSON.stringify(page.events || [])]);
        pagesStored += 1;
      } catch (err) {
        return res.status(500).json({ ok: false, error: 'Failed to store events page', details: String(err && err.message ? err.message : err) });
      }

      // Stop if API did not advance
      if (nextCursor == null || nextCursor <= lastCursor) break;
      lastCursor = nextCursor;

      // If we have a known report end time, stop after passing it by 60s buffer
      if (reportMaxEnd != null && lastCursor >= (reportMaxEnd + 60000)) break;
      guard++;

      // Safety: stop if too many pages in one request
      if (pagesStored >= 1000) break;
    }

    res.json({ ok: true, reportCode, pagesStored, startCursor, lastCursor });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Simple ingestion status for visibility
app.get('/api/wcl/events/ingest-status', async (req, res) => {
  let client;
  try {
    const eventId = String(req.query && req.query.eventId || '').trim();
    const reportInput = String(req.query && req.query.report || '').trim();
    if (!eventId) return res.status(400).json({ ok: false, error: 'Missing eventId' });
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) return res.status(400).json({ ok: false, error: 'Invalid report parameter' });
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const stats = await client.query(`
      SELECT COUNT(*)::int AS pages,
             COALESCE(MIN(start_time), 0)::bigint AS min_start,
             COALESCE(MAX(end_time), 0)::bigint AS max_end
      FROM wcl_event_pages
      WHERE event_id = $1 AND report_code = $2
    `, [eventId, reportCode]);
    res.json({ ok: true, eventId, reportCode, pages: stats.rows[0].pages, minStart: stats.rows[0].min_start, maxEnd: stats.rows[0].max_end });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Step 0: Export full combat logs to R2 as a single JSONL file
app.post('/api/wcl/events/export-r2', express.json({ limit: '1mb' }), async (req, res) => {
  try {
    if (!R2_ENABLED) return res.status(400).json({ ok: false, error: 'R2 not configured' });
    const eventId = String(req.body && req.body.eventId || '').trim();
    const reportInput = String(req.body && req.body.report || '').trim();
    if (!eventId) return res.status(400).json({ ok: false, error: 'Missing eventId' });
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) return res.status(400).json({ ok: false, error: 'Invalid report parameter' });
    const apiUrl = getWclApiUrlFromInput(reportInput);
    const result = await exportFullEventsToR2({ eventId, reportCode, apiUrl });
    return res.json(result);
  } catch (err) {
    return res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  }
});

// Start background export (returns immediately)
app.post('/api/wcl/events/export-r2/start', express.json({ limit: '1mb' }), async (req, res) => {
  try {
    if (!R2_ENABLED) return res.status(400).json({ ok: false, error: 'R2 not configured' });
    const eventId = String(req.body && req.body.eventId || '').trim();
    const reportInput = String(req.body && req.body.report || '').trim();
    if (!eventId) return res.status(400).json({ ok: false, error: 'Missing eventId' });
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) return res.status(400).json({ ok: false, error: 'Invalid report parameter' });
    const apiUrl = getWclApiUrlFromInput(reportInput);
    const jobKey = makeExportKey(eventId, reportCode);
    // If running, return existing
    const existing = activeExports.get(jobKey);
    if (!existing || existing.done || existing.error) {
      try { await ensureEventFolderMarkers(eventId, reportCode); } catch (_) {}
      // Fire and forget
      exportFullEventsToR2Background(eventId, reportCode, apiUrl).catch(()=>{});
    }
    return res.json({ ok: true, jobKey });
  } catch (err) {
    return res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  }
});

// Background export status
app.get('/api/wcl/events/export-r2/status', async (req, res) => {
  try {
    if (!R2_ENABLED) return res.status(400).json({ ok: false, error: 'R2 not configured' });
    const eventId = String(req.query && req.query.eventId || '').trim();
    const reportInput = String(req.query && req.query.report || '').trim();
    if (!eventId) return res.status(400).json({ ok: false, error: 'Missing eventId' });
    const reportCode = extractWclReportCode(reportInput);
    if (!reportCode) return res.status(400).json({ ok: false, error: 'Invalid report parameter' });
    const jobKey = makeExportKey(eventId, reportCode);
    const st = activeExports.get(jobKey) || null;
    // Also try to read manifest if present for final confirmation
    let manifest = null;
    try {
      const manifestKey = `events/${eventId}/${reportCode}/manifest.json`;
      await r2Client.send(new HeadObjectCommand({ Bucket: process.env.R2_BUCKET, Key: manifestKey }));
      manifest = { key: manifestKey };
    } catch (_) {}
    let percent = null;
    if (st) {
      if (st.totalDurationMs && st.processedMs != null) {
        const denom = Math.max(1, st.totalDurationMs);
        percent = Math.min(100, Math.max(0, Math.round((st.processedMs / denom) * 100)));
      } else if (st.reportMaxEnd != null && st.lastCursor != null) {
        const range = Math.max(1, st.reportMaxEnd);
        percent = Math.min(100, Math.max(0, Math.round((st.lastCursor / range) * 100)));
      }
    }
    return res.json({ ok: true, jobKey, state: st, manifest, percent });
  } catch (err) {
    return res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  }
});

// --- Summaries (compute-on-read) ---
function resolveActorName(actorsById, ev, idField) {
  if (!ev) return 'unknown';
  let id = null;
  if (Object.prototype.hasOwnProperty.call(ev, idField) && ev[idField] != null) {
    id = ev[idField];
  } else if (idField === 'sourceID') {
    id = ev.source && ev.source.id != null ? ev.source.id : null;
  } else if (idField === 'targetID') {
    id = ev.target && ev.target.id != null ? ev.target.id : null;
  }
  if (id != null && actorsById && actorsById[id] && actorsById[id].name) return actorsById[id].name;
  const obj = idField === 'sourceID' ? ev.source : ev.target;
  if (obj && obj.name) return obj.name;
  return id != null ? `#${id}` : 'unknown';
}

async function loadReportMetaForEvent(client, eventId) {
  const row = await client.query(`
    SELECT report_code FROM wcl_event_pages WHERE event_id = $1 ORDER BY created_at DESC LIMIT 1
  `, [eventId]);
  const rc = row.rows[0] && row.rows[0].report_code;
  if (!rc) return { code: null, actorsById: {}, abilitiesById: {} };
  const meta = await client.query(`SELECT actors_by_id, abilities_by_id FROM wcl_report_meta WHERE report_code = $1`, [rc]);
  const m = meta.rows[0] || {};
  return { code: rc, actorsById: m.actors_by_id || {}, abilitiesById: m.abilities_by_id || {} };
}

// Per-raid overview
app.get('/api/wcl/summary/raid/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const meta = await loadReportMetaForEvent(client, eventId);
    const pages = await client.query(`
      SELECT start_time, end_time, events FROM wcl_event_pages WHERE event_id = $1 ORDER BY start_time ASC
    `, [eventId]);

    const bySource = {}; // name -> { dmg, heal, deaths }
    let totalEvents = 0;
    let minTs = null;
    let maxTs = null;

    for (const row of pages.rows) {
      const arr = Array.isArray(row.events) ? row.events : [];
      totalEvents += arr.length;
      for (const ev of arr) {
        const t = ev && typeof ev.timestamp === 'number' ? ev.timestamp : null;
        if (t != null) {
          if (minTs == null || t < minTs) minTs = t;
          if (maxTs == null || t > maxTs) maxTs = t;
        }
        const type = (ev && ev.type || '').toLowerCase();
        if (type === 'damage' || type === 'heal') {
          const name = resolveActorName(meta.actorsById, ev, 'sourceID');
          const rec = bySource[name] || { dmg: 0, heal: 0, deaths: 0 };
          const amt = Number(ev.amount || 0);
          if (type === 'damage') rec.dmg += amt;
          if (type === 'heal') rec.heal += amt;
          bySource[name] = rec;
        } else if (type === 'death') {
          const name = resolveActorName(meta.actorsById, ev, 'targetID');
          const rec = bySource[name] || { dmg: 0, heal: 0, deaths: 0 };
          rec.deaths += 1;
          bySource[name] = rec;
        }
      }
    }

    res.json({
      ok: true,
      eventId,
      reportCode: meta.code,
      timeRange: { min: minTs || 0, max: maxTs || 0 },
      totalEvents,
      bySource
    });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Per-player totals
app.get('/api/wcl/summary/players/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const meta = await loadReportMetaForEvent(client, eventId);
    const pages = await client.query(`
      SELECT events FROM wcl_event_pages WHERE event_id = $1 ORDER BY start_time ASC
    `, [eventId]);
    const players = {}; // name -> { dmg, heal, deaths }
    for (const row of pages.rows) {
      const arr = Array.isArray(row.events) ? row.events : [];
      for (const ev of arr) {
        const type = (ev && ev.type || '').toLowerCase();
        if (type === 'damage' || type === 'heal') {
          const name = resolveActorName(meta.actorsById, ev, 'sourceID');
          const rec = players[name] || { dmg: 0, heal: 0, deaths: 0 };
          const amt = Number(ev.amount || 0);
          if (type === 'damage') rec.dmg += amt;
          if (type === 'heal') rec.heal += amt;
          players[name] = rec;
        } else if (type === 'death') {
          const name = resolveActorName(meta.actorsById, ev, 'targetID');
          const rec = players[name] || { dmg: 0, heal: 0, deaths: 0 };
          rec.deaths += 1;
          players[name] = rec;
        }
      }
    }
    res.json({ ok: true, eventId, reportCode: meta.code, players });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Serve Explorer page at /explorer
app.get('/explorer', (req, res) => {
  try {
    res.sendFile(path.join(__dirname, 'public', 'explorer.html'));
  } catch (err) {
    res.status(500).send('Failed to load explorer page');
  }
});

// Fights summary from stored events (encounterstart/encounterend)
app.get('/api/wcl/summary/fights/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const meta = await loadReportMetaForEvent(client, eventId);
    const pages = await client.query(`
      SELECT events FROM wcl_event_pages WHERE event_id = $1 ORDER BY start_time ASC
    `, [eventId]);
    const fights = [];
    let current = null;
    for (const row of pages.rows) {
      const arr = Array.isArray(row.events) ? row.events : [];
      for (const ev of arr) {
        const type = (ev && ev.type || '').toLowerCase();
        if (type === 'encounterstart') {
          if (current) fights.push(current);
          current = {
            name: ev.encounterName || ev.bossName || ev.name || 'Unknown',
            start: typeof ev.timestamp === 'number' ? ev.timestamp : null,
            end: null,
            kill: !!ev.kill
          };
        } else if (type === 'encounterend') {
          if (!current) {
            current = { name: ev.encounterName || ev.bossName || ev.name || 'Unknown', start: null, end: null, kill: !!ev.kill };
          }
          current.end = typeof ev.timestamp === 'number' ? ev.timestamp : current.end;
          if (typeof ev.kill === 'boolean') current.kill = ev.kill;
          fights.push(current);
          current = null;
        }
      }
    }
    if (current) fights.push(current);
    const out = fights.map(f => ({
      name: f.name,
      start: f.start || 0,
      end: f.end || f.start || 0,
      durationMs: (f.end && f.start) ? Math.max(0, f.end - f.start) : 0,
      kill: !!f.kill
    }));
    res.json({ ok: true, eventId, reportCode: meta.code, fights: out });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Deaths summary
app.get('/api/wcl/summary/deaths/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const meta = await loadReportMetaForEvent(client, eventId);
    const pages = await client.query(`
      SELECT events FROM wcl_event_pages WHERE event_id = $1 ORDER BY start_time ASC
    `, [eventId]);
    const deaths = {};
    const list = [];
    for (const row of pages.rows) {
      const arr = Array.isArray(row.events) ? row.events : [];
      for (const ev of arr) {
        const type = (ev && ev.type || '').toLowerCase();
        if (type !== 'death') continue;
        const name = resolveActorName(meta.actorsById, ev, 'targetID');
        deaths[name] = (deaths[name] || 0) + 1;
        list.push({ name, ts: typeof ev.timestamp === 'number' ? ev.timestamp : null });
      }
    }
    res.json({ ok: true, eventId, reportCode: meta.code, totals: deaths, list });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Abilities totals (damage/heal)
app.get('/api/wcl/summary/abilities/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    const kind = String(req.query && req.query.kind || '').toLowerCase();
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const meta = await loadReportMetaForEvent(client, eventId);
    const pages = await client.query(`
      SELECT events FROM wcl_event_pages WHERE event_id = $1 ORDER BY start_time ASC
    `, [eventId]);
    const damage = new Map();
    const healing = new Map();
    function add(map, abilityName, amount){
      const key = abilityName || 'Unknown';
      const rec = map.get(key) || { total: 0, hits: 0 };
      rec.total += amount;
      rec.hits += 1;
      map.set(key, rec);
    }
    for (const row of pages.rows) {
      const arr = Array.isArray(row.events) ? row.events : [];
      for (const ev of arr) {
        const type = (ev && ev.type || '').toLowerCase();
        if (type !== 'damage' && type !== 'heal') continue;
        if (kind && type !== kind) continue;
        const abilityId = ev.abilityGameID || (ev.ability && ev.ability.guid);
        const abilityName = (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId] && meta.abilitiesById[abilityId].name) || (ev.ability && ev.ability.name) || `#${abilityId||''}`;
        const amount = Number(ev.amount || 0);
        if (type === 'damage') add(damage, abilityName, amount);
        else add(healing, abilityName, amount);
      }
    }
    function toSortedArray(map){
      return Array.from(map.entries()).map(([name, rec])=>({ ability: name, total: rec.total, hits: rec.hits }))
        .sort((a,b)=> b.total - a.total);
    }
    res.json({ ok: true, eventId, reportCode: meta.code, damage: toSortedArray(damage), healing: toSortedArray(healing) });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Targets totals (damage to targets, healing on targets)
app.get('/api/wcl/summary/targets/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    const kind = String(req.query && req.query.kind || '').toLowerCase();
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const meta = await loadReportMetaForEvent(client, eventId);
    const pages = await client.query(`
      SELECT events FROM wcl_event_pages WHERE event_id = $1 ORDER BY start_time ASC
    `, [eventId]);
    const dmgTargets = new Map();
    const healTargets = new Map();
    function add(map, name, amount){
      const key = name || 'Unknown';
      map.set(key, (map.get(key)||0) + amount);
    }
    for (const row of pages.rows) {
      const arr = Array.isArray(row.events) ? row.events : [];
      for (const ev of arr) {
        const type = (ev && ev.type || '').toLowerCase();
        if (type !== 'damage' && type !== 'heal') continue;
        if (kind && type !== kind) continue;
        const tgtName = resolveActorName(meta.actorsById, ev, 'targetID');
        const amount = Number(ev.amount || 0);
        if (type === 'damage') add(dmgTargets, tgtName, amount);
        else add(healTargets, tgtName, amount);
      }
    }
    function toSorted(map){
      return Array.from(map.entries()).map(([name, total])=>({ name, total }))
        .sort((a,b)=> b.total - a.total);
    }
    res.json({ ok: true, eventId, reportCode: meta.code, damage: toSorted(dmgTargets), healing: toSorted(healTargets) });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// --- RAW DATA DUMPS ---
// All event pages for an event (raw JSON)
app.get('/api/wcl/raw/event-pages/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const rows = await client.query(`
      SELECT id, event_id, report_code, start_time, end_time, next_cursor, events, created_at
      FROM wcl_event_pages
      WHERE event_id = $1
      ORDER BY start_time ASC
    `, [eventId]);
    res.json({ ok: true, count: rows.rows.length, rows: rows.rows });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// Report meta rows referenced by an event (raw JSON)
app.get('/api/wcl/raw/report-meta/:eventId', async (req, res) => {
  let client;
  try {
    const eventId = req.params.eventId;
    client = await pool.connect();
    await ensureWclIngestTables(client);
    const codesRes = await client.query(`
      SELECT DISTINCT report_code FROM wcl_event_pages WHERE event_id = $1
    `, [eventId]);
    const codes = codesRes.rows.map(r => r.report_code).filter(Boolean);
    if (codes.length === 0) return res.json({ ok: true, reportCodes: [], meta: [] });
    const metaRes = await client.query(`
      SELECT report_code, api_url, actors_by_id, abilities_by_id, fetched_at
      FROM wcl_report_meta
      WHERE report_code = ANY($1)
    `, [codes]);
    res.json({ ok: true, reportCodes: codes, meta: metaRes.rows });
  } catch (err) {
    res.status(500).json({ ok: false, error: String(err && err.message ? err.message : err) });
  } finally {
    if (client) client.release();
  }
});

// =============================================================================
// LIVE HOST: SSE Streaming Import for WCL Events
// =============================================================================

// Create table for live session tracking
async function ensureLiveSessionTable(client) {
  await client.query(`
    CREATE TABLE IF NOT EXISTS wcl_live_sessions (
      id SERIAL PRIMARY KEY,
      session_id TEXT UNIQUE NOT NULL,
      report_code TEXT NOT NULL,
      api_url TEXT,
      status TEXT DEFAULT 'importing',
      total_events INTEGER DEFAULT 0,
      last_cursor BIGINT DEFAULT 0,
      report_end_time BIGINT,
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW()
    );
  `);
  await client.query(`CREATE INDEX IF NOT EXISTS idx_wcl_live_sessions_report ON wcl_live_sessions(report_code);`);
}

// Table for caching highlights data for live viewers (avoids re-analyzing for each viewer)
async function ensureLiveHighlightsTable(client) {
  await client.query(`
    CREATE TABLE IF NOT EXISTS wcl_live_highlights (
      id SERIAL PRIMARY KEY,
      report_code TEXT NOT NULL,
      highlight_type TEXT NOT NULL,
      highlights JSONB NOT NULL,
      version INTEGER DEFAULT 1,
      updated_at TIMESTAMPTZ DEFAULT NOW(),
      UNIQUE(report_code, highlight_type)
    );
  `);
  await client.query(`CREATE INDEX IF NOT EXISTS idx_wcl_live_highlights_report ON wcl_live_highlights(report_code);`);
}

// In-memory store for active live session (for real-time push to viewers)
let activeLiveSession = null;
const liveViewerConnections = new Set();

// Broadcast highlights update to all connected viewers
function broadcastHighlightsToViewers(data) {
  for (const res of liveViewerConnections) {
    try {
      res.write(`event: highlights-update\ndata: ${JSON.stringify(data)}\n\n`);
    } catch (_) {
      liveViewerConnections.delete(res);
    }
  }
}

// Save highlights to cache table and broadcast to viewers
async function saveAndBroadcastHighlights(reportCode, highlightType, highlights) {
  try {
    await pool.query(`
      INSERT INTO wcl_live_highlights (report_code, highlight_type, highlights, version, updated_at)
      VALUES ($1, $2, $3, 1, NOW())
      ON CONFLICT (report_code, highlight_type) 
      DO UPDATE SET highlights = $3, version = wcl_live_highlights.version + 1, updated_at = NOW()
    `, [reportCode, highlightType, JSON.stringify(highlights)]);
    
    // Broadcast to connected viewers
    broadcastHighlightsToViewers({
      type: highlightType,
      reportCode,
      data: highlights,
      timestamp: Date.now()
    });
  } catch (err) {
    console.error(`[LIVE] Error saving/broadcasting ${highlightType}:`, err.message);
  }
}

// Clear all highlights for a report
async function clearHighlightsForReport(reportCode) {
  try {
    await pool.query('DELETE FROM wcl_live_highlights WHERE report_code = $1', [reportCode]);
    broadcastHighlightsToViewers({ type: 'clear', reportCode, timestamp: Date.now() });
  } catch (err) {
    console.error('[LIVE] Error clearing highlights:', err.message);
  }
}

// Analyze bloodrages from ALL events in database
// Returns bad bloodrages (within 3s of trash combat ending, not during boss fights)
async function analyzeBloodragesFromDB(reportCode, fights, meta) {
  const COMBAT_GAP_MS = 3000; // 3 seconds of no damage = combat ended
  const BAD_THRESHOLD_MS = 3000; // Flag if bloodrage within 3s of combat end
  const MIN_COMBAT_DURATION_MS = 5000; // Ignore combat segments shorter than 5 seconds
  
  // Get all event pages for this report
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );
  
  if (pagesResult.rows.length === 0) {
    return { badBloodrages: [], totalBloodrages: 0, combatSegmentCount: 0, damageEventCount: 0 };
  }
  
  // Extract all damage timestamps and bloodrage events
  const damageTimestamps = [];
  const bloodrageEvents = [];
  
  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      
      // Track ALL damage events for combat detection
      if (type === 'damage' && ev.timestamp != null) {
        damageTimestamps.push(ev.timestamp);
      }
      
      // Track bloodrage casts
      if (type === 'cast') {
        const abilityId = ev.abilityGameID ?? ev.ability?.guid;
        // Bloodrage ability ID is 2687
        const abilityName = (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId])
          ? meta.abilitiesById[abilityId].name
          : '';
        if (abilityName.toLowerCase() === 'bloodrage' || abilityId === 2687) {
          // Enrich with names
          const enriched = { ...ev };
          if (ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
            enriched.sourceName = meta.actorsById[ev.sourceID].name;
            enriched.sourceSubType = meta.actorsById[ev.sourceID].subType;
          }
          enriched.abilityName = abilityName || 'Bloodrage';
          bloodrageEvents.push(enriched);
        }
      }
    }
  }
  
  console.log(`[ANALYSIS] Found ${damageTimestamps.length} damage events, ${bloodrageEvents.length} bloodrage casts`);
  
  if (damageTimestamps.length === 0 || bloodrageEvents.length === 0) {
    return { 
      badBloodrages: [], 
      totalBloodrages: bloodrageEvents.length, 
      combatSegmentCount: 0, 
      damageEventCount: damageTimestamps.length 
    };
  }
  
  // Collect all damage events (not just timestamps) for detailed analysis
  const allDamageEvents = [];
  let metaHits = 0;
  let metaMisses = 0;
  
  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      if (type === 'damage' && ev.timestamp != null) {
        // Enrich with names
        const enriched = { ...ev };
        
        // Try both string and number keys for actor lookup
        const sourceId = ev.sourceID;
        const targetId = ev.targetID;
        
        if (sourceId != null && meta.actorsById) {
          const actor = meta.actorsById[sourceId] || meta.actorsById[String(sourceId)];
          if (actor) {
            enriched.sourceName = actor.name;
            metaHits++;
          } else {
            metaMisses++;
          }
        }
        if (targetId != null && meta.actorsById) {
          const actor = meta.actorsById[targetId] || meta.actorsById[String(targetId)];
          if (actor) {
            enriched.targetName = actor.name;
          }
        }
        allDamageEvents.push(enriched);
      }
    }
  }
  
  console.log(`[ANALYSIS] Meta lookup: ${metaHits} hits, ${metaMisses} misses. actorsById keys sample: ${Object.keys(meta.actorsById || {}).slice(0, 5).join(', ')}`);
  
  // Sort damage events by timestamp
  allDamageEvents.sort((a, b) => a.timestamp - b.timestamp);
  
  // Detect combat segments with first/last damage event details
  const combatSegments = [];
  if (allDamageEvents.length > 0) {
    let segmentStartIdx = 0;
    let lastIdx = 0;
    
    for (let i = 1; i < allDamageEvents.length; i++) {
      const gap = allDamageEvents[i].timestamp - allDamageEvents[lastIdx].timestamp;
      if (gap > COMBAT_GAP_MS) {
        // End current segment, start new one
        combatSegments.push({ 
          startTime: allDamageEvents[segmentStartIdx].timestamp,
          endTime: allDamageEvents[lastIdx].timestamp,
          firstDamage: {
            sourceName: allDamageEvents[segmentStartIdx].sourceName || `#${allDamageEvents[segmentStartIdx].sourceID}`,
            targetName: allDamageEvents[segmentStartIdx].targetName || `#${allDamageEvents[segmentStartIdx].targetID}`,
            amount: allDamageEvents[segmentStartIdx].amount
          },
          lastDamage: {
            sourceName: allDamageEvents[lastIdx].sourceName || `#${allDamageEvents[lastIdx].sourceID}`,
            targetName: allDamageEvents[lastIdx].targetName || `#${allDamageEvents[lastIdx].targetID}`,
            amount: allDamageEvents[lastIdx].amount
          }
        });
        segmentStartIdx = i;
      }
      lastIdx = i;
    }
    // Add final segment
    combatSegments.push({ 
      startTime: allDamageEvents[segmentStartIdx].timestamp,
      endTime: allDamageEvents[lastIdx].timestamp,
      firstDamage: {
        sourceName: allDamageEvents[segmentStartIdx].sourceName || `#${allDamageEvents[segmentStartIdx].sourceID}`,
        targetName: allDamageEvents[segmentStartIdx].targetName || `#${allDamageEvents[segmentStartIdx].targetID}`,
        amount: allDamageEvents[segmentStartIdx].amount
      },
      lastDamage: {
        sourceName: allDamageEvents[lastIdx].sourceName || `#${allDamageEvents[lastIdx].sourceID}`,
        targetName: allDamageEvents[lastIdx].targetName || `#${allDamageEvents[lastIdx].targetID}`,
        amount: allDamageEvents[lastIdx].amount
      }
    });
  }
  
  console.log(`[ANALYSIS] Detected ${combatSegments.length} combat segments from ${allDamageEvents.length} damage events`);
  
  // Debug: show first few segments
  if (combatSegments.length > 0) {
    console.log(`[ANALYSIS] First segment: start=${combatSegments[0].startTime}, end=${combatSegments[0].endTime}, firstDmg=${JSON.stringify(combatSegments[0].firstDamage)}`);
    if (combatSegments.length > 1) {
      console.log(`[ANALYSIS] Second segment: start=${combatSegments[1].startTime}, end=${combatSegments[1].endTime}`);
    }
    console.log(`[ANALYSIS] Last segment: start=${combatSegments[combatSegments.length-1].startTime}, end=${combatSegments[combatSegments.length-1].endTime}`);
  }
  
  // Helper: Check if timestamp is during a BOSS encounter
  function isDuringBossEncounter(timestamp) {
    if (!fights || !Array.isArray(fights)) return false;
    for (const fight of fights) {
      // Only consider real boss encounters (encounterID > 0)
      if (fight.encounterID && fight.encounterID > 0) {
        if (timestamp >= fight.startTime && timestamp <= fight.endTime) {
          return true;
        }
      }
    }
    return false;
  }
  
  // Check each bloodrage
  const badBloodrages = [];
  
  for (const br of bloodrageEvents) {
    // Skip if during a boss encounter
    if (isDuringBossEncounter(br.timestamp)) {
      continue;
    }
    
    // Find which combat segment this bloodrage is in
    for (let segIdx = 0; segIdx < combatSegments.length; segIdx++) {
      const seg = combatSegments[segIdx];
      if (br.timestamp >= seg.startTime && br.timestamp <= seg.endTime) {
        // Skip combat segments that are too short (less than 5 seconds)
        const combatDurationMs = seg.endTime - seg.startTime;
        if (combatDurationMs < MIN_COMBAT_DURATION_MS) {
          break; // Skip this bloodrage - combat too short to be meaningful
        }
        
        const timeToCombatEnd = seg.endTime - br.timestamp;
        if (timeToCombatEnd <= BAD_THRESHOLD_MS) {
          // Get next combat segment info
          const nextSeg = combatSegments[segIdx + 1] || null;
          const outOfCombatDuration = nextSeg ? nextSeg.startTime - seg.endTime : null;
          
          badBloodrages.push({
            timestamp: br.timestamp,
            sourceName: br.sourceName || `#${br.sourceID}`,
            sourceID: br.sourceID,
            sourceSubType: br.sourceSubType, // Class info for color
            abilityName: br.abilityName,
            secondsBefore: Math.round(timeToCombatEnd / 1000),
            combatStart: seg.startTime,
            combatEnd: seg.endTime,
            combatDuration: Math.round((seg.endTime - seg.startTime) / 1000),
            firstDamage: seg.firstDamage,
            lastDamage: seg.lastDamage,
            outOfCombatDuration: outOfCombatDuration ? Math.round(outOfCombatDuration / 1000) : null,
            nextCombatStart: nextSeg ? nextSeg.startTime : null,
            nextCombatFirstDamage: nextSeg ? nextSeg.firstDamage : null
          });
        }
        break; // Found the segment, no need to check others
      }
    }
  }
  
  console.log(`[ANALYSIS] Found ${badBloodrages.length} bad bloodrages out of ${bloodrageEvents.length}`);
  
  // Debug: show first bad bloodrage data
  if (badBloodrages.length > 0) {
    console.log(`[ANALYSIS] First bad BR: timestamp=${badBloodrages[0].timestamp}, firstDamage=${JSON.stringify(badBloodrages[0].firstDamage)}, lastDamage=${JSON.stringify(badBloodrages[0].lastDamage)}, nextCombat=${badBloodrages[0].nextCombatStart}`);
  }
  
  return {
    badBloodrages,
    totalBloodrages: bloodrageEvents.length,
    combatSegmentCount: combatSegments.length,
    damageEventCount: damageTimestamps.length
  };
}

// Analyze charges from ALL events in database
// Returns charges with info about whether target was hit by a tank first
async function analyzeChargesFromDB(reportCode, tankNames, meta) {
  const LOOKBACK_MS = 10000; // Check 10 seconds before charge for tank hits
  
  // Stunnable mobs - charging these is bad because tank can't reposition
  const STUNNABLE_MOBS = [
    'plagued ghoul',
    'spirit of naxxramas',
    'shade of naxxramas',
    'necro knight',
    'stitched spewer',
    'zombie chow'
  ];
  
  // Critters/mobs that are always safe to charge (ignore tank check)
  const ALWAYS_OK_MOBS = [
    'maggot',
    'rat'
  ];
  
  // Get all event pages for this report
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );
  
  if (pagesResult.rows.length === 0) {
    return { charges: [], totalCharges: 0 };
  }
  
  // Collect all events
  const allEvents = [];
  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      // Enrich with names and class info
      const enriched = { ...ev };
      if (ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        enriched.sourceName = meta.actorsById[ev.sourceID].name;
        enriched.sourceSubType = meta.actorsById[ev.sourceID].subType;
      }
      if (ev.targetID != null && meta.actorsById && meta.actorsById[ev.targetID]) {
        enriched.targetName = meta.actorsById[ev.targetID].name;
      }
      const abilityId = ev.abilityGameID ?? ev.ability?.guid;
      if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
        enriched.abilityName = meta.abilitiesById[abilityId].name;
      }
      allEvents.push(enriched);
    }
  }
  
  // Separate damage events and charge events
  const damageEvents = allEvents.filter(ev => 
    String(ev.type || '').toLowerCase() === 'damage' && 
    ev.timestamp != null && 
    ev.targetID != null
  );
  
  const chargeEvents = allEvents.filter(ev => 
    String(ev.type || '').toLowerCase() === 'cast' && 
    String(ev.abilityName || '').toLowerCase() === 'charge'
  );
  
  console.log(`[CHARGE ANALYSIS] Found ${chargeEvents.length} charges, ${damageEvents.length} damage events, ${tankNames.length} tanks: ${tankNames.join(', ')}`);
  
  // Sort damage events by timestamp for efficient lookback
  damageEvents.sort((a, b) => a.timestamp - b.timestamp);
  
  // Build a map of targetID -> damage events for quick lookup
  const damageByTargetId = new Map();
  for (const dmg of damageEvents) {
    if (!damageByTargetId.has(dmg.targetID)) {
      damageByTargetId.set(dmg.targetID, []);
    }
    damageByTargetId.get(dmg.targetID).push(dmg);
  }
  
  // Normalize tank names for comparison
  const tankNamesLower = new Set(tankNames.map(n => String(n).toLowerCase()));
  
  // Analyze each charge
  const analyzedCharges = [];
  
  for (const charge of chargeEvents) {
    const chargeTargetId = charge.targetID;
    const chargeTime = charge.timestamp;
    
    // Find damage events on the same targetID before the charge
    const targetDamageEvents = damageByTargetId.get(chargeTargetId) || [];
    
    // Look for tank hits in the lookback window before the charge
    let tankHitFirst = false;
    let firstTankHit = null;
    
    for (const dmg of targetDamageEvents) {
      // Only consider damage BEFORE the charge
      if (dmg.timestamp >= chargeTime) continue;
      
      // Only consider damage within the lookback window
      if (chargeTime - dmg.timestamp > LOOKBACK_MS) continue;
      
      // Check if the damage source is a tank
      const sourceName = String(dmg.sourceName || '').toLowerCase();
      if (tankNamesLower.has(sourceName)) {
        tankHitFirst = true;
        if (!firstTankHit || dmg.timestamp < firstTankHit.timestamp) {
          firstTankHit = {
            timestamp: dmg.timestamp,
            sourceName: dmg.sourceName,
            targetName: dmg.targetName,
            abilityName: dmg.abilityName || 'Unknown',
            amount: dmg.amount
          };
        }
      }
    }
    
    // Check if target is a stunnable mob or always-OK critter
    const targetNameLower = String(charge.targetName || '').toLowerCase();
    const isStunnableMob = STUNNABLE_MOBS.some(mob => targetNameLower.includes(mob));
    const isCritter = ALWAYS_OK_MOBS.some(mob => targetNameLower.includes(mob));
    
    analyzedCharges.push({
      timestamp: charge.timestamp,
      sourceName: charge.sourceName || `#${charge.sourceID}`,
      sourceID: charge.sourceID,
      sourceSubType: charge.sourceSubType, // Class info for color
      targetName: charge.targetName || `#${charge.targetID}`,
      targetID: charge.targetID,
      abilityName: charge.abilityName || 'Charge',
      tankHitFirst: tankHitFirst || isCritter, // Critters count as "tank hit first"
      firstTankHit,
      isStunnableMob,
      isCritter
    });
  }
  
  const badCharges = analyzedCharges.filter(c => (!c.tankHitFirst && !c.isCritter) || c.isStunnableMob).length;
  console.log(`[CHARGE ANALYSIS] ${badCharges} charges on mobs not hit by tank first`);
  
  return {
    charges: analyzedCharges,
    totalCharges: chargeEvents.length,
    badCharges
  };
}

// Analyze spell interrupts from ALL events in database - aggregated by player
async function analyzeInterruptsFromDB(reportCode, meta) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );

  if (pagesResult.rows.length === 0) {
    return { playerStats: [], totalInterrupts: 0 };
  }

  const playerCounts = {}; // { sourceName: { count, sourceSubType, spells: {}, events: [] } }
  let totalInterrupts = 0;

  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      if (type !== 'interrupt') continue;

      let sourceName = ev.sourceName;
      let sourceSubType = ev.sourceSubType;
      if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        sourceName = meta.actorsById[ev.sourceID].name;
        sourceSubType = meta.actorsById[ev.sourceID].subType;
      }
      if (!sourceName) continue;

      if (!playerCounts[sourceName]) {
        playerCounts[sourceName] = { count: 0, sourceSubType, spells: {}, events: [] };
      }
      playerCounts[sourceName].count++;
      totalInterrupts++;

      // Track which spells were interrupted
      const interruptedAbilityId = ev.extraAbilityGameID ?? ev.ability?.guid;
      let spellName = 'Unknown';
      if (interruptedAbilityId != null && meta.abilitiesById && meta.abilitiesById[interruptedAbilityId]) {
        spellName = meta.abilitiesById[interruptedAbilityId].name;
      }
      playerCounts[sourceName].spells[spellName] = (playerCounts[sourceName].spells[spellName] || 0) + 1;
      
      // Store individual event for detail view
      playerCounts[sourceName].events.push({
        timestamp: ev.timestamp,
        extraAbilityName: spellName
      });
    }
  }

  // Convert to sorted array
  const playerStats = Object.entries(playerCounts)
    .map(([name, data]) => ({
      name,
      count: data.count,
      sourceSubType: data.sourceSubType,
      topSpells: Object.entries(data.spells).sort((a, b) => b[1] - a[1]).slice(0, 3),
      events: data.events
    }))
    .sort((a, b) => b.count - a.count);

  console.log(`[ANALYSIS] Found ${totalInterrupts} interrupts by ${playerStats.length} players`);
  return { playerStats, totalInterrupts };
}

// Analyze decurses from ALL events in database - aggregated by player
async function analyzeDecursesFromDB(reportCode, meta) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );

  if (pagesResult.rows.length === 0) {
    return { playerStats: [], totalDecurses: 0 };
  }

  // Decurse spell IDs (Remove Curse variations)
  const DECURSE_ABILITIES = ['remove curse', 'remove lesser curse', 'abolish poison'];

  const playerCounts = {}; // { sourceName: { count, sourceSubType, curses: {}, events: [] } }
  let totalDecurses = 0;

  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      if (type !== 'dispel') continue;

      // Get the ability used
      const abilityId = ev.abilityGameID ?? ev.ability?.guid;
      let abilityName = '';
      if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
        abilityName = meta.abilitiesById[abilityId].name;
      }

      // Check if it's a decurse ability
      const abilityLower = abilityName.toLowerCase();
      if (!DECURSE_ABILITIES.some(d => abilityLower.includes(d.split(' ')[0]))) {
        if (!abilityLower.includes('remove') && !abilityLower.includes('curse')) continue;
      }

      let sourceName = ev.sourceName;
      let sourceSubType = ev.sourceSubType;
      if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        sourceName = meta.actorsById[ev.sourceID].name;
        sourceSubType = meta.actorsById[ev.sourceID].subType;
      }
      if (!sourceName) continue;

      if (!playerCounts[sourceName]) {
        playerCounts[sourceName] = { count: 0, sourceSubType, curses: {}, events: [] };
      }
      playerCounts[sourceName].count++;
      totalDecurses++;

      // Track which curses were removed
      const extraAbilityId = ev.extraAbilityGameID;
      let curseName = 'Unknown';
      if (extraAbilityId != null && meta.abilitiesById && meta.abilitiesById[extraAbilityId]) {
        curseName = meta.abilitiesById[extraAbilityId].name;
      }
      playerCounts[sourceName].curses[curseName] = (playerCounts[sourceName].curses[curseName] || 0) + 1;
      
      // Store individual event for detail view
      playerCounts[sourceName].events.push({
        timestamp: ev.timestamp,
        extraAbilityName: curseName
      });
    }
  }
  
  // Convert to sorted array
  const playerStats = Object.entries(playerCounts)
    .map(([name, data]) => ({
      name,
      count: data.count,
      sourceSubType: data.sourceSubType,
      topCurses: Object.entries(data.curses).sort((a, b) => b[1] - a[1]).slice(0, 3),
      events: data.events
    }))
    .sort((a, b) => b.count - a.count);
  
  console.log(`[ANALYSIS] Found ${totalDecurses} decurses by ${playerStats.length} players`);
  return { playerStats, totalDecurses };
}

// Analyze effective Sunder Armor applications from ALL events in database - aggregated by player
async function analyzeSundersFromDB(reportCode, meta) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );

  if (pagesResult.rows.length === 0) {
    return { playerStats: [], effectiveSunders: 0, totalSunders: 0 };
  }

  const playerCounts = {}; // { sourceName: { effective, total, sourceSubType, events: [] } }
  let totalEffective = 0;
  let totalCasts = 0;

  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();

      // Get ability name
      const abilityId = ev.abilityGameID ?? ev.ability?.guid;
      let abilityName = '';
      if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
        abilityName = meta.abilitiesById[abilityId].name;
      }

      if (!abilityName.toLowerCase().includes('sunder armor')) continue;

      let sourceName = ev.sourceName;
      let sourceSubType = ev.sourceSubType;
      if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        sourceName = meta.actorsById[ev.sourceID].name;
        sourceSubType = meta.actorsById[ev.sourceID].subType;
      }
      if (!sourceName) continue;

      if (!playerCounts[sourceName]) {
        playerCounts[sourceName] = { effective: 0, total: 0, sourceSubType, events: [] };
      }

      // Count casts
      if (type === 'cast') {
        playerCounts[sourceName].total++;
        totalCasts++;
      }

      // Only count effective sunders (applydebuff = first stack, applydebuffstack = additional stacks)
      if (type === 'applydebuff' || type === 'applydebuffstack') {
        playerCounts[sourceName].effective++;
        totalEffective++;
        
        // Get target name for detail view
        let targetName = ev.targetName;
        if (!targetName && ev.targetID != null && meta.actorsById && meta.actorsById[ev.targetID]) {
          targetName = meta.actorsById[ev.targetID].name;
        }
        
        // Store individual event for detail view
        playerCounts[sourceName].events.push({
          timestamp: ev.timestamp,
          targetName: targetName || 'Unknown'
        });
      }
    }
  }

  // Convert to sorted array - only include players with effective sunders
  const playerStats = Object.entries(playerCounts)
    .filter(([name, data]) => data.effective > 0)
    .map(([name, data]) => ({
      name,
      effective: data.effective,
      total: data.total,
      sourceSubType: data.sourceSubType,
      events: data.events
    }))
    .sort((a, b) => b.effective - a.effective);
  
  console.log(`[ANALYSIS] Found ${totalEffective} effective sunders out of ${totalCasts} casts by ${playerStats.length} players`);
  return { 
    playerStats, 
    effectiveSunders: totalEffective,
    totalSunders: totalCasts
  };
}

// Analyze effective Scorch (Fire Vulnerability / Improved Scorch) applications - aggregated by player
// Note: In Classic WoW, the debuff from Improved Scorch is spell ID 22959
// The debuff is called "Fire Vulnerability" and stacks up to 5 times
async function analyzeScorchesFromDB(reportCode, meta) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );
  
  if (pagesResult.rows.length === 0) {
    return { playerStats: [], effectiveScorches: 0, totalScorches: 0 };
  }
  
  const playerCounts = {}; // { sourceName: { effective, total, sourceSubType } }
  let totalEffective = 0;
  let totalCasts = 0;
  
  // Fire Vulnerability spell IDs (from Classic WoW)
  // 22959 = Fire Vulnerability (Improved Scorch debuff)
  const FIRE_VULN_IDS = [22959, 12873, 12872, 12871, 12870, 12869];
  
  // Track all debuff names for debugging
  const debugDebuffs = new Map(); // abilityId -> { name, count }
  
  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      
      // Get ability info
      const abilityId = ev.abilityGameID ?? ev.ability?.guid;
      let abilityName = '';
      if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
        abilityName = meta.abilitiesById[abilityId].name;
      }
      
      const abilityLower = abilityName.toLowerCase();
      
      // Count Scorch casts
      if (type === 'cast' && abilityLower === 'scorch') {
        let sourceName = ev.sourceName;
        let sourceSubType = ev.sourceSubType;
        if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
          sourceName = meta.actorsById[ev.sourceID].name;
          sourceSubType = meta.actorsById[ev.sourceID].subType;
        }
        if (sourceName) {
          if (!playerCounts[sourceName]) {
            playerCounts[sourceName] = { effective: 0, total: 0, sourceSubType, events: [] };
          }
          playerCounts[sourceName].total++;
          totalCasts++;
        }
        continue;
      }
      
      // Only track debuff applications
      if (type !== 'applydebuff' && type !== 'applydebuffstack') continue;
      
      // Check if this is Fire Vulnerability by ID or name
      const isFireVuln = FIRE_VULN_IDS.includes(abilityId) ||
                         abilityLower.includes('fire vulnerability') || 
                         abilityLower.includes('improved scorch');
      
      // Debug: track all debuff applications to see what's available
      if (type === 'applydebuff' || type === 'applydebuffstack') {
        const key = `${abilityId}`;
        if (!debugDebuffs.has(key)) {
          debugDebuffs.set(key, { name: abilityName, id: abilityId, count: 0 });
        }
        debugDebuffs.get(key).count++;
      }
      
      if (!isFireVuln) continue;
      
      let sourceName = ev.sourceName;
      let sourceSubType = ev.sourceSubType;
      if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        sourceName = meta.actorsById[ev.sourceID].name;
        sourceSubType = meta.actorsById[ev.sourceID].subType;
      }
      if (!sourceName) continue;
      
      if (!playerCounts[sourceName]) {
        playerCounts[sourceName] = { effective: 0, total: 0, sourceSubType, events: [] };
      }
      playerCounts[sourceName].effective++;
      totalEffective++;
      
      // Get target name for detail view
      let targetName = ev.targetName;
      if (!targetName && ev.targetID != null && meta.actorsById && meta.actorsById[ev.targetID]) {
        targetName = meta.actorsById[ev.targetID].name;
      }
      
      // Store individual event for detail view
      playerCounts[sourceName].events.push({
        timestamp: ev.timestamp,
        targetName: targetName || 'Unknown'
      });
    }
  }
  
  // Convert to sorted array - only include players with effective scorches
  const playerStats = Object.entries(playerCounts)
    .filter(([name, data]) => data.effective > 0)
    .map(([name, data]) => ({
      name,
      effective: data.effective,
      total: data.total,
      sourceSubType: data.sourceSubType,
      events: data.events || []
    }))
    .sort((a, b) => b.effective - a.effective);
  
  console.log(`[ANALYSIS] Found ${totalEffective} effective scorches out of ${totalCasts} casts by ${playerStats.length} mages`);
  
  // Debug: Show top debuff types if no fire vulns found
  if (totalEffective === 0 && debugDebuffs.size > 0) {
    const topDebuffs = Array.from(debugDebuffs.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
    console.log(`[ANALYSIS] Top debuff types found (no Fire Vulnerability detected):`);
    for (const d of topDebuffs) {
      console.log(`  - ID ${d.id}: "${d.name}" (${d.count} applications)`);
    }
  }
  
  return { 
    playerStats, 
    effectiveScorches: totalEffective,
    totalScorches: totalCasts
  };
}

// Analyze Disarm applications from ALL events in database - aggregated by player
async function analyzeDisarmsFromDB(reportCode, meta) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );

  if (pagesResult.rows.length === 0) {
    return { playerStats: [], totalDisarms: 0 };
  }

  const playerCounts = {}; // { sourceName: { count, sourceSubType, targets: {}, events: [] } }
  let totalDisarms = 0;

  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      if (type !== 'applydebuff') continue;

      // Get ability name
      const abilityId = ev.abilityGameID ?? ev.ability?.guid;
      let abilityName = '';
      if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
        abilityName = meta.abilitiesById[abilityId].name;
      }

      if (abilityName.toLowerCase() !== 'disarm') continue;

      let sourceName = ev.sourceName;
      let sourceSubType = ev.sourceSubType;
      if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        sourceName = meta.actorsById[ev.sourceID].name;
        sourceSubType = meta.actorsById[ev.sourceID].subType;
      }
      if (!sourceName) continue;

      let targetName = ev.targetName;
      if (!targetName && ev.targetID != null && meta.actorsById && meta.actorsById[ev.targetID]) {
        targetName = meta.actorsById[ev.targetID].name;
      }

      if (!playerCounts[sourceName]) {
        playerCounts[sourceName] = { count: 0, sourceSubType, targets: {}, events: [] };
      }
      playerCounts[sourceName].count++;
      totalDisarms++;

      // Track targets
      if (targetName) {
        playerCounts[sourceName].targets[targetName] = (playerCounts[sourceName].targets[targetName] || 0) + 1;
      }
      
      // Store individual event for detail view
      playerCounts[sourceName].events.push({
        timestamp: ev.timestamp,
        targetName: targetName || 'Unknown'
      });
    }
  }

  // Convert to sorted array
  const playerStats = Object.entries(playerCounts)
    .map(([name, data]) => ({
      name,
      count: data.count,
      sourceSubType: data.sourceSubType,
      topTargets: Object.entries(data.targets).sort((a, b) => b[1] - a[1]).slice(0, 3),
      events: data.events
    }))
    .sort((a, b) => b.count - a.count);
  
  console.log(`[ANALYSIS] Found ${totalDisarms} disarms by ${playerStats.length} players`);
  return { playerStats, totalDisarms };
}

// Analyze mage damage done while curses are active on friendly players
// Curses tracked: Veil of Darkness, Curse of the Plaguebringer, Life Drain
async function analyzeMageDamageWhileCurseUp(reportCode, meta) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );

  if (pagesResult.rows.length === 0) {
    return { playerStats: [], totalDamage: 0, curseWindows: 0 };
  }

  // Curse abilities to track (case-insensitive matching)
  const CURSE_NAMES = ['veil of darkness', 'curse of the plaguebringer', 'life drain'];
  
  // Build set of player actor IDs
  const playerActorIds = new Set();
  const mageActorIds = new Set();
  if (meta && meta.actorsById) {
    for (const [id, actor] of Object.entries(meta.actorsById)) {
      if (actor && actor.type === 'Player') {
        playerActorIds.add(Number(id));
        if (actor.subType && actor.subType.toLowerCase() === 'mage') {
          mageActorIds.add(Number(id));
        }
      }
    }
  }

  // First pass: collect all curse apply/remove events and damage events
  const curseEvents = []; // { type: 'apply'|'remove', targetId, timestamp, curseName }
  const damageEvents = []; // { sourceId, sourceName, timestamp, amount }

  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      
      // Check for curse apply/remove on friendly players
      if (type === 'applydebuff' || type === 'removedebuff') {
        const targetId = ev.targetID;
        if (!playerActorIds.has(targetId)) continue;
        
        // Get ability name
        const abilityId = ev.abilityGameID ?? ev.ability?.guid;
        let abilityName = '';
        if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
          abilityName = meta.abilitiesById[abilityId].name.toLowerCase();
        }
        
        // Check if it's one of our tracked curses
        const isCurse = CURSE_NAMES.some(curse => abilityName.includes(curse.split(' ')[0]));
        if (!isCurse) continue;
        
        curseEvents.push({
          type: type === 'applydebuff' ? 'apply' : 'remove',
          targetId,
          timestamp: ev.timestamp,
          curseName: abilityName
        });
      }
      
      // Track damage events from mages
      if (type === 'damage') {
        const sourceId = ev.sourceID;
        if (!mageActorIds.has(sourceId)) continue;
        
        const amount = ev.amount || 0;
        if (amount <= 0) continue;
        
        let sourceName = ev.sourceName;
        if (!sourceName && meta.actorsById && meta.actorsById[sourceId]) {
          sourceName = meta.actorsById[sourceId].name;
        }
        
        // Get ability/spell name
        const abilityId = ev.abilityGameID ?? ev.ability?.guid;
        let abilityName = '';
        if (abilityId != null && meta.abilitiesById && meta.abilitiesById[abilityId]) {
          abilityName = meta.abilitiesById[abilityId].name;
        }
        
        // Get target name
        let targetName = ev.targetName;
        if (!targetName && ev.targetID != null && meta.actorsById && meta.actorsById[ev.targetID]) {
          targetName = meta.actorsById[ev.targetID].name;
        }
        
        damageEvents.push({
          sourceId,
          sourceName,
          timestamp: ev.timestamp,
          amount,
          abilityName: abilityName || 'Unknown',
          targetName: targetName || 'Unknown'
        });
      }
    }
  }

  // Sort curse events by timestamp
  curseEvents.sort((a, b) => a.timestamp - b.timestamp);
  
  // Build curse windows (when any curse is active on any player)
  // Track per-player curse state
  const playerCurseState = {}; // { playerId: { curseCount, startTime } }
  const curseWindows = []; // { start, end }
  let globalCurseStart = null;
  let activeCurseCount = 0;
  
  const GRACE_PERIOD_MS = 1000; // 1 second grace period

  for (const ev of curseEvents) {
    if (ev.type === 'apply') {
      if (!playerCurseState[ev.targetId]) {
        playerCurseState[ev.targetId] = { curseCount: 0 };
      }
      playerCurseState[ev.targetId].curseCount++;
      activeCurseCount++;
      
      if (activeCurseCount === 1) {
        // First curse applied - start window (with grace period)
        globalCurseStart = ev.timestamp + GRACE_PERIOD_MS;
      }
    } else if (ev.type === 'remove') {
      if (playerCurseState[ev.targetId] && playerCurseState[ev.targetId].curseCount > 0) {
        playerCurseState[ev.targetId].curseCount--;
        activeCurseCount--;
        
        if (activeCurseCount === 0 && globalCurseStart !== null) {
          // Last curse removed - end window
          if (ev.timestamp > globalCurseStart) {
            curseWindows.push({ start: globalCurseStart, end: ev.timestamp });
          }
          globalCurseStart = null;
        }
      }
    }
  }

  // Calculate mage damage during curse windows
  const mageDamage = {}; // { sourceName: { totalDamage, events: [] } }
  let totalDamageWhileCurseUp = 0;

  for (const dmg of damageEvents) {
    // Check if this damage event falls within any curse window
    const inCurseWindow = curseWindows.some(w => dmg.timestamp >= w.start && dmg.timestamp <= w.end);
    if (!inCurseWindow) continue;
    
    if (!mageDamage[dmg.sourceName]) {
      mageDamage[dmg.sourceName] = { totalDamage: 0, events: [] };
    }
    mageDamage[dmg.sourceName].totalDamage += dmg.amount;
    mageDamage[dmg.sourceName].events.push({
      timestamp: dmg.timestamp,
      amount: dmg.amount,
      abilityName: dmg.abilityName,
      targetName: dmg.targetName
    });
    totalDamageWhileCurseUp += dmg.amount;
  }

  // Convert to sorted array
  const playerStats = Object.entries(mageDamage)
    .map(([name, data]) => ({
      name,
      damage: data.totalDamage,
      eventCount: data.events.length,
      events: data.events
    }))
    .sort((a, b) => b.damage - a.damage);

  console.log(`[ANALYSIS] Found ${totalDamageWhileCurseUp.toLocaleString()} mage damage during ${curseWindows.length} curse windows by ${playerStats.length} mages`);
  return { playerStats, totalDamage: totalDamageWhileCurseUp, curseWindows: curseWindows.length };
}

// Analyze Loatheb spore distribution - who got Fungal Bloom from each spore
async function analyzeLoathebSpores(reportCode, meta, fights) {
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );

  if (pagesResult.rows.length === 0) {
    return { sporeGroups: [], totalSpores: 0 };
  }

  // Find Loatheb fight(s) - also include Spore fights which happen during Loatheb
  const loathebFights = fights.filter(f =>
    f.encounterID === 1115 || f.encounterID === 51115 ||
    (f.name && (f.name.toLowerCase().includes('loatheb') || f.name.toLowerCase() === 'spore'))
  );

  console.log('[SPORE DEBUG] Loatheb/Spore fights found:', loathebFights.length);

  if (loathebFights.length === 0) {
    console.log('[ANALYSIS] No Loatheb fights found for spore analysis');
    return { sporeGroups: [], totalSpores: 0 };
  }

  // Build time ranges - use the overall min/max time to capture all spore buffs
  const minTime = Math.min(...loathebFights.map(f => f.startTime));
  const maxTime = Math.max(...loathebFights.map(f => f.endTime));
  const loathebTimeRanges = [{ start: minTime, end: maxTime }];

  // Fungal Creep spell ID is 29232 (confirmed from logs)

  // Build set of player actor IDs
  const playerActorIds = new Set();
  if (meta && meta.actorsById) {
    for (const [id, actor] of Object.entries(meta.actorsById)) {
      if (actor && actor.type === 'Player') {
        playerActorIds.add(Number(id));
      }
    }
  }

  // Strategy: Use CAST events (targetID=-1) as anchors for when spores explode
  // Then collect the applydebuff events that follow within 100ms
  // Only count players who don't already have the buff (first application only)
  
  const sporeCasts = []; // Cast events marking spore explosions
  const debuffApplications = []; // All Fungal Creep debuff applications

  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    for (const ev of events) {
      const type = String(ev.type || '').toLowerCase();
      
      // Check if in Loatheb fight time range
      const inLoatheb = loathebTimeRanges.some(r => ev.timestamp >= r.start && ev.timestamp <= r.end);
      if (!inLoatheb) continue;
      
      // Get ability info
      const abilityId = ev.abilityGameID ?? ev.ability?.guid;
      if (abilityId !== 29232) continue; // Only Fungal Creep
      
      // Collect cast events (spore explosions)
      if (type === 'cast' && ev.targetID === -1) {
        sporeCasts.push({ timestamp: ev.timestamp });
        continue;
      }
      
      // Collect debuff applications to players
      if (type === 'applydebuff') {
        const targetId = ev.targetID;
        if (!playerActorIds.has(targetId)) continue;
        
        let targetName = ev.targetName;
        if (!targetName && meta.actorsById && meta.actorsById[targetId]) {
          targetName = meta.actorsById[targetId].name;
        }
        
        debuffApplications.push({
          timestamp: ev.timestamp,
          targetId,
          targetName: targetName || `Player #${targetId}`
        });
      }
    }
  }

  // Sort both arrays by timestamp
  sporeCasts.sort((a, b) => a.timestamp - b.timestamp);
  debuffApplications.sort((a, b) => a.timestamp - b.timestamp);
  
  console.log(`[SPORE DEBUG] Found ${sporeCasts.length} spore casts and ${debuffApplications.length} debuff applications`);

  // Group debuff applications to their corresponding spore cast
  // Each cast should have applications within ~100ms after it
  const SPORE_WINDOW_MS = 100; // Debuffs applied within 100ms of cast
  const sporeGroups = [];
  const usedPlayers = new Set(); // Track which players already got a spore this fight (for first-time only tracking)
  
  for (let i = 0; i < sporeCasts.length; i++) {
    const cast = sporeCasts[i];
    const nextCastTime = i < sporeCasts.length - 1 ? sporeCasts[i + 1].timestamp : Infinity;
    
    // Find debuffs applied after this cast but before the next cast (or within window)
    const windowEnd = Math.min(cast.timestamp + SPORE_WINDOW_MS, nextCastTime);
    
    const players = [];
    const seenInThisSpore = new Set();
    
    for (const debuff of debuffApplications) {
      // Must be after the cast
      if (debuff.timestamp < cast.timestamp) continue;
      // Must be within the window
      if (debuff.timestamp > windowEnd) break;
      
      // Only count each player once per spore (avoid duplicates from rapid re-applications)
      if (seenInThisSpore.has(debuff.targetId)) continue;
      seenInThisSpore.add(debuff.targetId);
      
      players.push(debuff.targetName);
    }
    
    // Only add spore groups that have players (valid spores)
    if (players.length > 0) {
      sporeGroups.push({
        sporeNumber: sporeGroups.length + 1,
        timestamp: cast.timestamp,
        players
      });
    }
  }

  console.log(`[ANALYSIS] Found ${sporeGroups.length} Loatheb spores from ${sporeCasts.length} casts`);
  return { sporeGroups, totalSpores: sporeGroups.length };
}

// Fetch player stats directly from WCL API (exact numbers with class info)
async function fetchPlayerStatsFromWCL(reportCode) {
  try {
    const token = await getWclAccessToken();
    const apiUrl = 'https://vanilla.warcraftlogs.com/api/v2/client';
    
    // Fetch both damage and healing tables
    // Note: WCL uses "DamageDone" but just "Healing" (not "HealingDone")
    const query = `query($code: String!) {
      reportData {
        report(code: $code) {
          damageTable: table(dataType: DamageDone, startTime: 0, endTime: 999999999)
          healingTable: table(dataType: Healing, startTime: 0, endTime: 999999999)
        }
      }
    }`;
    
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ query, variables: { code: reportCode } })
    });
    
    const data = await response.json();
    
    if (data.errors) {
      throw new Error(data.errors[0].message);
    }
    
    const damageTable = data?.data?.reportData?.report?.damageTable?.data;
    const healingTable = data?.data?.reportData?.report?.healingTable?.data;
    
    // Get total time for DPS/HPS calculation (in milliseconds)
    // WCL uses totalTime (total raid duration) for DPS/HPS, not per-player activeTime
    const damageTotalTime = damageTable?.totalTime || 1;
    const healingTotalTime = healingTable?.totalTime || 1;
    
    // Process damage entries - include DPS using totalTime to match WCL
    const damage = (damageTable?.entries || [])
      .filter(e => e.type && e.type !== 'Pet')
      .map(e => ({
        name: e.name,
        amount: e.total,
        // DPS = total damage / totalTime (to match WCL's calculation)
        dps: e.total / (damageTotalTime / 1000),
        class: e.type || 'Unknown',
        percent: 0
      }))
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 30);
    
    // Calculate percent relative to top
    if (damage.length > 0) {
      const topDamage = damage[0].amount;
      for (const p of damage) {
        p.percent = (p.amount / topDamage) * 100;
      }
    }
    
    // Process healing entries - include HPS using totalTime to match WCL
    const healing = (healingTable?.entries || [])
      .filter(e => e.type && e.type !== 'Pet')
      .map(e => ({
        name: e.name,
        amount: e.total,
        // HPS = total healing / totalTime (to match WCL's calculation)
        hps: e.total / (healingTotalTime / 1000),
        class: e.type || 'Unknown',
        percent: 0
      }))
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 15);
    
    if (healing.length > 0) {
      const topHealing = healing[0].amount;
      for (const p of healing) {
        p.percent = (p.amount / topHealing) * 100;
      }
    }
    
    return { damage, healing };
  } catch (err) {
    console.error('[WCL] Failed to fetch player stats from API:', err.message);
    throw err;
  }
}

// Analyze player damage and healing stats from ALL events in database (fallback)
async function analyzePlayerStatsFromDB(reportCode, meta) {
  // Get all event pages for this report
  const pagesResult = await pool.query(
    'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
    [reportCode]
  );
  
  if (pagesResult.rows.length === 0) {
    return { damage: [], healing: [] };
  }
  
  // Aggregate damage and healing by source
  const damageByPlayer = new Map();
  const healingByPlayer = new Map();
  
  // Deduplicate events by creating a unique key for each
  const seenEvents = new Set();
  function getEventKey(ev) {
    return `${ev.timestamp}-${ev.sourceID}-${ev.targetID}-${ev.type}-${ev.abilityGameID || ev.ability?.guid || ''}-${ev.amount || 0}`;
  }
  
  let duplicateCount = 0;
  
  for (const row of pagesResult.rows) {
    const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
    
    for (const ev of events) {
      // Deduplicate events
      const eventKey = getEventKey(ev);
      if (seenEvents.has(eventKey)) {
        duplicateCount++;
        continue;
      }
      seenEvents.add(eventKey);
      
      const type = String(ev.type || '').toLowerCase();
      let amount = ev.amount || 0;
      
      if (amount <= 0) continue;
      
      // Get source name
      let sourceName = ev.sourceName;
      if (!sourceName && ev.sourceID != null && meta.actorsById && meta.actorsById[ev.sourceID]) {
        sourceName = meta.actorsById[ev.sourceID].name;
      }
      if (!sourceName) continue;
      
      // Only count player damage/healing (filter out pets, NPCs, etc.)
      // Check if source is a player (has a player type in actors)
      const sourceActor = ev.sourceID != null && meta.actorsById ? meta.actorsById[ev.sourceID] : null;
      const isPlayer = sourceActor && (sourceActor.type === 'Player' || sourceActor.subType === 'Player');
      
      // If we can't determine, include it (better to have extra than miss players)
      if (sourceActor && !isPlayer) continue;
      
      if (type === 'damage') {
        // Check target - filter out friendly fire (same faction) and trivial targets
        const targetActor = ev.targetID != null && meta.actorsById ? meta.actorsById[ev.targetID] : null;
        
        // Skip if target is a player (friendly fire)
        if (targetActor && (targetActor.type === 'Player' || targetActor.subType === 'Player')) {
          continue;
        }
        
        // Skip critters and trivial mobs (Maggot, Rat, etc.)
        const targetName = (ev.targetName || targetActor?.name || '').toLowerCase();
        if (targetName === 'maggot' || targetName === 'rat' || targetName === 'roach' || 
            targetName === 'spider' || targetName === 'frog' || targetName === 'larva' ||
            targetName === 'beetle' || targetName === 'cockroach' || targetName === 'snake') {
          continue;
        }
        
        // Skip mind-controlled/friendly NPCs that don't count for rankings
        // Death Knight Understudy - MC'd during Razuvious fight
        if (targetName === 'death knight understudy') {
          continue;
        }
        
        // Subtract overkill - WoW Logs doesn't count damage beyond killing blow
        const overkill = ev.overkill || 0;
        const effectiveDamage = Math.max(0, amount - overkill);
        
        if (effectiveDamage <= 0) continue;
        
        const current = damageByPlayer.get(sourceName) || 0;
        damageByPlayer.set(sourceName, current + effectiveDamage);
      } else if (type === 'heal') {
        // For healing, WCL 'amount' should already be effective healing (minus overheal)
        const current = healingByPlayer.get(sourceName) || 0;
        healingByPlayer.set(sourceName, current + amount);
      } else if (type === 'absorbed') {
        // Count absorbs as healing (shields like PW:S)
        // The source of an absorb event is the shielder
        const current = healingByPlayer.get(sourceName) || 0;
        healingByPlayer.set(sourceName, current + amount);
      } else if (type === 'healabsorbed') {
        // Some absorbs might be logged as healabsorbed
        const current = healingByPlayer.get(sourceName) || 0;
        healingByPlayer.set(sourceName, current + amount);
      }
    }
  }
  
  if (duplicateCount > 0) {
    console.log(`[PLAYER STATS] Skipped ${duplicateCount} duplicate events`);
  }
  
  // Convert to sorted arrays
  const damageList = Array.from(damageByPlayer.entries())
    .map(([name, amount]) => ({ name, amount }))
    .sort((a, b) => b.amount - a.amount);
  
  const healingList = Array.from(healingByPlayer.entries())
    .map(([name, amount]) => ({ name, amount }))
    .sort((a, b) => b.amount - a.amount);
  
  // Calculate percentages relative to top player
  const topDamage = damageList[0]?.amount || 1;
  const topHealing = healingList[0]?.amount || 1;
  
  for (const player of damageList) {
    player.percent = (player.amount / topDamage) * 100;
  }
  
  for (const player of healingList) {
    player.percent = (player.amount / topHealing) * 100;
  }
  
  console.log(`[PLAYER STATS] ${damageList.length} damage dealers, ${healingList.length} healers`);
  
  return {
    damage: damageList,
    healing: healingList
  };
}

// Test endpoint: Simulate polling behavior to verify cursor advancement
app.get('/api/wcl/test-polling', async (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();
  
  const sendEvent = (type, data) => {
    try {
      res.write(`event: ${type}\ndata: ${JSON.stringify(data)}\n\n`);
    } catch (_) {}
  };
  
  let aborted = false;
  req.on('close', () => { aborted = true; });
  
  sendEvent('connected', { reportCode: 'TEST-POLLING', message: 'Simulating polling behavior' });
  sendEvent('polling-started', { message: 'Test polling started' });
  
  let cursor = 1000000; // Start at 1 million ms
  const windowMs = 10000; // 10 second window
  let pollCount = 0;
  const maxPolls = 20; // Run 20 test polls
  
  console.log('[TEST-POLLING] Starting test polling simulation');
  
  while (!aborted && pollCount < maxPolls) {
    await new Promise(resolve => setTimeout(resolve, 1000)); // Poll every 1 second for faster testing
    
    if (aborted) break;
    
    const windowEnd = cursor + windowMs;
    const oldCursor = cursor;
    
    // Simulate API behavior: sometimes return events, sometimes don't
    const hasEvents = Math.random() > 0.5; // 50% chance of events
    const eventCount = hasEvents ? Math.floor(Math.random() * 10) + 1 : 0;
    
    // Simulate nextPageTimestamp (sometimes provided by API, sometimes not)
    const apiProvidedNext = Math.random() > 0.3; // 70% chance API provides next cursor
    const nextCursor = apiProvidedNext ? (cursor + Math.floor(Math.random() * 15000) + 5000) : null;
    
    if (hasEvents) {
      sendEvent('new-events', {
        count: eventCount,
        cursor: oldCursor,
        message: `Simulated ${eventCount} events`,
        apiProvidedNext
      });
    } else {
      sendEvent('heartbeat', {
        cursor: oldCursor,
        pollCount,
        message: 'No events in window',
        apiProvidedNext
      });
    }
    
    // Apply the FIXED cursor advancement logic
    if (nextCursor != null && nextCursor > cursor) {
      cursor = nextCursor;
      console.log(`[TEST-POLLING ${pollCount}] ‚úÖ Cursor advanced via API: ${oldCursor} -> ${cursor} (+${cursor - oldCursor}ms, ${eventCount} events)`);
    } else {
      cursor = windowEnd;
      console.log(`[TEST-POLLING ${pollCount}] ‚úÖ Cursor advanced by window: ${oldCursor} -> ${cursor} (+${cursor - oldCursor}ms, ${eventCount} events)`);
    }
    
    // Test the safeguard: detect if cursor didn't advance (should NEVER happen with fix)
    if (cursor <= oldCursor) {
      const error = `‚ö†Ô∏è CRITICAL: Cursor stuck at ${cursor}!`;
      console.error(`[TEST-POLLING ${pollCount}] ${error}`);
      sendEvent('warning', { message: error, cursor, oldCursor });
    }
    
    pollCount++;
  }
  
  sendEvent('test-complete', { 
    message: `Test complete: ${pollCount} polls simulated, cursor advanced from 1000000 to ${cursor}`,
    finalCursor: cursor,
    totalAdvancement: cursor - 1000000,
    pollCount 
  });
  
  console.log(`[TEST-POLLING] Test complete: cursor advanced ${cursor - 1000000}ms over ${pollCount} polls`);
  
  setTimeout(() => {
    try { res.end(); } catch (_) {}
  }, 1000);
});

// SSE endpoint: Streams import progress and events
app.get('/api/wcl/stream-import', async (req, res) => {
  const reportInput = String(req.query.report || '').trim();
  const reportCode = extractWclReportCode(reportInput);
  
  if (!reportCode) {
    return res.status(400).json({ error: 'Invalid report URL or code. Accepts full URL or just the report code (e.g., 4VxLvCnTtG8QryWb)' });
  }
  
  // Use report code as session ID for idempotent re-imports
  const sessionId = reportCode;
  
  const apiUrl = getWclApiUrlFromInput(reportInput);
  
  // Set up SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering
  res.flushHeaders();
  
  // Helper to send SSE events
  const sendEvent = (type, data) => {
    try {
      res.write(`event: ${type}\ndata: ${JSON.stringify(data)}\n\n`);
    } catch (_) {}
  };
  
  // Helper for safe pool queries (don't hold client)
  const safeQuery = async (sql, params) => {
    try {
      return await pool.query(sql, params);
    } catch (err) {
      console.error('SSE query error:', err.message);
      return null;
    }
  };
  
  let aborted = false;
  
  req.on('close', () => {
    aborted = true;
  });
  
  try {
    // Ensure tables exist (one-time setup)
    const setupClient = await pool.connect();
    try {
      await ensureWclIngestTables(setupClient);
      await ensureLiveSessionTable(setupClient);
      await ensureLiveHighlightsTable(setupClient);
    } finally {
      setupClient.release();
    }
    
    // Capture host info from authenticated user
    let hostName = 'Unknown';
    let hostId = null;
    if (req.isAuthenticated && req.isAuthenticated() && req.user) {
      hostName = req.user.username || req.user.displayName || req.user.global_name || 'Unknown';
      hostId = req.user.id || null;
    }
    
    // Set active live session for viewer connections
    activeLiveSession = { sessionId, reportCode, startTime: Date.now(), hostName, hostId };
    
    // Clear existing event pages for this report to avoid duplicates on re-import
    try {
      const deleteResult = await pool.query(
        'DELETE FROM wcl_event_pages WHERE report_code = $1',
        [reportCode]
      );
      if (deleteResult.rowCount > 0) {
        console.log(`[LIVE] Cleared ${deleteResult.rowCount} existing event pages for report ${reportCode}`);
      }
    } catch (clearErr) {
      console.error('[LIVE] Error clearing old event pages:', clearErr.message);
    }
    
    // Send initial connection event
    sendEvent('connected', { sessionId, reportCode, status: 'starting' });
    
    // Notify any connected viewers that a new session started
    broadcastHighlightsToViewers({ type: 'session-start', reportCode, timestamp: Date.now() });
    
    // Fetch report metadata first
    sendEvent('progress', { phase: 'meta', message: 'Fetching report metadata...' });
    
    let meta = { actorsById: {}, abilitiesById: {} };
    try {
      meta = await fetchWclReportMeta({ reportCode, apiUrl });
      // Store meta in DB
      await safeQuery(`
        INSERT INTO wcl_report_meta (report_code, api_url, actors_by_id, abilities_by_id, fetched_at)
        VALUES ($1, $2, $3, $4, NOW())
        ON CONFLICT (report_code)
        DO UPDATE SET api_url = EXCLUDED.api_url,
                      actors_by_id = EXCLUDED.actors_by_id,
                      abilities_by_id = EXCLUDED.abilities_by_id,
                      fetched_at = NOW();
      `, [reportCode, apiUrl, JSON.stringify(meta.actorsById || {}), JSON.stringify(meta.abilitiesById || {})]);
      sendEvent('meta', { actorCount: Object.keys(meta.actorsById).length, abilityCount: Object.keys(meta.abilitiesById).length });
    } catch (err) {
      sendEvent('warning', { message: 'Failed to fetch metadata, continuing without it' });
    }
    
    if (aborted) { res.end(); return; }
    
    // Fetch fights to estimate total duration
    sendEvent('progress', { phase: 'fights', message: 'Fetching fight list...' });
    
    let fights = [];
    let reportMaxEnd = null;
    let reportMinStart = null;
    try {
      fights = await fetchWclFights({ reportCode, apiUrl });
      for (const f of fights || []) {
        if (f && typeof f.endTime === 'number') {
          reportMaxEnd = reportMaxEnd == null ? f.endTime : Math.max(reportMaxEnd, f.endTime);
        }
        if (f && typeof f.startTime === 'number') {
          reportMinStart = reportMinStart == null ? f.startTime : Math.min(reportMinStart, f.startTime);
        }
      }
      sendEvent('fights', { count: fights.length, startTime: reportMinStart, endTime: reportMaxEnd, fights: fights.map(f => ({ id: f.id, name: f.name, startTime: f.startTime, endTime: f.endTime, kill: f.kill, encounterID: f.encounterID })) });
      
      // Save fights to cache and broadcast to live viewers immediately
      const fightsForLive = fights.map(f => ({ id: f.id, name: f.name, startTime: f.startTime, endTime: f.endTime, kill: f.kill, encounterID: f.encounterID }));
      await saveAndBroadcastHighlights(reportCode, 'meta', { fights: fightsForLive, tanks: [], hostName, hostId });
      console.log(`[LIVE] Saved ${fightsForLive.length} fights to meta cache for live viewers (host: ${hostName})`);
    } catch (err) {
      sendEvent('warning', { message: 'Failed to fetch fights list' });
    }
    
    if (aborted) { res.end(); return; }
    
    // Create/update session record
    await safeQuery(`
      INSERT INTO wcl_live_sessions (session_id, report_code, api_url, status, report_end_time)
      VALUES ($1, $2, $3, 'importing', $4)
      ON CONFLICT (session_id) DO UPDATE SET
        status = 'importing',
        report_end_time = EXCLUDED.report_end_time,
        updated_at = NOW();
    `, [sessionId, reportCode, apiUrl, reportMaxEnd]);
    
    // Start importing events
    sendEvent('progress', { phase: 'importing', message: 'Starting event import...' });
    
    // Always start from the beginning for display purposes
    // ON CONFLICT DO NOTHING will prevent duplicates in the database
    let startCursor = 0;
    if (reportMinStart && reportMinStart > 0) {
      startCursor = Math.max(0, reportMinStart - 5000); // Start 5s before first fight
    }
    
    // Check if we already have data (for informational purposes)
    try {
      const existing = await safeQuery(`
        SELECT COUNT(*) as page_count, COALESCE(SUM(jsonb_array_length(events)), 0) as event_count
        FROM wcl_event_pages 
        WHERE report_code = $1
      `, [reportCode]);
      const pageCount = Number(existing?.rows?.[0]?.page_count || 0);
      const eventCount = Number(existing?.rows?.[0]?.event_count || 0);
      if (pageCount > 0) {
        sendEvent('progress', { phase: 'refetching', message: `Found ${eventCount} cached events, fetching fresh data...` });
      }
    } catch (_) {}
    
    const windowMs = 60000; // 60 second pages for faster import
    let lastCursor = startCursor;
    let totalEvents = 0;
    let pagesStored = 0;
    let guard = 0;
    const maxGuard = 50000; // Safety limit
    
    // Calculate estimated total for progress bar
    const estimatedTotal = reportMaxEnd ? Math.ceil((reportMaxEnd - startCursor) / windowMs) : 100;
    
    console.log(`[LIVE] Starting event fetch loop: startCursor=${startCursor}, reportMaxEnd=${reportMaxEnd}, windowMs=${windowMs}`);
    
    while (!aborted && guard < maxGuard) {
      const end = lastCursor + windowMs;
      
      let page;
      try {
        console.log(`[LIVE] Fetching page: cursor=${lastCursor}, end=${end}`);
        page = await fetchWclEventsPage({ reportCode, startTime: lastCursor, endTime: end, apiUrl });
        console.log(`[LIVE] Got page: events=${page.events?.length || 0}, nextPageTimestamp=${page.nextPageTimestamp}`);
      } catch (err) {
        console.error(`[LIVE] Fetch error:`, err.message);
        sendEvent('error', { message: `Failed to fetch events: ${err.message}` });
        break;
      }
      
      const events = page.events || [];
      const nextCursor = page.nextPageTimestamp != null ? page.nextPageTimestamp : end;
      
      // Store this page
      if (events.length > 0) {
        const storeResult = await safeQuery(`
          INSERT INTO wcl_event_pages (event_id, report_code, start_time, end_time, next_cursor, events)
          VALUES ($1, $2, $3, $4, $5, $6)
          ON CONFLICT (event_id, report_code, start_time, end_time) DO NOTHING;
        `, [sessionId, reportCode, lastCursor, end, nextCursor, JSON.stringify(events)]);
        if (storeResult) pagesStored++;
      }
      
      totalEvents += events.length;
      
      // Calculate progress
      const progress = reportMaxEnd ? Math.min(100, Math.round(((lastCursor - startCursor) / (reportMaxEnd - startCursor)) * 100)) : Math.min(100, Math.round((pagesStored / estimatedTotal) * 100));
      
      // Enrich events with actor/ability names from metadata
      // Helper to enrich a single event
      const enrichEvent = (ev) => {
        const enriched = { ...ev };
        // Add source name
        if (ev.sourceID != null && meta.actorsById[ev.sourceID]) {
          enriched.sourceName = meta.actorsById[ev.sourceID].name;
          enriched.sourceType = meta.actorsById[ev.sourceID].type;
          enriched.sourceSubType = meta.actorsById[ev.sourceID].subType;
        }
        // Add target name
        if (ev.targetID != null && meta.actorsById[ev.targetID]) {
          enriched.targetName = meta.actorsById[ev.targetID].name;
          enriched.targetType = meta.actorsById[ev.targetID].type;
          enriched.targetSubType = meta.actorsById[ev.targetID].subType;
        }
        // Add ability name
        const abilityId = ev.abilityGameID ?? ev.ability?.guid;
        if (abilityId != null && meta.abilitiesById[abilityId]) {
          enriched.abilityName = meta.abilitiesById[abilityId].name;
          enriched.abilityType = meta.abilitiesById[abilityId].type;
        }
        return enriched;
      };
      
      // Highlight abilities we want to track (case-insensitive)
      const HIGHLIGHT_ABILITIES = ['power word: shield', 'bloodrage', 'charge', 'renew'];
      
      // Separate events into highlighted (send all) vs stream sample (send 50)
      const highlightedEvents = [];
      const otherEvents = [];
      
      for (const ev of events) {
        const abilityId = ev.abilityGameID ?? ev.ability?.guid;
        const abilityName = (abilityId != null && meta.abilitiesById[abilityId]) 
          ? meta.abilitiesById[abilityId].name.toLowerCase() 
          : '';
        const type = String(ev.type || '').toLowerCase();
        
        // Check if this is a highlighted ability (cast or applybuff)
        const isHighlight = (type === 'cast' || type === 'applybuff') && 
                            HIGHLIGHT_ABILITIES.some(h => abilityName.includes(h));
        
        // Also include all damage events for combat detection
        const isDamage = type === 'damage';
        
        if (isHighlight || isDamage) {
          highlightedEvents.push(enrichEvent(ev));
        } else {
          otherEvents.push(ev);
        }
      }
      
      // Enrich sample of other events for stream display
      const streamSample = otherEvents.slice(0, 50).map(enrichEvent);
      
      // Combine: all highlights + stream sample
      const enrichedEvents = [...highlightedEvents, ...streamSample];
      
      // Send batch of events to client
      sendEvent('events', { 
        count: events.length, 
        totalEvents,
        cursor: lastCursor,
        nextCursor,
        progress,
        pagesStored,
        events: enrichedEvents,
        highlightCount: highlightedEvents.length
      });
      
      // Update session record periodically
      if (pagesStored % 10 === 0) {
        await safeQuery(`
          UPDATE wcl_live_sessions 
          SET total_events = $1, last_cursor = $2, updated_at = NOW()
          WHERE session_id = $3
        `, [totalEvents, lastCursor, sessionId]);
      }
      
      // Stop conditions
      if (nextCursor == null || nextCursor <= lastCursor) {
        console.log(`[LIVE] Loop exit: no more pages (nextCursor=${nextCursor}, lastCursor=${lastCursor})`);
        break;
      }
      
      lastCursor = nextCursor;
      
      // Stop if we've passed the report end
      if (reportMaxEnd != null && lastCursor >= (reportMaxEnd + 60000)) {
        console.log(`[LIVE] Loop exit: passed report end (lastCursor=${lastCursor}, reportMaxEnd=${reportMaxEnd})`);
        break;
      }
      
      guard++;
    }
    
    console.log(`[LIVE] Fetch loop complete: totalEvents=${totalEvents}, pagesStored=${pagesStored}, guard=${guard}`);
    
    // Update session as complete
    await safeQuery(`
      UPDATE wcl_live_sessions 
      SET status = 'complete', total_events = $1, last_cursor = $2, updated_at = NOW()
      WHERE session_id = $3
    `, [totalEvents, lastCursor, sessionId]);
    
    // Send completion event
    sendEvent('complete', { 
      totalEvents, 
      pagesStored, 
      lastCursor,
      reportCode,
      sessionId,
      message: 'Import complete! Analyzing bloodrages...'
    });
    
    // Phase 2: Backend analysis of bad bloodrages
    // This uses ALL events from the database for accurate combat detection
    console.log('[LIVE] ====== STARTING PHASE 2: ANALYSIS ======');
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing all events for bad bloodrages...' });
    
    try {
      console.log('[LIVE] Starting bloodrage analysis...');
      const analysisResult = await analyzeBloodragesFromDB(reportCode, fights, meta);
      const bloodrageData = {
        badBloodrages: analysisResult.badBloodrages,
        totalBloodrages: analysisResult.totalBloodrages,
        combatSegments: analysisResult.combatSegmentCount,
        damageEvents: analysisResult.damageEventCount
      };
      sendEvent('bloodrage-analysis', bloodrageData);
      
      // Save to cache and broadcast to live viewers
      await saveAndBroadcastHighlights(reportCode, 'bloodrages', bloodrageData);
      
      console.log(`[LIVE] Bloodrage analysis complete: ${analysisResult.badBloodrages.length} bad out of ${analysisResult.totalBloodrages}`);
    } catch (analysisErr) {
      console.error('[LIVE] Bloodrage analysis error:', analysisErr.message);
      sendEvent('warning', { message: 'Bloodrage analysis failed: ' + analysisErr.message });
    }
    
    // Phase 2c: Player stats from WCL API (exact numbers with class info)
    sendEvent('progress', { phase: 'analyzing', message: 'Fetching damage and healing stats from WCL...' });
    try {
      const playerStats = await fetchPlayerStatsFromWCL(reportCode);
      const playerStatsData = {
        damage: playerStats.damage, // Top 30 damage
        healing: playerStats.healing // Top 15 healers
      };
      sendEvent('player-stats', playerStatsData);
      // Save to cache for live page
      await saveAndBroadcastHighlights(reportCode, 'playerstats', playerStatsData);
      console.log(`[LIVE] Player stats from WCL: ${playerStats.damage.length} damage dealers, ${playerStats.healing.length} healers`);
    } catch (statsErr) {
      console.error('[LIVE] WCL Player stats error:', statsErr.message);
      sendEvent('warning', { message: 'Player stats fetch failed: ' + statsErr.message });
    }
    
    // Phase 2b: Charge analysis (if tank names provided)
    const tankNamesParam = String(req.query.tanks || '').trim();
    const tankNames = tankNamesParam ? tankNamesParam.split(',').map(n => n.trim()).filter(Boolean) : [];
    
    if (tankNames.length > 0) {
      sendEvent('progress', { phase: 'analyzing', message: 'Analyzing charges...' });
      try {
        const chargeResult = await analyzeChargesFromDB(reportCode, tankNames, meta);
        const chargeData = {
          charges: chargeResult.charges,
          totalCharges: chargeResult.totalCharges,
          badCharges: chargeResult.badCharges
        };
        sendEvent('charge-analysis', chargeData);
        
        // Save to cache and broadcast to live viewers
        await saveAndBroadcastHighlights(reportCode, 'charges', chargeData);
        
        console.log(`[LIVE] Charge analysis complete: ${chargeResult.badCharges} bad out of ${chargeResult.totalCharges}`);
      } catch (chargeErr) {
        console.error('[LIVE] Charge analysis error:', chargeErr.message);
        sendEvent('warning', { message: 'Charge analysis failed: ' + chargeErr.message });
      }
    }
    
    // Phase 2d: Interrupts analysis
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing interrupts...' });
    try {
      const interruptResult = await analyzeInterruptsFromDB(reportCode, meta);
      const interruptData = {
        playerStats: interruptResult.playerStats,
        totalInterrupts: interruptResult.totalInterrupts
      };
      sendEvent('interrupt-analysis', interruptData);
      await saveAndBroadcastHighlights(reportCode, 'interrupts', interruptData);
      console.log(`[LIVE] Interrupt analysis complete: ${interruptResult.totalInterrupts} by ${interruptResult.playerStats.length} players`);
    } catch (err) {
      console.error('[LIVE] Interrupt analysis error:', err.message);
    }
    
    // Phase 2e: Decurses analysis
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing decurses...' });
    try {
      const decurseResult = await analyzeDecursesFromDB(reportCode, meta);
      const decurseData = {
        playerStats: decurseResult.playerStats,
        totalDecurses: decurseResult.totalDecurses
      };
      sendEvent('decurse-analysis', decurseData);
      await saveAndBroadcastHighlights(reportCode, 'decurses', decurseData);
      console.log(`[LIVE] Decurse analysis complete: ${decurseResult.totalDecurses} by ${decurseResult.playerStats.length} players`);
    } catch (err) {
      console.error('[LIVE] Decurse analysis error:', err.message);
    }
    
    // Phase 2f: Sunder Armor analysis
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing Sunder Armor...' });
    try {
      const sunderResult = await analyzeSundersFromDB(reportCode, meta);
      const sunderData = {
        playerStats: sunderResult.playerStats,
        effectiveSunders: sunderResult.effectiveSunders,
        totalSunders: sunderResult.totalSunders
      };
      sendEvent('sunder-analysis', sunderData);
      await saveAndBroadcastHighlights(reportCode, 'sunders', sunderData);
      console.log(`[LIVE] Sunder analysis complete: ${sunderResult.effectiveSunders} effective by ${sunderResult.playerStats.length} players`);
    } catch (err) {
      console.error('[LIVE] Sunder analysis error:', err.message);
    }
    
    // Phase 2g: Scorch (Fire Vulnerability) analysis
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing Scorch...' });
    try {
      const scorchResult = await analyzeScorchesFromDB(reportCode, meta);
      const scorchData = {
        playerStats: scorchResult.playerStats,
        effectiveScorches: scorchResult.effectiveScorches,
        totalScorches: scorchResult.totalScorches
      };
      sendEvent('scorch-analysis', scorchData);
      await saveAndBroadcastHighlights(reportCode, 'scorches', scorchData);
      console.log(`[LIVE] Scorch analysis complete: ${scorchResult.effectiveScorches} effective by ${scorchResult.playerStats.length} players`);
    } catch (err) {
      console.error('[LIVE] Scorch analysis error:', err.message);
    }
    
    // Phase 2h: Disarm analysis
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing Disarms...' });
    try {
      const disarmResult = await analyzeDisarmsFromDB(reportCode, meta);
      const disarmData = {
        playerStats: disarmResult.playerStats,
        totalDisarms: disarmResult.totalDisarms
      };
      sendEvent('disarm-analysis', disarmData);
      await saveAndBroadcastHighlights(reportCode, 'disarms', disarmData);
      console.log(`[LIVE] Disarm analysis complete: ${disarmResult.totalDisarms} by ${disarmResult.playerStats.length} players`);
    } catch (err) {
      console.error('[LIVE] Disarm analysis error:', err.message);
    }
    
    // Phase 2i: Calculate player deaths per fight from stored events
    sendEvent('progress', { phase: 'analyzing', message: 'Counting player deaths per encounter...' });
    try {
      // Get all death events from stored pages
      const deathPagesResult = await pool.query(
        'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
        [reportCode]
      );

      // Build a set of player actor IDs (exclude pets and NPCs)
      const playerActorIds = new Set();
      if (meta && meta.actorsById) {
        for (const [id, actor] of Object.entries(meta.actorsById)) {
          // Only include actual players, not pets or NPCs
          // In WCL data: type='Player' for players, type='Pet' for pets, type='NPC' for enemies
          // subType contains class name for players (e.g., 'Warrior', 'Priest')
          if (actor && actor.type === 'Player') {
            playerActorIds.add(Number(id));
          }
        }
      }
      console.log(`[LIVE] Found ${playerActorIds.size} player actors for death counting`);

      // Count PLAYER deaths per fight - only count deaths where target is a player
      // Use the 'fight' field from death events (more accurate than timestamp matching)
      const deathsByFight = {};
      const deathLog = []; // Track individual deaths for the deaths panel
      
      // Build a set of valid fight IDs for quick lookup
      const validFightIds = new Set(fights.map(f => f.id));

      for (const row of deathPagesResult.rows) {
        const events = Array.isArray(row.events) ? row.events : [];
        for (const ev of events) {
          if (ev && (ev.type || '').toLowerCase() === 'death') {
            const targetId = ev.targetID;

            // Only count if target is a player (not a pet, NPC, or enemy)
            if (!playerActorIds.has(targetId)) continue;

            // Get ability info for filtering - check multiple possible fields
            const abilityId = ev.abilityGameID || ev.killingAbilityGameID || ev.ability?.guid || 0;
            const abilityName = (abilityId && meta.abilitiesById && meta.abilitiesById[abilityId])
              ? meta.abilitiesById[abilityId].name
              : (abilityId ? `Ability #${abilityId}` : 'Unknown');
            
            // Filter out Feign Death and fake deaths
            // Feign Death ability ID is 5384, but WCL often logs it with abilityId=0 (no killing blow)
            // Deaths with abilityId=0 are fake deaths (Feign Death, spirit release, etc.)
            const sourceId = ev.sourceID;
            const isFeignDeath = 
              abilityId === 0 ||  // No killing blow = Feign Death or fake death
              abilityId === 5384 || 
              ev.abilityGameID === 5384 ||
              ev.killingAbilityGameID === 5384 ||
              abilityName.toLowerCase().includes('feign') ||
              (sourceId === targetId && sourceId > 0); // Self-inflicted = Feign Death
            
            if (isFeignDeath) {
              continue; // Skip Feign Death / fake deaths
            }

            // Use the fight field from the death event (WCL provides this)
            const fightId = ev.fight;
            if (!fightId || !validFightIds.has(fightId)) continue;
            
            // Get player name and death info
            const playerName = meta.actorsById[targetId]?.name || `Player #${targetId}`;
            const ts = ev.timestamp;

            // Add to death log
            deathLog.push({
              timestamp: ts,
              playerName,
              abilityName,
              abilityId,
              fightId
            });

            // Count deaths per fight using the fight field
            deathsByFight[fightId] = (deathsByFight[fightId] || 0) + 1;
          }
        }
      }

      console.log(`[LIVE] Player deaths found: ${deathLog.length} total across ${Object.keys(deathsByFight).length} fights`);

      // Update fights with deaths count and re-save meta
      const fightsWithDeaths = fights.map(f => ({
        id: f.id,
        name: f.name,
        startTime: f.startTime,
        endTime: f.endTime,
        kill: f.kill,
        encounterID: f.encounterID,
        deaths: deathsByFight[f.id] || 0
      }));

      await saveAndBroadcastHighlights(reportCode, 'meta', { fights: fightsWithDeaths, tanks: tankNames, hostName, hostId, deathLog });
      console.log(`[LIVE] Player deaths calculated: ${deathLog.length} total across ${Object.keys(deathsByFight).length} fights`);
      
      // Also save deaths as a separate highlight for the deaths panel
      await saveAndBroadcastHighlights(reportCode, 'deaths', { deaths: deathLog, count: deathLog.length });
    } catch (err) {
      console.error('[LIVE] Deaths calculation error:', err.message);
    }
    
    // Phase 2j: Mage damage while curses are active
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing mage damage during curses...' });
    try {
      const curseResult = await analyzeMageDamageWhileCurseUp(reportCode, meta);
      const curseData = {
        playerStats: curseResult.playerStats,
        totalDamage: curseResult.totalDamage,
        curseWindows: curseResult.curseWindows
      };
      sendEvent('curse-damage-analysis', curseData);
      await saveAndBroadcastHighlights(reportCode, 'curseDamage', curseData);
      console.log(`[LIVE] Curse damage analysis complete: ${curseResult.totalDamage.toLocaleString()} damage by ${curseResult.playerStats.length} mages during ${curseResult.curseWindows} curse windows`);
    } catch (err) {
      console.error('[LIVE] Curse damage analysis error:', err.message);
    }
    
    // Phase 2k: Loatheb spore distribution
    sendEvent('progress', { phase: 'analyzing', message: 'Analyzing Loatheb spores...' });
    try {
      const sporeResult = await analyzeLoathebSpores(reportCode, meta, fights);
      const sporeData = {
        sporeGroups: sporeResult.sporeGroups,
        totalSpores: sporeResult.totalSpores
      };
      sendEvent('spore-analysis', sporeData);
      await saveAndBroadcastHighlights(reportCode, 'spores', sporeData);
      console.log(`[LIVE] Spore analysis complete: ${sporeResult.totalSpores} spores tracked`);
    } catch (err) {
      console.error('[LIVE] Spore analysis error:', err.message);
    }
    
    console.log('[LIVE] ====== PHASE 2 COMPLETE - ALL ANALYSIS DONE ======');
    
    // Phase 3: Real-time polling for new events
    console.log('[LIVE] ====== STARTING PHASE 3: REAL-TIME POLLING ======');
    console.log(`[LIVE] aborted=${aborted}, lastCursor=${lastCursor}`);
    sendEvent('progress', { phase: 'polling', message: 'Watching for new events...' });
    sendEvent('polling-started', { message: 'Real-time polling started', cursor: lastCursor });
    
    // Poll for new events every 3 seconds
    let pollCount = 0;
    const maxPolls = 1000; // ~50 minutes of polling
    const reanalysisInterval = 10; // Re-run analysis every 10 polls (30 seconds)
    let lastAnalysisPollCount = 0;
    
    // Safeguard: Track cursor advancement to detect stuck polling
    let lastCursorValue = lastCursor;
    let cursorsStuckCount = 0;
    const MAX_STUCK_POLLS = 5; // Alert if cursor doesn't advance for 5 consecutive polls
    
    // Smart jump: Track empty polls and re-check for fights if stuck in empty space
    let consecutiveEmptyPolls = 0;
    const EMPTY_POLL_RECHECK_THRESHOLD = 20; // Re-check fights every 20 empty polls (~60 seconds)
    let lastFightCheckPoll = -999; // Ensure we don't re-check too frequently
    
    console.log('[LIVE] Entering polling loop (maxPolls=1000, interval=3s)');
    console.log(`[LIVE] Initial cursor: ${lastCursor}, windowMs: ${windowMs}`);
    while (!aborted && pollCount < maxPolls) {
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      if (aborted) break;
      
      const pollEnd = lastCursor + windowMs;
      let pollPage;
      try {
        pollPage = await fetchWclEventsPage({ reportCode, startTime: lastCursor, endTime: pollEnd, apiUrl });
      } catch (err) {
        sendEvent('poll-error', { message: err.message });
        pollCount++;
        continue;
      }
      
      const newEvents = pollPage.events || [];
      const pollNextCursor = pollPage.nextPageTimestamp;
      let hasNewEvents = false;
      
      if (newEvents.length > 0) {
        hasNewEvents = true;
        consecutiveEmptyPolls = 0; // Reset empty poll counter - we found data!
        
        // Store new events
        await safeQuery(`
          INSERT INTO wcl_event_pages (event_id, report_code, start_time, end_time, next_cursor, events)
          VALUES ($1, $2, $3, $4, $5, $6)
          ON CONFLICT (event_id, report_code, start_time, end_time) DO NOTHING;
        `, [sessionId, reportCode, lastCursor, pollEnd, pollNextCursor, JSON.stringify(newEvents)]);
        
        totalEvents += newEvents.length;
        
        // Enrich new events with metadata
        const enrichedNewEvents = newEvents.slice(0, 50).map(ev => {
          const enriched = { ...ev };
          if (ev.sourceID != null && meta.actorsById[ev.sourceID]) {
            enriched.sourceName = meta.actorsById[ev.sourceID].name;
            enriched.sourceType = meta.actorsById[ev.sourceID].type;
          }
          if (ev.targetID != null && meta.actorsById[ev.targetID]) {
            enriched.targetName = meta.actorsById[ev.targetID].name;
            enriched.targetType = meta.actorsById[ev.targetID].type;
          }
          const abilityId = ev.abilityGameID ?? ev.ability?.guid;
          if (abilityId != null && meta.abilitiesById[abilityId]) {
            enriched.abilityName = meta.abilitiesById[abilityId].name;
          }
          return enriched;
        });
        
        sendEvent('new-events', {
          count: newEvents.length,
          totalEvents,
          cursor: lastCursor,
          events: enrichedNewEvents
        });
      } else {
        // No events in this poll - track consecutive empty polls
        consecutiveEmptyPolls++;
        
        // SMART JUMP: If stuck getting empty polls, re-check if fights now exist
        if (consecutiveEmptyPolls >= EMPTY_POLL_RECHECK_THRESHOLD && 
            (pollCount - lastFightCheckPoll) >= EMPTY_POLL_RECHECK_THRESHOLD) {
          
          console.log(`[LIVE POLL ${pollCount}] üîç ${consecutiveEmptyPolls} consecutive empty polls - re-checking for fights...`);
          lastFightCheckPoll = pollCount;
          
          try {
            const freshFights = await fetchWclFights({ reportCode, apiUrl });
            if (freshFights && freshFights.length > 0) {
              let minFightStart = null;
              for (const f of freshFights) {
                if (f && typeof f.startTime === 'number') {
                  minFightStart = minFightStart == null ? f.startTime : Math.min(minFightStart, f.startTime);
                }
              }
              
              if (minFightStart != null && minFightStart > lastCursor) {
                const jumpTo = Math.max(0, minFightStart - 5000); // 5s before first fight
                const jumpDistance = jumpTo - lastCursor;
                
                console.log(`[LIVE POLL ${pollCount}] üöÄ SMART JUMP: Found ${freshFights.length} fights! Jumping from ${lastCursor}ms to ${jumpTo}ms (skip ${jumpDistance}ms)`);
                sendEvent('progress', { 
                  phase: 'jump', 
                  message: `Found ${freshFights.length} fights! Jumping ahead ${Math.round(jumpDistance/1000/60)} minutes...`,
                  jumpFrom: lastCursor,
                  jumpTo: jumpTo,
                  fightsFound: freshFights.length
                });
                
                lastCursor = jumpTo;
                consecutiveEmptyPolls = 0; // Reset counter after jump
                pollCount++; // Increment and continue to next poll immediately
                continue;
              }
            } else {
              console.log(`[LIVE POLL ${pollCount}] No fights found yet - continuing sequential polling`);
            }
          } catch (jumpErr) {
            console.error(`[LIVE POLL ${pollCount}] Error during fight re-check:`, jumpErr.message);
          }
        }
        
        // Send heartbeat to keep connection alive with detailed status
        sendEvent('heartbeat', { 
          cursor: lastCursor, 
          pollCount, 
          totalEvents,
          timestamp: Date.now(),
          windowStart: lastCursor,
          windowEnd: pollEnd,
          cursorAdvancing: true,
          consecutiveEmptyPolls // Include in heartbeat for debugging
        });
      }
      
      // Always advance cursor (even if no events found) to catch up to real-time
      // Use API's nextPageTimestamp if available, otherwise advance by window
      const oldCursor = lastCursor;
      if (pollNextCursor != null && pollNextCursor > lastCursor) {
        lastCursor = pollNextCursor;
        const delta = lastCursor - oldCursor;
        console.log(`[LIVE POLL ${pollCount}] ‚úÖ Cursor advanced via API: ${oldCursor} -> ${lastCursor} (+${delta}ms, ${newEvents.length} events)`);
      } else {
        // If API doesn't provide next cursor, advance by window size
        lastCursor = pollEnd;
        const delta = lastCursor - oldCursor;
        console.log(`[LIVE POLL ${pollCount}] ‚úÖ Cursor advanced by window: ${oldCursor} -> ${lastCursor} (+${delta}ms, ${newEvents.length} events)`);
      }
      
      // Safeguard: Detect if cursor is stuck (critical bug indicator)
      if (lastCursor <= lastCursorValue) {
        cursorsStuckCount++;
        console.error(`[LIVE POLL ${pollCount}] ‚ö†Ô∏è WARNING: Cursor did not advance! Stuck count: ${cursorsStuckCount}/${MAX_STUCK_POLLS}`);
        console.error(`[LIVE POLL ${pollCount}] lastCursorValue: ${lastCursorValue}, newCursor: ${lastCursor}, pollNextCursor: ${pollNextCursor}, pollEnd: ${pollEnd}`);
        
        if (cursorsStuckCount >= MAX_STUCK_POLLS) {
          const errorMsg = `CRITICAL: Cursor stuck for ${MAX_STUCK_POLLS} consecutive polls - polling may not work correctly`;
          console.error(`[LIVE POLL ${pollCount}] ${errorMsg}`);
          sendEvent('warning', { 
            message: errorMsg,
            cursor: lastCursor,
            pollCount,
            debugInfo: { lastCursorValue, pollNextCursor, pollEnd, newEventsCount: newEvents.length }
          });
        }
      } else {
        cursorsStuckCount = 0; // Reset counter on successful advancement
      }
      lastCursorValue = lastCursor;
      
      // Periodic re-analysis every 30 seconds (if there were new events since last analysis)
      if (hasNewEvents && (pollCount - lastAnalysisPollCount) >= reanalysisInterval) {
        console.log(`[LIVE] Running periodic re-analysis at poll ${pollCount}`);
        lastAnalysisPollCount = pollCount;
        
        try {
          // Re-run bloodrage analysis
          const analysisResult = await analyzeBloodragesFromDB(reportCode, fights, meta);
          const bloodrageData = {
            badBloodrages: analysisResult.badBloodrages,
            totalBloodrages: analysisResult.totalBloodrages,
            combatSegments: analysisResult.combatSegmentCount,
            damageEvents: analysisResult.damageEventCount,
            isUpdate: true
          };
          sendEvent('bloodrage-analysis', bloodrageData);
          await saveAndBroadcastHighlights(reportCode, 'bloodrages', bloodrageData);
          
          // Re-run charge analysis if tanks provided
          if (tankNames.length > 0) {
            const chargeResult = await analyzeChargesFromDB(reportCode, tankNames, meta);
            const chargeData = {
              charges: chargeResult.charges,
              totalCharges: chargeResult.totalCharges,
              badCharges: chargeResult.badCharges,
              isUpdate: true
            };
            sendEvent('charge-analysis', chargeData);
            await saveAndBroadcastHighlights(reportCode, 'charges', chargeData);
          }
          
          console.log(`[LIVE] Periodic re-analysis complete: ${analysisResult.badBloodrages.length} bad BRs`);
        } catch (reanalysisErr) {
          console.error('[LIVE] Periodic re-analysis error:', reanalysisErr.message);
        }
      }
      
      pollCount++;
    }
    
    sendEvent('session-end', { message: 'Polling session ended', totalEvents, lastCursor });
    
  } catch (err) {
    sendEvent('error', { message: err.message || 'Unknown error' });
  } finally {
    activeLiveSession = null; // Clear active session when done
    try { res.end(); } catch (_) {}
  }
});

// Debug endpoint to compare our damage AND healing calculation with WCL's
app.get('/api/debug/compare/:reportCode/:playerName', async (req, res) => {
  const { reportCode, playerName } = req.params;
  
  try {
    // 1. Get our calculated damage for this player
    const metaResult = await pool.query(
      'SELECT actors_by_id, abilities_by_id FROM wcl_report_meta WHERE report_code = $1',
      [reportCode]
    );
    
    if (metaResult.rows.length === 0) {
      return res.status(404).json({ error: 'Report not found in database' });
    }
    
    const meta = {
      actorsById: metaResult.rows[0].actors_by_id || {},
      abilitiesById: metaResult.rows[0].abilities_by_id || {}
    };
    
    // Get all events for this player
    const pagesResult = await pool.query(
      'SELECT events FROM wcl_event_pages WHERE report_code = $1 ORDER BY start_time',
      [reportCode]
    );
    
    const playerNameLower = playerName.toLowerCase();
    let ourTotal = 0;
    let ourTotalWithOverkill = 0;
    const eventBreakdown = {};
    const excludedEvents = [];
    const includedSample = [];
    
    const seenEvents = new Set();
    function getEventKey(ev) {
      return `${ev.timestamp}-${ev.sourceID}-${ev.targetID}-${ev.type}-${ev.abilityGameID || ev.ability?.guid || ''}-${ev.amount || 0}`;
    }
    
    for (const row of pagesResult.rows) {
      const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
      
      for (const ev of events) {
        // Deduplicate
        const eventKey = getEventKey(ev);
        if (seenEvents.has(eventKey)) continue;
        seenEvents.add(eventKey);
        
        const type = String(ev.type || '').toLowerCase();
        if (type !== 'damage') continue;
        
        // Check if this is from our player
        let sourceName = ev.sourceName;
        if (!sourceName && ev.sourceID != null && meta.actorsById[ev.sourceID]) {
          sourceName = meta.actorsById[ev.sourceID].name;
        }
        if (!sourceName || sourceName.toLowerCase() !== playerNameLower) continue;
        
        const amount = ev.amount || 0;
        const overkill = ev.overkill || 0;
        
        // Get target info
        const targetActor = ev.targetID != null ? meta.actorsById[ev.targetID] : null;
        const targetName = ev.targetName || targetActor?.name || `#${ev.targetID}`;
        const abilityName = ev.abilityName || (ev.abilityGameID && meta.abilitiesById[ev.abilityGameID]?.name) || 'Unknown';
        
        // Check exclusion reasons
        let excluded = false;
        let excludeReason = '';
        
        // Check if target is player
        if (targetActor && (targetActor.type === 'Player' || targetActor.subType === 'Player')) {
          excluded = true;
          excludeReason = 'Target is player (friendly fire)';
        }
        
        // Check critters
        const targetNameLower = targetName.toLowerCase();
        if (!excluded && (targetNameLower === 'maggot' || targetNameLower === 'rat' || targetNameLower === 'roach' || 
            targetNameLower === 'spider' || targetNameLower === 'frog' || targetNameLower === 'larva' ||
            targetNameLower === 'beetle' || targetNameLower === 'cockroach' || targetNameLower === 'snake')) {
          excluded = true;
          excludeReason = 'Target is critter';
        }
        
        // Check mind-controlled/friendly NPCs
        if (!excluded && targetNameLower === 'death knight understudy') {
          excluded = true;
          excludeReason = 'Target is MC\'d NPC (Razuvious fight)';
        }
        
        ourTotalWithOverkill += amount;
        
        if (excluded) {
          excludedEvents.push({
            timestamp: ev.timestamp,
            target: targetName,
            ability: abilityName,
            amount,
            overkill,
            reason: excludeReason
          });
          continue;
        }
        
        const effectiveDamage = Math.max(0, amount - overkill);
        ourTotal += effectiveDamage;
        
        // Track by target
        if (!eventBreakdown[targetName]) {
          eventBreakdown[targetName] = { count: 0, total: 0, overkill: 0 };
        }
        eventBreakdown[targetName].count++;
        eventBreakdown[targetName].total += effectiveDamage;
        eventBreakdown[targetName].overkill += overkill;
        
        // Sample first few events
        if (includedSample.length < 20) {
          includedSample.push({
            timestamp: ev.timestamp,
            target: targetName,
            ability: abilityName,
            amount,
            overkill,
            effective: effectiveDamage
          });
        }
      }
    }
    
    // Also calculate healing for this player
    let ourHealingTotal = 0;
    const healEventBreakdown = {};
    const healSeenEvents = new Set();
    const healIncludedSample = [];
    
    for (const row of pagesResult.rows) {
      const events = typeof row.events === 'string' ? JSON.parse(row.events) : row.events;
      
      for (const ev of events) {
        // Deduplicate
        const eventKey = getEventKey(ev);
        if (healSeenEvents.has(eventKey)) continue;
        healSeenEvents.add(eventKey);
        
        const type = String(ev.type || '').toLowerCase();
        if (type !== 'heal' && type !== 'absorbed' && type !== 'healabsorbed') continue;
        
        // Check if this is from our player
        let sourceName = ev.sourceName;
        if (!sourceName && ev.sourceID != null && meta.actorsById[ev.sourceID]) {
          sourceName = meta.actorsById[ev.sourceID].name;
        }
        if (!sourceName || sourceName.toLowerCase() !== playerNameLower) continue;
        
        const amount = ev.amount || 0;
        const overheal = ev.overheal || 0;
        const effectiveHeal = Math.max(0, amount - overheal);
        
        ourHealingTotal += effectiveHeal;
        
        // Get target info
        const targetActor = ev.targetID != null ? meta.actorsById[ev.targetID] : null;
        const targetName = ev.targetName || targetActor?.name || `#${ev.targetID}`;
        const abilityName = ev.abilityName || (ev.abilityGameID && meta.abilitiesById[ev.abilityGameID]?.name) || 'Unknown';
        
        // Track by target
        if (!healEventBreakdown[targetName]) {
          healEventBreakdown[targetName] = { count: 0, total: 0, overheal: 0 };
        }
        healEventBreakdown[targetName].count++;
        healEventBreakdown[targetName].total += effectiveHeal;
        healEventBreakdown[targetName].overheal += overheal;
        
        if (healIncludedSample.length < 20) {
          healIncludedSample.push({
            timestamp: ev.timestamp,
            target: targetName,
            ability: abilityName,
            amount,
            overheal,
            effective: effectiveHeal
          });
        }
      }
    }
    
    // 2. Query WCL API for their damage AND healing totals
    let wclDamageTotal = null;
    let wclDamageBreakdown = null;
    let wclHealingTotal = null;
    let wclHealingBreakdown = null;
    try {
      const token = await getWclAccessToken();
      const apiUrl = 'https://vanilla.warcraftlogs.com/api/v2/client';
      
      const query = `query($code: String!) {
        reportData {
          report(code: $code) {
            damageTable: table(dataType: DamageDone, startTime: 0, endTime: 999999999)
            healingTable: table(dataType: Healing, startTime: 0, endTime: 999999999)
          }
        }
      }`;
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ query, variables: { code: reportCode } })
      });
      
      const data = await response.json();
      const damageTable = data?.data?.reportData?.report?.damageTable?.data;
      const healingTable = data?.data?.reportData?.report?.healingTable?.data;
      
      if (damageTable && damageTable.entries) {
        const playerEntry = damageTable.entries.find(e => 
          e.name && e.name.toLowerCase() === playerNameLower
        );
        if (playerEntry) {
          wclDamageTotal = playerEntry.total;
          wclDamageBreakdown = playerEntry;
        }
      }
      
      if (healingTable && healingTable.entries) {
        const playerEntry = healingTable.entries.find(e => 
          e.name && e.name.toLowerCase() === playerNameLower
        );
        if (playerEntry) {
          wclHealingTotal = playerEntry.total;
          wclHealingBreakdown = playerEntry;
        }
      }
    } catch (wclErr) {
      console.error('WCL API error:', wclErr.message);
    }
    
    // Sort damage breakdown by total
    const sortedBreakdown = Object.entries(eventBreakdown)
      .map(([target, data]) => ({ target, ...data }))
      .sort((a, b) => b.total - a.total)
      .slice(0, 30);
    
    // Sort healing breakdown by total
    const sortedHealBreakdown = Object.entries(healEventBreakdown)
      .map(([target, data]) => ({ target, ...data }))
      .sort((a, b) => b.total - a.total)
      .slice(0, 30);
    
    res.json({
      player: playerName,
      reportCode,
      damage: {
        ourTotal,
        ourTotalWithOverkill,
        wclTotal: wclDamageTotal,
        difference: wclDamageTotal ? ourTotal - wclDamageTotal : null,
        differencePercent: wclDamageTotal ? ((ourTotal - wclDamageTotal) / wclDamageTotal * 100).toFixed(2) + '%' : null,
        overkillSubtracted: ourTotalWithOverkill - ourTotal,
        topTargets: sortedBreakdown,
        excludedEvents: excludedEvents.slice(0, 50),
        includedSample,
        wclBreakdown: wclDamageBreakdown
      },
      healing: {
        ourTotal: ourHealingTotal,
        wclTotal: wclHealingTotal,
        difference: wclHealingTotal ? ourHealingTotal - wclHealingTotal : null,
        differencePercent: wclHealingTotal ? ((ourHealingTotal - wclHealingTotal) / wclHealingTotal * 100).toFixed(2) + '%' : null,
        topTargets: sortedHealBreakdown,
        includedSample: healIncludedSample,
        wclBreakdown: wclHealingBreakdown
      }
    });
    
  } catch (err) {
    console.error('Debug compare error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Fetch damage and healing leaderboards directly from WCL API
// This gives exact WCL numbers including class info
app.get('/api/wcl/leaderboards/:reportCode', async (req, res) => {
  const { reportCode } = req.params;
  
  try {
    const token = await getWclAccessToken();
    const apiUrl = 'https://vanilla.warcraftlogs.com/api/v2/client';
    
    // Fetch both damage and healing tables
    // Note: WCL uses "DamageDone" but just "Healing" (not "HealingDone")
    const query = `query($code: String!) {
      reportData {
        report(code: $code) {
          damageTable: table(dataType: DamageDone, startTime: 0, endTime: 999999999)
          healingTable: table(dataType: Healing, startTime: 0, endTime: 999999999)
        }
      }
    }`;
    
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ query, variables: { code: reportCode } })
    });
    
    const data = await response.json();
    
    if (data.errors) {
      return res.status(400).json({ error: data.errors[0].message });
    }
    
    const damageTable = data?.data?.reportData?.report?.damageTable?.data;
    const healingTable = data?.data?.reportData?.report?.healingTable?.data;
    
    // Process damage entries
    const damage = (damageTable?.entries || [])
      .filter(e => e.type && e.type !== 'Pet') // Filter out pets
      .map(e => ({
        name: e.name,
        amount: e.total,
        class: e.type || 'Unknown',
        icon: e.icon,
        percent: 0 // Will calculate below
      }))
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 30);
    
    // Calculate percent relative to top
    if (damage.length > 0) {
      const topDamage = damage[0].amount;
      for (const p of damage) {
        p.percent = (p.amount / topDamage) * 100;
      }
    }
    
    // Process healing entries
    const healing = (healingTable?.entries || [])
      .filter(e => e.type && e.type !== 'Pet')
      .map(e => ({
        name: e.name,
        amount: e.total,
        class: e.type || 'Unknown',
        icon: e.icon,
        percent: 0
      }))
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 15);
    
    if (healing.length > 0) {
      const topHealing = healing[0].amount;
      for (const p of healing) {
        p.percent = (p.amount / topHealing) * 100;
      }
    }
    
    res.json({
      reportCode,
      damage,
      healing,
      totalDamage: damageTable?.totalDamage || 0,
      totalHealing: healingTable?.totalHealing || 0
    });
    
  } catch (err) {
    console.error('WCL leaderboards error:', err);
    res.status(500).json({ error: err.message });
  }
});

// SSE endpoint for live page viewers - streams from cached highlights
app.get('/api/live/stream', async (req, res) => {
  // Set up SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no');
  res.flushHeaders();
  
  // Add this connection to viewers set
  liveViewerConnections.add(res);
  console.log(`[LIVE VIEWER] Connected. Total viewers: ${liveViewerConnections.size}`);
  
  // Send initial state from cache
  try {
    const result = await pool.query('SELECT highlight_type, highlights, updated_at FROM wcl_live_highlights ORDER BY updated_at DESC');
    const cached = {};
    for (const row of result.rows) {
      cached[row.highlight_type] = typeof row.highlights === 'string' ? JSON.parse(row.highlights) : row.highlights;
    }
    
    // Send current session status
    res.write(`event: init\ndata: ${JSON.stringify({ 
      active: activeLiveSession != null,
      session: activeLiveSession,
      cached,
      viewerCount: liveViewerConnections.size
    })}\n\n`);
  } catch (err) {
    res.write(`event: error\ndata: ${JSON.stringify({ message: 'Failed to load cached highlights' })}\n\n`);
  }
  
  // Handle client disconnect
  req.on('close', () => {
    liveViewerConnections.delete(res);
    console.log(`[LIVE VIEWER] Disconnected. Total viewers: ${liveViewerConnections.size}`);
  });
  
  // Send heartbeat every 15 seconds to keep connection alive
  const heartbeatInterval = setInterval(() => {
    try {
      res.write(`event: heartbeat\ndata: ${JSON.stringify({ 
        time: Date.now(),
        viewerCount: liveViewerConnections.size 
      })}\n\n`);
    } catch (_) {
      clearInterval(heartbeatInterval);
      liveViewerConnections.delete(res);
    }
  }, 15000);
  
  req.on('close', () => clearInterval(heartbeatInterval));
});

// API to save PW:S highlights from host
app.post('/api/live/highlights/pws', express.json({ limit: '5mb' }), async (req, res) => {
  const { reportCode, events, fights, tanks } = req.body || {};
  if (!reportCode || !Array.isArray(events)) {
    return res.status(400).json({ ok: false, error: 'Missing reportCode or events' });
  }
  try {
    await saveAndBroadcastHighlights(reportCode, 'pws', { events, count: events.length });
    // Also save meta data (fights, tanks) for detail modals on live page
    if (fights || tanks) {
      await saveAndBroadcastHighlights(reportCode, 'meta', { fights: fights || [], tanks: tanks || [] });
    }
    res.json({ ok: true, count: events.length });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

// API to save Renew highlights from host
app.post('/api/live/highlights/renew', express.json({ limit: '5mb' }), async (req, res) => {
  const { reportCode, events } = req.body || {};
  if (!reportCode || !Array.isArray(events)) {
    return res.status(400).json({ ok: false, error: 'Missing reportCode or events' });
  }
  try {
    await saveAndBroadcastHighlights(reportCode, 'renew', { events, count: events.length });
    res.json({ ok: true, count: events.length });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

// API to stop the active live session
app.post('/api/live/stop', async (req, res) => {
  activeLiveSession = null;
  broadcastHighlightsToViewers({ type: 'stopped', timestamp: Date.now() });
  res.json({ ok: true, message: 'Live session stopped' });
});

// API to clear all highlights
app.post('/api/live/clear', async (req, res) => {
  try {
    await pool.query('DELETE FROM wcl_live_highlights');
    broadcastHighlightsToViewers({ type: 'clear', timestamp: Date.now() });
    res.json({ ok: true, message: 'Highlights cleared' });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

// API to get live session status (for navigation indicator)
app.get('/api/live/status', async (req, res) => {
  try {
    res.json({
      active: activeLiveSession != null,
      session: activeLiveSession ? {
        reportCode: activeLiveSession.reportCode,
        startTime: activeLiveSession.startTime
      } : null,
      viewerCount: liveViewerConnections.size
    });
  } catch (err) {
    res.status(500).json({ active: false, error: err.message });
  }
});

// Get session status
app.get('/api/wcl/live-session/:sessionId', async (req, res) => {
  let client;
  try {
    const { sessionId } = req.params;
    client = await pool.connect();
    await ensureLiveSessionTable(client);
    
    const result = await client.query(`
      SELECT * FROM wcl_live_sessions WHERE session_id = $1
    `, [sessionId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ ok: false, error: 'Session not found' });
    }
    
    res.json({ ok: true, session: result.rows[0] });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  } finally {
    if (client) client.release();
  }
});

app.get('/api/db-status', (req, res) => {
  res.json({ status: dbConnectionStatus });
});

// --- Role-Based Access Control Endpoints ---

// Endpoint to get user's permissions only
app.get('/api/user/permissions', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Authentication required' });
  }

  try {
    const isManagement = await hasManagementRoleById(req.user.id);

    res.json({
      hasManagementRole: isManagement,
      permissions: {
        canManage: isManagement
      }
    });
  } catch (error) {
    console.error('Error fetching user permissions:', error);
    res.status(500).json({ 
      message: 'Error fetching permissions',
      error: error.message 
    });
  }
});

// --- Assignments API ---
app.get('/api/assignments/:eventId', async (req, res) => {
  const { eventId } = req.params;
  try {
    // Ensure defaults table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS raid_assignment_defaults (
        dungeon TEXT NOT NULL,
        wing TEXT NOT NULL,
        boss TEXT NOT NULL,
        default_strategy_text TEXT,
        updated_by TEXT,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        PRIMARY KEY (dungeon, wing, boss)
      )
    `);
    // Ensure core Naxx Spider Wing panels exist (Anub'Rekhan, Grand Widow Faerlina)
    const base = await pool.query(
      `SELECT * FROM raid_assignments WHERE event_id = $1 ORDER BY id ASC`,
      [eventId]
    );

    // Always ensure Anub'Rekhan exists
    await pool.query(
      `INSERT INTO raid_assignments (event_id, dungeon, wing, boss, strategy_text, image_url, image_url_full, boss_icon_url, video_url)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
       ON CONFLICT (event_id, dungeon, wing, boss) DO NOTHING`,
      [
        eventId,
        'Naxxramas',
        'Spider Wing',
        "Anub'Rekhan",
        'Assignments will appear here.',
        'https://res.cloudinary.com/duthjs0c3/image/upload/v1754768041/Anubian_mid_eeb1zj.jpg',
        'https://res.cloudinary.com/duthjs0c3/image/upload/v1754768042/Anubian_full_s1fmvs.png',
        'https://res.cloudinary.com/duthjs0c3/image/upload/v1754809667/30800_etmqmc.png',
        'https://www.youtube.com/embed/yEh16DOAs-k?si=sbFC_3eSplmFyuav&start=13&controls=0&modestbranding=1&rel=0&iv_load_policy=3'
      ]
    );
    // Always ensure Grand Widow Faerlina exists
    await pool.query(
      `INSERT INTO raid_assignments (event_id, dungeon, wing, boss, strategy_text, image_url, image_url_full, boss_icon_url, video_url)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
       ON CONFLICT (event_id, dungeon, wing, boss) DO NOTHING`,
      [
        eventId,
        'Naxxramas',
        'Spider Wing',
        'Grand Widow Faerlina',
        "Kill the 2 followers fast (Skull and Cross), then nuke boss. Move out of rain of fire.\n\nAssigned priests use mind control and Widow's Embrace to dispel Enrage from the boss.",
        'https://res.cloudinary.com/duthjs0c3/image/upload/v1754816216/Faerlina_mid_xzjrtj.jpg',
        'https://res.cloudinary.com/duthjs0c3/image/upload/v1754816215/Faerlina_full_wdeu9g.png',
        'https://res.cloudinary.com/duthjs0c3/image/upload/v1754815959/3kvUdFR_kx7gif.png',
        'https://www.youtube.com/embed/JaAJ01RTsP4'
      ]
    );

    const panelsResult = await pool.query(
      `SELECT id, dungeon, wing, boss, strategy_text, image_url, image_url_full, boss_icon_url, video_url
       FROM raid_assignments WHERE event_id = $1
       ORDER BY dungeon, wing NULLS FIRST, boss`,
      [eventId]
    );
    // Load defaults and merge by (dungeon, wing, boss)
    const defaultsRes = await pool.query(
      `SELECT dungeon, wing, boss, default_strategy_text FROM raid_assignment_defaults`
    );
    const dKey = (d,w,b) => `${String(d||'')}|${String(w||'')}|${String(b||'')}`;
    const defaultsMap = new Map(defaultsRes.rows.map(r => [dKey(r.dungeon, r.wing, r.boss), r.default_strategy_text || '']));
    const entriesResult = await pool.query(
      `SELECT rae.*, ro.is_placeholder 
       FROM raid_assignment_entries rae
       LEFT JOIN roster_overrides ro 
         ON ro.event_id = rae.event_id 
         AND LOWER(ro.assigned_char_name) = LOWER(rae.character_name)
       WHERE rae.event_id = $1 
       ORDER BY rae.sort_index, rae.id`,
      [eventId]
    );
    const acceptsResult = await pool.query(
      `SELECT event_id, dungeon, wing, boss, character_name, accept_status, accept_set_by, accept_updated_at
       FROM raid_assignment_entry_accepts WHERE event_id = $1`,
      [eventId]
    );
    const acceptKey = (e) => `${e.event_id}|${(e.dungeon||'')}|${(e.wing||'')}|${(e.boss||'')}|${(e.character_name||'').toLowerCase()}`;
    const acceptsMap = new Map(acceptsResult.rows.map(r => [acceptKey(r), r]));

    const panels = panelsResult.rows.map(p => ({
      ...p,
      default_strategy_text: defaultsMap.get(dKey(p.dungeon, p.wing || '', p.boss)) || '',
      entries: entriesResult.rows
        .filter(e => e.dungeon === p.dungeon && (e.wing || '') === (p.wing || '') && e.boss === p.boss)
        .map(e => {
          const key = `${eventId}|${p.dungeon||''}|${p.wing||''}|${p.boss||''}|${(e.character_name||'').toLowerCase()}`;
          const acc = acceptsMap.get(key);
          return {
            ...e,
            is_placeholder: e.is_placeholder || false,
            accept_status: acc?.accept_status || null,
            accept_set_by: acc?.accept_set_by || null,
            accept_updated_at: acc?.accept_updated_at || null,
          };
        })
    }));

    res.json({ success: true, panels });
  } catch (error) {
    console.error('Error fetching assignments:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch assignments' });
  }
});

// Management action to insert Faerlina panel with defaults
app.post('/api/assignments/:eventId/seed/faerlina', requireManagement, async (req, res) => {
  const { eventId } = req.params;
  const dungeon = 'Naxxramas';
  const wing = 'Spider Wing';
  const boss = 'Grand Widow Faerlina';
  const strategy = 'Kill the 2 followers fast (Skull and Cross), then nuke boss. Move out of rain of fire.\n\nAssigned priests use mind control and Widow\'s Embrace to dispel Enrage from the boss.';
  const imageMid = 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754816216/Faerlina_mid_xzjrtj.jpg';
  const imageFull = 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754816215/Faerlina_full_wdeu9g.png';
  const bossIcon = 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754815959/3kvUdFR_kx7gif.png';
  const video = 'https://www.youtube.com/embed/JaAJ01RTsP4';
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await client.query(
      `INSERT INTO raid_assignments (event_id, dungeon, wing, boss, strategy_text, image_url, image_url_full, boss_icon_url, video_url)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
       ON CONFLICT (event_id, dungeon, wing, boss)
       DO UPDATE SET strategy_text = EXCLUDED.strategy_text, image_url = EXCLUDED.image_url, image_url_full = EXCLUDED.image_url_full, boss_icon_url = EXCLUDED.boss_icon_url, video_url = EXCLUDED.video_url, updated_at = NOW()`,
      [eventId, dungeon, wing, boss, strategy, imageMid, imageFull, bossIcon, video]
    );
    // Build template entries from current roster
    const rosterRes = await client.query(
      `SELECT assigned_char_name AS character_name, assigned_char_class AS class_name, assigned_char_spec AS spec_name, assigned_char_spec_emote AS spec_emote, party_id, slot_id
         FROM roster_overrides WHERE event_id = $1 AND assigned_char_name IS NOT NULL`,
      [eventId]
    );
    const templates = buildFaerlinaTemplateEntries(rosterRes.rows);
    // Clear existing entries for this panel and insert defaults
    await client.query(
      `DELETE FROM raid_assignment_entries WHERE event_id = $1 AND dungeon = $2 AND wing = $3 AND boss = $4`,
      [eventId, dungeon, wing, boss]
    );
    let sortIndex = 0;
    for (const t of templates) {
      await client.query(
        `INSERT INTO raid_assignment_entries (event_id, dungeon, wing, boss, character_name, marker_icon_url, assignment, sort_index)
         VALUES ($1,$2,$3,$4,$5,$6,$7,$8)`,
        [eventId, dungeon, wing, boss, t.character_name, t.marker_icon_url || null, t.assignment || null, sortIndex++]
      );
    }
    await client.query('COMMIT');
    res.json({ success: true });
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('Error seeding Faerlina panel:', err);
    res.status(500).json({ success: false, message: 'Failed to seed Faerlina panel' });
  } finally {
    client.release();
  }
});

// Helper for Faerlina default templates
function buildFaerlinaTemplateEntries(roster) {
  const byPartySlot = (p, s) => roster.find(r => Number(r.party_id) === Number(p) && Number(r.slot_id) === Number(s));
  const findPriestsSorted = () => roster.filter(r => String(r.class_name).toLowerCase() === 'priest')
    .sort((a,b) => (Number(a.party_id)||99) - (Number(b.party_id)||99) || (Number(a.slot_id)||99) - (Number(b.slot_id)||99));
  const priests = findPriestsSorted();
  const p1 = priests[0];
  const p2 = priests[1];
  const entries = [];
  const icons = {
    skull: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/1_skull_faqei8.png',
    cross: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/2_cross_kj9wuf.png',
    square: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/3_square_yqucv9.png',
    moon: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/4_moon_vwhoen.png',
    triangle: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/5_triangle_rbpjyi.png',
    diamond: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/6_diamond_hre1uj.png',
    circle: 'https://res.cloudinary.com/duthjs0c3/image/upload/v1754765896/7_circle_zayctt.png'
  };
  const pushIf = (r, icon, text) => { if (r) entries.push({ character_name: r.character_name, marker_icon_url: icon, assignment: text }); };
  // #1 G1 S1 tank boss (square)
  pushIf(byPartySlot(1,1), icons.square, 'Tank the boss');
  // #2 G1 S2 tank left 2 adds (triangle)
  pushIf(byPartySlot(1,2), icons.triangle, 'Tank the left 2 adds');
  // #3 G1 S2 tank left 2 adds (moon)
  pushIf(byPartySlot(1,2), icons.moon, 'Tank the left 2 adds');
  // #4 G1 S3 tank right 2 adds (diamond)
  pushIf(byPartySlot(1,3), icons.diamond, 'Tank the right 2 adds');
  // #5 G1 S3 tank right 2 adds (circle)
  pushIf(byPartySlot(1,3), icons.circle, 'Tank the right 2 adds');
  // #6 G2 S1 tank Skull
  pushIf(byPartySlot(2,1), icons.skull, 'Tank Skull');
  // #7 G2 S2 tank Cross
  pushIf(byPartySlot(2,2), icons.cross, 'Tank Cross (pull it to boss)');
  // #8 First priest MC
  if (p1) entries.push({ character_name: p1.character_name, marker_icon_url: icons.diamond, assignment: "Use mind control and Widow's Embrace to dispel Enrage from the boss. Start with Diamond and Circle targets." });
  // #9 First priest MC Circle
  if (p1) entries.push({ character_name: p1.character_name, marker_icon_url: icons.circle, assignment: "Use mind control and Widow's Embrace to dispel Enrage from the boss. Start with Diamond and Circle targets." });
  // #10 Second priest backup
  if (p2) entries.push({ character_name: p2.character_name, marker_icon_url: icons.circle, assignment: 'Backup mindcontrol in case the assigned priest dies or fails.' });
  return entries;
}
// Accept/Decline API: player can update own entry; managers can update any
app.post('/api/assignments/:eventId/entry/accept', express.json(), async (req, res) => {
  const { eventId } = req.params;
  const { dungeon, wing = '', boss, character_name, accept_status } = req.body || {};
  if (!eventId || !dungeon || !boss || !character_name || !['accept','decline',null,''].includes(accept_status)) {
    return res.status(400).json({ success: false, message: 'Invalid payload' });
  }
  const isAuthed = req.isAuthenticated && req.isAuthenticated();
  if (!isAuthed) return res.status(401).json({ success: false, message: 'Login required' });
  const actingUserId = req.user?.id;
  try {
    // Determine if acting user is manager
    let isManager = false;
    try { isManager = await hasManagementRoleById(req.user.id); } catch {}
    // Verify ownership: character_name in roster_overrides for this event must have discord_user_id == acting user
    const ownerRes = await pool.query(
      `SELECT discord_user_id FROM roster_overrides WHERE event_id = $1 AND LOWER(assigned_char_name) = LOWER($2) LIMIT 1`,
      [eventId, character_name]
    );
    const ownerId = ownerRes.rows[0]?.discord_user_id || null;
    const canEdit = isManager || (ownerId && ownerId === actingUserId);
    if (!canEdit) return res.status(403).json({ success: false, message: 'Forbidden' });

    await pool.query(
      `INSERT INTO raid_assignment_entry_accepts (event_id, dungeon, wing, boss, character_name, accept_status, accept_set_by, accept_updated_at)
       VALUES ($1,$2,$3,$4,$5,$6,$7,NOW())
       ON CONFLICT (event_id, dungeon, wing, boss, character_name)
       DO UPDATE SET accept_status = EXCLUDED.accept_status, accept_set_by = EXCLUDED.accept_set_by, accept_updated_at = NOW()`,
      [eventId, dungeon, wing || '', boss, character_name, accept_status || null, actingUserId]
    );
    res.json({ success: true });
  } catch (error) {
    console.error('Error updating accept status:', error);
    res.status(500).json({ success: false, message: 'Failed to update status' });
  }
});

// Returns roster for assignments for a given event, enriched with class color and spec icon
app.get('/api/assignments/:eventId/roster', async (req, res) => {
  const { eventId } = req.params;
  try {
    const result = await pool.query(
      `SELECT 
         ro.assigned_char_name AS character_name,
         ro.assigned_char_class AS class_name,
         ro.assigned_char_spec AS spec_name,
         ro.assigned_char_spec_emote AS spec_emote,
         ro.discord_user_id,
         ro.party_id,
         ro.slot_id,
         ro.is_placeholder,
         csm.class_color_hex AS class_color,
         csm.spec_icon_url
       FROM roster_overrides ro
       LEFT JOIN class_spec_mappings csm 
         ON LOWER(csm.class_name) = LOWER(ro.assigned_char_class)
        AND LOWER(csm.spec_name) = LOWER(ro.assigned_char_spec)
       WHERE ro.event_id = $1
         AND ro.assigned_char_name IS NOT NULL
       ORDER BY ro.assigned_char_name`,
      [eventId]
    );
    res.json({ success: true, roster: result.rows });
  } catch (error) {
    console.error('Error fetching assignments roster:', error);
    res.status(500).json({ success: false, message: 'Failed to fetch roster' });
  }
});

app.post('/api/assignments/:eventId/save', requireRosterManager, express.json(), async (req, res) => {
  const { eventId } = req.params;
  const { panels } = req.body || {};
  if (!Array.isArray(panels)) return res.status(400).json({ success: false, message: 'Invalid payload' });
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    // Build roster lookup for validation and spec/class derivation
    const rosterRes = await client.query(
      `SELECT assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, discord_user_id
         FROM roster_overrides WHERE event_id = $1 AND assigned_char_name IS NOT NULL`,
      [eventId]
    );
    const rosterByName = new Map();
    for (const r of rosterRes.rows) {
      rosterByName.set(String(r.assigned_char_name).toLowerCase(), r);
    }
    // Preload class/spec mapping
    const csmRes = await client.query(`SELECT class_name, spec_name, class_color_hex FROM class_spec_mappings`);
    const csmKey = (c, s) => `${String(c).toLowerCase()}|${String(s).toLowerCase()}`;
    const csmMap = new Map();
    for (const m of csmRes.rows) csmMap.set(csmKey(m.class_name, m.spec_name), m);
    for (const panel of panels) {
      const { dungeon, wing = null, boss, strategy_text, image_url, entries = [] } = panel;
      if (!dungeon || !boss) continue;
        await client.query(
          `INSERT INTO raid_assignments (event_id, dungeon, wing, boss, strategy_text, image_url, image_url_full, boss_icon_url)
           VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
         ON CONFLICT (event_id, dungeon, wing, boss)
           DO UPDATE SET strategy_text = EXCLUDED.strategy_text, image_url = EXCLUDED.image_url, image_url_full = EXCLUDED.image_url_full, boss_icon_url = EXCLUDED.boss_icon_url, updated_at = NOW()`,
          [eventId, dungeon, wing || '', boss, strategy_text || null, image_url || null, panel.image_url_full || null, panel.boss_icon_url || null]
      );
        // Update optional video_url if provided on payload
        if (panel.video_url !== undefined) {
          await client.query(
            `UPDATE raid_assignments SET video_url = $1, updated_at = NOW() WHERE event_id = $2 AND dungeon = $3 AND COALESCE(wing,'') = $4 AND boss = $5`,
            [panel.video_url || null, eventId, dungeon, wing || '', boss]
          );
        }
        // Update optional image_url_full and boss_icon_url if provided
        if (panel.image_url_full !== undefined || panel.boss_icon_url !== undefined) {
          await client.query(
            `UPDATE raid_assignments SET image_url_full = COALESCE($1, image_url_full), boss_icon_url = COALESCE($2, boss_icon_url), updated_at = NOW()
             WHERE event_id = $3 AND dungeon = $4 AND COALESCE(wing,'') = $5 AND boss = $6`,
            [panel.image_url_full ?? null, panel.boss_icon_url ?? null, eventId, dungeon, wing || '', boss]
          );
        }

      // Clear and re-insert entries for this panel for simplicity
      await client.query(
        `DELETE FROM raid_assignment_entries WHERE event_id = $1 AND dungeon = $2 AND wing = $3 AND boss = $4`,
        [eventId, dungeon, wing || '', boss]
      );

      let sortIndex = 0;
      for (const entry of entries) {
        const { character_name, assignment, marker_icon_url, accept_status } = entry;
        if (!character_name) continue;
        const roster = rosterByName.get(String(character_name).toLowerCase());
        if (!roster) {
          throw new Error(`Player '${character_name}' is not in the roster for this event`);
        }
        const cls = roster.assigned_char_class || '';
        const spc = roster.assigned_char_spec || '';
        const emote = roster.assigned_char_spec_emote || null;
        const map = csmMap.get(csmKey(cls, spc));
        const classColor = map?.class_color_hex || null;
        await client.query(
          `INSERT INTO raid_assignment_entries
            (event_id, dungeon, wing, boss, character_name, class_name, class_color, spec_name, spec_emote, marker_icon_url, assignment, sort_index, character_discord_id)
           VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)`,
          [eventId, dungeon, wing || '', boss, character_name, cls || null, classColor, spc || null, emote, marker_icon_url || null, assignment || null, sortIndex++, roster?.discord_user_id || null]
        );
        // Persist acceptance state: upsert for accept/decline, clear for null/empty
        if (accept_status === 'accept' || accept_status === 'decline') {
          await client.query(
            `INSERT INTO raid_assignment_entry_accepts (event_id, dungeon, wing, boss, character_name, accept_status, accept_set_by, accept_updated_at)
             VALUES ($1,$2,$3,$4,$5,$6,$7,NOW())
             ON CONFLICT (event_id, dungeon, wing, boss, character_name)
             DO UPDATE SET accept_status = EXCLUDED.accept_status, accept_set_by = EXCLUDED.accept_set_by, accept_updated_at = NOW()`,
            [eventId, dungeon, wing || '', boss, character_name, accept_status, req.user?.id || null]
          );
        } else {
          await client.query(
            `DELETE FROM raid_assignment_entry_accepts WHERE event_id = $1 AND dungeon = $2 AND wing = $3 AND boss = $4 AND character_name = $5`,
            [eventId, dungeon, wing || '', boss, character_name]
          );
        }
      }
    }
    await client.query('COMMIT');
    res.json({ success: true });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error saving assignments:', error);
    res.status(500).json({ success: false, message: 'Failed to save assignments' });
  } finally {
    client.release();
  }
});

// Get Four Horsemen active tactics for an event (returns 'classic' or 'cleave')
app.get('/api/assignments/:eventId/horsemen-tactics', async (req, res) => {
  const { eventId } = req.params;
  try {
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS event_horsemen_tactics (
        event_id VARCHAR(100) PRIMARY KEY,
        active_tactics VARCHAR(20) DEFAULT 'classic',
        updated_by TEXT,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      )
    `);
    
    const result = await pool.query(
      `SELECT active_tactics FROM event_horsemen_tactics WHERE event_id = $1`,
      [eventId]
    );
    
    const activeTactics = result.rows.length > 0 ? result.rows[0].active_tactics : 'classic';
    res.json({ success: true, activeTactics });
  } catch (error) {
    console.error('Error getting horsemen tactics:', error);
    res.status(500).json({ success: false, message: 'Failed to get tactics' });
  }
});

// Set Four Horsemen active tactics for an event (management only)
app.post('/api/assignments/:eventId/horsemen-tactics', requireManagement, express.json(), async (req, res) => {
  const { eventId } = req.params;
  const { activeTactics } = req.body || {};
  
  if (!activeTactics || !['classic', 'cleave'].includes(activeTactics)) {
    return res.status(400).json({ success: false, message: 'Invalid tactics value' });
  }
  
  try {
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS event_horsemen_tactics (
        event_id VARCHAR(100) PRIMARY KEY,
        active_tactics VARCHAR(20) DEFAULT 'classic',
        updated_by TEXT,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      )
    `);
    
    const actingUserId = req.user?.id || null;
    await pool.query(
      `INSERT INTO event_horsemen_tactics (event_id, active_tactics, updated_by, updated_at)
       VALUES ($1, $2, $3, NOW())
       ON CONFLICT (event_id)
       DO UPDATE SET active_tactics = EXCLUDED.active_tactics, updated_by = EXCLUDED.updated_by, updated_at = NOW()`,
      [eventId, activeTactics, actingUserId]
    );
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error saving horsemen tactics:', error);
    res.status(500).json({ success: false, message: 'Failed to save tactics' });
  }
});

// Save or update a default strategy text (manager only)
app.post('/api/assignments/defaults/save', requireManagement, express.json(), async (req, res) => {
  try {
    const { dungeon, wing = '', boss, default_strategy_text } = req.body || {};
    if (!dungeon || !boss) return res.status(400).json({ success: false, message: 'Invalid payload' });
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS raid_assignment_defaults (
        dungeon TEXT NOT NULL,
        wing TEXT NOT NULL,
        boss TEXT NOT NULL,
        default_strategy_text TEXT,
        updated_by TEXT,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        PRIMARY KEY (dungeon, wing, boss)
      )
    `);
    const actingUserId = req.user?.id || null;
    await pool.query(
      `INSERT INTO raid_assignment_defaults (dungeon, wing, boss, default_strategy_text, updated_by, updated_at)
       VALUES ($1,$2,$3,$4,$5,NOW())
       ON CONFLICT (dungeon, wing, boss)
       DO UPDATE SET default_strategy_text = EXCLUDED.default_strategy_text, updated_by = EXCLUDED.updated_by, updated_at = NOW()`,
      [dungeon, wing || '', boss, default_strategy_text || '', actingUserId]
    );
    res.json({ success: true });
  } catch (error) {
    console.error('Error saving assignment default:', error);
    res.status(500).json({ success: false, message: 'Failed to save default' });
  }
});

// Replace assignments: rename character across all entries for an event, preserving other entries
app.post('/api/assignments/:eventId/replace-name', requireRosterManager, express.json(), async (req, res) => {
  const { eventId } = req.params;
  const { fromName, toName, matchMode } = req.body || {};
  if (!eventId || !fromName || !toName) {
    return res.status(400).json({ success: false, message: 'Missing eventId, fromName or toName' });
  }
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    // Resolve target player from roster for this event
    const rosterRes = await client.query(
      `SELECT assigned_char_name AS character_name,
              assigned_char_class AS class_name,
              assigned_char_spec  AS spec_name,
              assigned_char_spec_emote AS spec_emote,
              discord_user_id
         FROM roster_overrides
        WHERE event_id = $1 AND LOWER(assigned_char_name) = LOWER($2)
        LIMIT 1`,
      [eventId, toName]
    );
    if (!rosterRes.rows.length) {
      await client.query('ROLLBACK');
      return res.status(400).json({ success: false, message: `Target '${toName}' is not in the roster for this event` });
    }
    const target = rosterRes.rows[0];
    // Resolve class color
    let classColor = null;
    try {
      const csm = await client.query(
        `SELECT class_color_hex FROM class_spec_mappings WHERE LOWER(class_name) = LOWER($1) AND LOWER(spec_name) = LOWER($2) LIMIT 1`,
        [target.class_name || '', target.spec_name || '']
      );
      classColor = csm.rows[0]?.class_color_hex || null;
    } catch {}

    // Fetch affected entries for reporting (exact or partial)
    const isPartial = String(matchMode || '').toLowerCase() === 'partial';
    const affected = await client.query(
      isPartial ?
      `SELECT dungeon, wing, boss, assignment, character_name
         FROM raid_assignment_entries
        WHERE event_id = $1 AND LOWER(character_name) LIKE LOWER($2)` :
      `SELECT dungeon, wing, boss, assignment, character_name
         FROM raid_assignment_entries
        WHERE event_id = $1 AND LOWER(character_name) = LOWER($2)`,
      [eventId, isPartial ? `%${fromName.toLowerCase()}%` : fromName]
    );
    const replacedList = affected.rows || [];

    // Update entries
    const upd = await client.query(
      isPartial ?
      `UPDATE raid_assignment_entries
          SET character_name = $2,
              class_name = $3,
              class_color = $4,
              spec_name = $5,
              spec_emote = $6,
              character_discord_id = $7
        WHERE event_id = $1 AND LOWER(character_name) LIKE LOWER($8)` :
      `UPDATE raid_assignment_entries
          SET character_name = $2,
              class_name = $3,
              class_color = $4,
              spec_name = $5,
              spec_emote = $6,
              character_discord_id = $7
        WHERE event_id = $1 AND LOWER(character_name) = LOWER($8)`,
      [eventId, target.character_name, target.class_name || null, classColor, target.spec_name || null, target.spec_emote || null, target.discord_user_id || null, isPartial ? `%${fromName.toLowerCase()}%` : fromName]
    );

    const replacedCount = Number(upd.rowCount || 0);

    // Move accept/decline states from fromName to toName per panel
    try {
      const accRows = await client.query(
        `SELECT dungeon, wing, boss, accept_status, accept_set_by, accept_updated_at
           FROM raid_assignment_entry_accepts
          WHERE event_id = $1 AND LOWER(character_name) = LOWER($2)`,
        [eventId, fromName]
      );
      for (const row of accRows.rows) {
        await client.query(
          `INSERT INTO raid_assignment_entry_accepts (event_id, dungeon, wing, boss, character_name, accept_status, accept_set_by, accept_updated_at)
           VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
           ON CONFLICT (event_id, dungeon, wing, boss, character_name)
           DO UPDATE SET accept_status = EXCLUDED.accept_status, accept_set_by = EXCLUDED.accept_set_by, accept_updated_at = EXCLUDED.accept_updated_at`,
          [eventId, row.dungeon, row.wing || '', row.boss, target.character_name, row.accept_status || null, row.accept_set_by || null, row.accept_updated_at || new Date()]
        );
      }
      await client.query(
        `DELETE FROM raid_assignment_entry_accepts WHERE event_id = $1 AND LOWER(character_name) = LOWER($2)`,
        [eventId, fromName]
      );
    } catch {}

    await client.query('COMMIT');
    return res.json({ success: true, replacedCount, replacedList });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error replacing assignment names:', error);
    return res.status(500).json({ success: false, message: 'Failed to replace assignments' });
  } finally {
    client.release();
  }
});

// API to get tank names for an event (for livehost filtering)
app.get('/api/event/:eventId/tanks', async (req, res) => {
  const { eventId } = req.params;
  console.log(`[TANKS API] Fetching tanks for event: ${eventId}`);
  let client;
  try {
    client = await pool.connect();
    
    // First, try to find tank entries - check what wing/boss values exist
    const checkResult = await client.query(`
      SELECT DISTINCT wing, boss FROM raid_assignment_entries WHERE event_id = $1
    `, [eventId]);
    console.log(`[TANKS API] Wings/bosses found for event ${eventId}:`, checkResult.rows);
    
    // Get tank entries - try multiple possible combinations
    let result = await client.query(`
      SELECT character_name, assignment, marker_icon_url, sort_index
      FROM raid_assignment_entries
      WHERE event_id = $1 AND boss = 'Tanking'
      ORDER BY sort_index ASC
      LIMIT 4
    `, [eventId]);
    
    // If no results, try looking for 'Main Tank', 'Off Tank' in assignment field
    if (result.rows.length === 0) {
      console.log(`[TANKS API] No Tanking boss found, trying assignment field...`);
      result = await client.query(`
        SELECT character_name, assignment, marker_icon_url, sort_index
        FROM raid_assignment_entries
        WHERE event_id = $1 AND (assignment LIKE '%Tank%' OR assignment LIKE '%tank%')
        ORDER BY sort_index ASC
        LIMIT 8
      `, [eventId]);
    }
    
    const tankNames = result.rows.map(r => r.character_name).filter(n => n && n.trim());
    console.log(`[TANKS API] Found tanks:`, tankNames);
    res.json({ tanks: tankNames, count: tankNames.length, debug: checkResult.rows });
  } catch (err) {
    console.error('[TANKS API] Error fetching tanks:', err);
    res.status(500).json({ error: err.message, tanks: [] });
  } finally {
    if (client) client.release();
  }
});

// Page route
app.get('/event/:eventId/assignments', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'assignments.html'));
});

// Subpage routes for assignments wings
app.get('/event/:eventId/assignments/:wing', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'assignments.html'));
});

// Non-event scoped assignments routes (used by placeholder and generic links)
app.get('/assignments', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'assignments.html'));
});

app.get('/assignments/:wing', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'assignments.html'));
});

// Channel flags for an event (is_nax, channelId, channelName)
app.get('/api/events/:eventId/channel-flags', async (req, res) => {
  const { eventId } = req.params;
  let client;
  try {
    client = await pool.connect();
    let channelId = null;
    let channelName = null;
    let isNax = false;
    const ev = await client.query(
      `SELECT event_data FROM raid_helper_events_cache WHERE event_id = $1`,
      [eventId]
    );
    if (ev.rows.length > 0) {
      const data = ev.rows[0].event_data || {};
      channelId = data.channelId || data.channelID || data.channel_id || null;
      channelName = data.channelName || null;
    }
    if (channelId) {
      try {
        const cf = await client.query(`SELECT is_nax FROM channel_filters WHERE channel_id = $1`, [channelId]);
        if (cf.rows.length > 0) isNax = !!cf.rows[0].is_nax;
      } catch {}
    }
    // Fallback: try upcoming events cache to resolve channel if missing
    if (!channelId) {
      try {
        const cached = await client.query(
          `SELECT events_data FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()`,
          ['raid_helper_events']
        );
        if (cached.rows.length > 0) {
          const eventsBlob = cached.rows[0].events_data || {};
          const list = Array.isArray(eventsBlob.postedEvents) ? eventsBlob.postedEvents : (Array.isArray(eventsBlob) ? eventsBlob : []);
          const match = list.find(e => String(e.id) === String(eventId));
          if (match) {
            channelId = match.channelId || match.channelID || match.channel_id || null;
            channelName = match.channelName || match.channel_name || channelName;
          }
        }
      } catch {}
      if (channelId && !isNax) {
        try {
          const cf2 = await client.query(`SELECT is_nax FROM channel_filters WHERE channel_id = $1`, [channelId]);
          if (cf2.rows.length > 0) isNax = !!cf2.rows[0].is_nax;
        } catch {}
      }
    }
    // Heuristic fallback when DB flag is unavailable
    if (!isNax && channelName) {
      const lower = String(channelName).toLowerCase();
      if (lower.includes('nax')) isNax = true;
    }
    return res.json({ success: true, eventId, channelId, channelName, isNax });
  } catch (e) {
    console.error('‚ùå [/api/events/:eventId/channel-flags] Error:', e.message);
    return res.json({ success: false, error: 'Failed to load channel flags' });
  } finally {
    if (client) client.release();
  }
});

// Store raidleader name and cut per event (requires management)
app.put('/api/events/:eventId/raidleader', requireRosterManager, express.json(), async (req, res) => {
  const { eventId } = req.params;
  const { raidleaderName, raidleaderCut } = req.body || {};
  if (!eventId) return res.status(400).json({ success:false, message:'Missing eventId' });
  let client;
  try {
    client = await pool.connect();
    await client.query(`
      CREATE TABLE IF NOT EXISTS event_metadata (
        event_id VARCHAR(255) PRIMARY KEY,
        raidleader_name VARCHAR(255),
        raidleader_cut NUMERIC,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    const cutVal = (raidleaderCut == null || raidleaderCut === '') ? null : Number(raidleaderCut);
    await client.query(
      `INSERT INTO event_metadata (event_id, raidleader_name, raidleader_cut, updated_at)
       VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
       ON CONFLICT (event_id)
       DO UPDATE SET raidleader_name = EXCLUDED.raidleader_name, raidleader_cut = EXCLUDED.raidleader_cut, updated_at = CURRENT_TIMESTAMP`,
      [eventId, raidleaderName || null, isNaN(cutVal) ? null : cutVal]
    );
    res.json({ success:true });
  } catch (e) {
    console.error('‚ùå [/api/events/:eventId/raidleader] Error:', e);
    res.status(500).json({ success:false, message:'Failed to save raidleader' });
  } finally {
    if (client) client.release();
  }
});

app.get('/api/events/:eventId/raidleader', async (req, res) => {
  const { eventId } = req.params;
  if (!eventId) return res.status(400).json({ success:false, message:'Missing eventId' });
  let client;
  try {
    client = await pool.connect();
    await client.query(`
      CREATE TABLE IF NOT EXISTS event_metadata (
        event_id VARCHAR(255) PRIMARY KEY,
        raidleader_name VARCHAR(255),
        raidleader_cut NUMERIC,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    const r = await client.query('SELECT raidleader_name, raidleader_cut FROM event_metadata WHERE event_id = $1', [eventId]);
    if (!r.rows.length) return res.json({ success:true, raidleaderName:null, raidleaderCut:null });
    const row = r.rows[0];
    res.json({ success:true, raidleaderName: row.raidleader_name || null, raidleaderCut: row.raidleader_cut != null ? Number(row.raidleader_cut) : null });
  } catch (e) {
    console.error('‚ùå [/api/events/:eventId/raidleader GET] Error:', e);
    res.status(500).json({ success:false, message:'Failed to load raidleader' });
  } finally {
    if (client) client.release();
  }
});

// Management-only endpoint for user data
app.get('/api/management/users', requireManagement, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query('SELECT discord_id, character_name, class FROM players ORDER BY character_name');
    client.release();
    res.json({ 
      message: 'Management access granted',
      users: result.rows 
    });
  } catch (error) {
    console.error('Error fetching users:', error.stack);
    res.status(500).json({ message: 'Error fetching users from the database.' });
  }
});

// Management-only: list app roles (management/helper)
app.get('/api/management/app-roles', requireManagement, async (req, res) => {
  try {
    const { rows } = await pool.query(`
      SELECT r.discord_id, r.role_key, u.username, u.discriminator
      FROM app_user_roles r
      LEFT JOIN discord_users u ON u.discord_id = r.discord_id
      ORDER BY r.role_key, r.discord_id
    `);
    res.json({ ok: true, roles: rows });
  } catch (e) {
    res.status(500).json({ ok: false, error: e && e.message ? e.message : String(e) });
  }
});

// Bootstrap endpoint: If no management users exist, allow the currently logged-in user to become management once
app.post('/api/bootstrap/grant-management-to-self', async (req, res) => {
  try {
    if (!req.isAuthenticated || !req.isAuthenticated()) {
      return res.status(401).json({ ok: false, error: 'Authentication required' });
    }
    const { rows } = await pool.query(`SELECT 1 FROM app_user_roles WHERE role_key = 'management' LIMIT 1`);
    if (rows && rows.length > 0) {
      return res.status(400).json({ ok: false, error: 'Management already exists' });
    }
    await pool.query(`
      INSERT INTO app_user_roles (discord_id, role_key, granted_at, granted_by)
      VALUES ($1, 'management', CURRENT_TIMESTAMP, $2)
      ON CONFLICT (discord_id, role_key) DO NOTHING
    `, [String(req.user.id), String(req.user.id)]);
    return res.json({ ok: true });
  } catch (e) {
    return res.status(500).json({ ok: false, error: e && e.message ? e.message : String(e) });
  }
});

// Management-only: grant a role to a user
app.post('/api/management/app-roles/grant', requireManagement, express.json(), async (req, res) => {
  const { discordId, roleKey } = req.body || {};
  if (!discordId || !roleKey) return res.status(400).json({ ok: false, error: 'discordId and roleKey required' });
  try {
    // Ensure target user exists in discord_users to satisfy FK
    await pool.query(`
      INSERT INTO discord_users (discord_id, created_at, updated_at)
      VALUES ($1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      ON CONFLICT (discord_id) DO NOTHING
    `, [String(discordId)]);

    await pool.query(`
      INSERT INTO app_user_roles (discord_id, role_key, granted_at, granted_by)
      VALUES ($1, $2, CURRENT_TIMESTAMP, $3)
      ON CONFLICT (discord_id, role_key) DO NOTHING
    `, [String(discordId), String(roleKey), String(req.user && req.user.id || '')]);
    try { const c = await pool.connect(); await auditRoleChange(c, 'grant', discordId, roleKey, req.user && req.user.id); c.release(); } catch(_) {}
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ ok: false, error: e && e.message ? e.message : String(e) });
  }
});

// Optional: audit role changes
async function auditRoleChange(client, action, targetDiscordId, roleKey, actorDiscordId) {
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS role_audit (
        id SERIAL PRIMARY KEY,
        action TEXT NOT NULL,
        discord_id TEXT NOT NULL,
        role_key TEXT NOT NULL,
        actor_discord_id TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`);
    await client.query(`INSERT INTO role_audit (action, discord_id, role_key, actor_discord_id) VALUES ($1,$2,$3,$4)`, [action, String(targetDiscordId), String(roleKey), String(actorDiscordId||'')]);
  } catch(_) {}
}

// Management-only: revoke a role from a user
app.post('/api/management/app-roles/revoke', requireManagement, express.json(), async (req, res) => {
  const { discordId, roleKey } = req.body || {};
  if (!discordId || !roleKey) return res.status(400).json({ ok: false, error: 'discordId and roleKey required' });
  try {
    await pool.query(`
      DELETE FROM app_user_roles WHERE discord_id = $1 AND role_key = $2
    `, [String(discordId), String(roleKey)]);
    try { const c = await pool.connect(); await auditRoleChange(c, 'revoke', discordId, roleKey, req.user && req.user.id); c.release(); } catch(_) {}
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ ok: false, error: e && e.message ? e.message : String(e) });
  }
});

// Management-only: update a player row (discord_id, character_name, class)
app.put('/api/management/users', requireManagement, async (req, res) => {
  const { originalDiscordId, originalCharacterName, newDiscordId, newCharacterName, newClass } = req.body || {};

  if (!originalDiscordId || !originalCharacterName) {
    return res.status(400).json({ success: false, message: 'Missing originalDiscordId or originalCharacterName' });
  }
  if (!newDiscordId || !newCharacterName || !newClass) {
    return res.status(400).json({ success: false, message: 'Missing newDiscordId or newCharacterName or newClass' });
  }

  let client;
  try {
    client = await pool.connect();
    await client.query('BEGIN');

    const result = await client.query(
      `UPDATE players
       SET discord_id = $1, character_name = $2, class = $3
       WHERE discord_id = $4 AND character_name = $5`,
      [newDiscordId, newCharacterName, newClass, originalDiscordId, originalCharacterName]
    );

    if (result.rowCount === 0) {
      // If no row to update, respond 404
      await client.query('ROLLBACK');
      return res.status(404).json({ success: false, message: 'Player not found' });
    }

    await client.query('COMMIT');
    res.json({ success: true, message: 'Player updated', player: { discord_id: newDiscordId, character_name: newCharacterName, class: newClass } });
  } catch (error) {
    if (client) await client.query('ROLLBACK');
    // Unique violation when changing PK to an existing one
    if (error && error.code === '23505') {
      return res.status(409).json({ success: false, message: 'A player with that Discord ID and character name already exists.' });
    }
    console.error('Error updating player by management:', error);
    res.status(500).json({ success: false, message: 'Internal Server Error' });
  } finally {
    if (client) client.release();
  }
});

// Management-only: delete a player row
app.delete('/api/management/users', requireManagement, async (req, res) => {
  const { discordId, characterName } = req.body || {};
  if (!discordId || !characterName) {
    return res.status(400).json({ success: false, message: 'Missing discordId or characterName' });
  }

  let client;
  try {
    client = await pool.connect();
    const result = await client.query(
      'DELETE FROM players WHERE discord_id = $1 AND character_name = $2',
      [discordId, characterName]
    );
    if (result.rowCount === 0) {
      return res.status(404).json({ success: false, message: 'Player not found' });
    }
    res.json({ success: true, message: 'Player deleted' });
  } catch (error) {
    console.error('Error deleting player by management:', error);
    res.status(500).json({ success: false, message: 'Internal Server Error' });
  } finally {
    if (client) client.release();
  }
});

// Management-only endpoint for roster statistics
app.get('/api/management/roster-stats', requireManagement, async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(`
      SELECT 
        COUNT(DISTINCT event_id) as managed_events,
        COUNT(*) as total_roster_entries,
        COUNT(DISTINCT discord_user_id) as unique_players
      FROM roster_overrides
    `);
    client.release();
    res.json({ 
      message: 'Management access granted',
      stats: result.rows[0] 
    });
  } catch (error) {
    console.error('Error fetching roster stats:', error.stack);
    res.status(500).json({ message: 'Error fetching roster statistics.' });
  }
});

// Guild import preview endpoint - shows what will be added/removed/updated
app.post('/api/management/guild-import-preview', requireManagement, async (req, res) => {
  try {
    const { importData } = req.body;
    
    if (!importData || typeof importData !== 'string') {
      return res.status(400).json({ message: 'Import data is required' });
    }

    const client = await pool.connect();
    
    // Parse the import data
    const lines = importData.trim().split('\n');
    if (lines.length < 2) {
      client.release();
      return res.status(400).json({ message: 'Invalid import data format' });
    }

    // Skip header line and parse characters
    const importedChars = [];
    for (let i = 1; i < lines.length; i++) {
      const fields = lines[i].split(';');
      if (fields.length >= 17) {
        const level = parseInt(fields[2]);
        if (level === 60) { // Only import level 60 characters
          importedChars.push({
            character_name: fields[0],
            rank_name: fields[1],
            level: level,
            class: fields[3],
            race: fields[4],
            sex: fields[5],
            last_online_days: parseFloat(fields[6]) || null,
            main_alt: fields[7],
            player_alts: fields[8],
            join_date: fields[9],
            promo_date: fields[10],
            rank_history: fields[11],
            birthday: fields[12],
            public_note: fields[13],
            officer_note: fields[14],
            custom_note: fields[15],
            faction: fields[16]
          });
        }
      }
    }

    // Get current guildies from database
    const currentResult = await client.query('SELECT * FROM guildies');
    const currentGuildies = currentResult.rows;

    // Get players for discord ID matching
    const playersResult = await client.query('SELECT discord_id, character_name, class FROM players');
    const playersMap = new Map();
    playersResult.rows.forEach(player => {
      const key = `${player.character_name.toLowerCase()}_${player.class.toLowerCase()}`;
      playersMap.set(key, player.discord_id);
    });

    // Add discord_id to imported chars where possible
    importedChars.forEach(char => {
      const key = `${char.character_name.toLowerCase()}_${char.class.toLowerCase()}`;
      char.discord_id = playersMap.get(key) || null;
    });

    // Determine changes
    const currentCharMap = new Map(currentGuildies.map(char => [char.character_name, char]));
    const importedCharMap = new Map(importedChars.map(char => [char.character_name, char]));

    const toAdd = importedChars.filter(char => !currentCharMap.has(char.character_name));
    const toRemove = currentGuildies.filter(char => !importedCharMap.has(char.character_name));
    const toUpdate = [];

    // Check for updates
    for (const importedChar of importedChars) {
      const currentChar = currentCharMap.get(importedChar.character_name);
      if (currentChar) {
        // Compare relevant fields (excluding timestamps and discord_id changes)
        const hasChanges = (
          currentChar.rank_name !== importedChar.rank_name ||
          currentChar.level !== importedChar.level ||
          currentChar.class !== importedChar.class ||
          currentChar.race !== importedChar.race ||
          currentChar.sex !== importedChar.sex ||
          currentChar.last_online_days !== importedChar.last_online_days ||
          currentChar.main_alt !== importedChar.main_alt ||
          currentChar.player_alts !== importedChar.player_alts ||
          currentChar.join_date !== importedChar.join_date ||
          currentChar.promo_date !== importedChar.promo_date ||
          currentChar.rank_history !== importedChar.rank_history ||
          currentChar.birthday !== importedChar.birthday ||
          currentChar.public_note !== importedChar.public_note ||
          currentChar.officer_note !== importedChar.officer_note ||
          currentChar.custom_note !== importedChar.custom_note ||
          currentChar.faction !== importedChar.faction ||
          currentChar.discord_id !== importedChar.discord_id
        );

        if (hasChanges) {
          toUpdate.push({
            character_name: importedChar.character_name,
            changes: {
              old: currentChar,
              new: importedChar
            }
          });
        }
      }
    }

    client.release();

    res.json({
      success: true,
      summary: {
        totalImported: importedChars.length,
        toAdd: toAdd.length,
        toRemove: toRemove.length,
        toUpdate: toUpdate.length
      },
      changes: {
        toAdd,
        toRemove,
        toUpdate
      }
    });

  } catch (error) {
    console.error('Error previewing guild import:', error.stack);
    console.error('Error details:', error);
    res.status(500).json({ 
      message: 'Error processing guild import preview',
      error: error.message 
    });
  }
});

// Guild import execute endpoint - performs the actual import
app.post('/api/management/guild-import-execute', requireManagement, async (req, res) => {
  try {
    const { importData } = req.body;
    
    if (!importData || typeof importData !== 'string') {
      return res.status(400).json({ message: 'Import data is required' });
    }

    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');

      // Parse the import data (same logic as preview)
      const lines = importData.trim().split('\n');
      if (lines.length < 2) {
        await client.query('ROLLBACK');
        client.release();
        return res.status(400).json({ message: 'Invalid import data format' });
      }

      // Parse characters
      const importedChars = [];
      for (let i = 1; i < lines.length; i++) {
        const fields = lines[i].split(';');
        if (fields.length >= 17) {
          const level = parseInt(fields[2]);
          if (level === 60) {
            importedChars.push({
              character_name: fields[0],
              rank_name: fields[1],
              level: level,
              class: fields[3],
              race: fields[4],
              sex: fields[5],
              last_online_days: parseFloat(fields[6]) || null,
              main_alt: fields[7],
              player_alts: fields[8],
              join_date: fields[9],
              promo_date: fields[10],
              rank_history: fields[11],
              birthday: fields[12],
              public_note: fields[13],
              officer_note: fields[14],
              custom_note: fields[15],
              faction: fields[16]
            });
          }
        }
      }

      // Get players for discord ID matching
      const playersResult = await client.query('SELECT discord_id, character_name, class FROM players');
      const playersMap = new Map();
      playersResult.rows.forEach(player => {
        const key = `${player.character_name.toLowerCase()}_${player.class.toLowerCase()}`;
        playersMap.set(key, player.discord_id);
      });

      // Add discord_id to imported chars
      importedChars.forEach(char => {
        const key = `${char.character_name.toLowerCase()}_${char.class.toLowerCase()}`;
        char.discord_id = playersMap.get(key) || null;
      });

      // Clear existing guildies and insert new ones
      await client.query('DELETE FROM guildies');
      
      // Insert all imported characters
      for (const char of importedChars) {
        await client.query(`
          INSERT INTO guildies (
            character_name, rank_name, level, class, race, sex, last_online_days,
            main_alt, player_alts, join_date, promo_date, rank_history, birthday,
            public_note, officer_note, custom_note, faction, discord_id, updated_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, CURRENT_TIMESTAMP)
          ON CONFLICT (character_name, class) 
          DO UPDATE SET 
            rank_name = EXCLUDED.rank_name,
            level = EXCLUDED.level,
            race = EXCLUDED.race,
            sex = EXCLUDED.sex,
            last_online_days = EXCLUDED.last_online_days,
            main_alt = EXCLUDED.main_alt,
            player_alts = EXCLUDED.player_alts,
            join_date = EXCLUDED.join_date,
            promo_date = EXCLUDED.promo_date,
            rank_history = EXCLUDED.rank_history,
            birthday = EXCLUDED.birthday,
            public_note = EXCLUDED.public_note,
            officer_note = EXCLUDED.officer_note,
            custom_note = EXCLUDED.custom_note,
            faction = EXCLUDED.faction,
            discord_id = EXCLUDED.discord_id,
            updated_at = CURRENT_TIMESTAMP
        `, [
          char.character_name, char.rank_name, char.level, char.class, char.race, char.sex,
          char.last_online_days, char.main_alt, char.player_alts, char.join_date, char.promo_date,
          char.rank_history, char.birthday, char.public_note, char.officer_note, char.custom_note,
          char.faction, char.discord_id
        ]);
      }

      await client.query('COMMIT');
      
      res.json({
        success: true,
        message: `Successfully imported ${importedChars.length} guild members`,
        imported: importedChars.length
      });

    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }

  } catch (error) {
    console.error('Error executing guild import:', error.stack);
    console.error('Error details:', error);
    res.status(500).json({ 
      message: 'Error executing guild import',
      error: error.message 
    });
  }
});

// Get all guild members - public endpoint
app.get('/api/guild-members', async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query(`
      SELECT 
        character_name, 
        class, 
        level, 
        rank_name, 
        race, 
        sex,
        last_online_days,
        join_date,
        discord_id,
        CASE WHEN discord_id IS NOT NULL THEN true ELSE false END as has_discord_link
      FROM guildies 
      ORDER BY rank_name, character_name
    `);
    client.release();
    
    res.json({ 
      success: true,
      members: result.rows,
      count: result.rows.length
    });
  } catch (error) {
    console.error('Error fetching guild members:', error.stack);
    res.status(500).json({ 
      success: false,
      message: 'Error fetching guild members',
      error: error.message 
    });
  }
});

// DEBUG: Endpoint to recreate guildies table with correct structure
app.get('/api/debug/recreate-guildies-table', async (req, res) => {
  try {
    const client = await pool.connect();
    
    // Drop existing table if it exists
    await client.query(`DROP TABLE IF EXISTS guildies CASCADE`);
    
    // Create guildies table with composite primary key
    await client.query(`
      CREATE TABLE guildies (
        character_name VARCHAR(255),
        rank_name VARCHAR(100),
        level INTEGER,
        class VARCHAR(50),
        race VARCHAR(50),
        sex VARCHAR(20),
        last_online_days DECIMAL,
        main_alt VARCHAR(50),
        player_alts TEXT,
        join_date VARCHAR(50),
        promo_date VARCHAR(50),
        rank_history TEXT,
        birthday VARCHAR(50),
        public_note TEXT,
        officer_note TEXT,
        custom_note TEXT,
        faction VARCHAR(20),
        discord_id VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (character_name, class)
      )
    `);
    
    // Create indexes
    await client.query(`CREATE INDEX idx_guildies_discord_id ON guildies (discord_id)`);
    await client.query(`CREATE INDEX idx_guildies_class_name ON guildies (class, character_name)`);
    
    client.release();
    
    res.json({
      success: true,
      message: 'Guildies table recreated successfully with composite primary key (character_name, class)!'
    });
  } catch (error) {
    console.error('Error recreating guildies table:', error);
    res.status(500).json({ 
      error: error.message,
      success: false 
    });
  }
});

// DEBUG: Endpoint to create guildies table if it doesn't exist
app.get('/api/debug/create-guildies-table', async (req, res) => {
  try {
    const client = await pool.connect();
    
    // Create guildies table
    await client.query(`
      CREATE TABLE IF NOT EXISTS guildies (
        character_name VARCHAR(255),
        rank_name VARCHAR(100),
        level INTEGER,
        class VARCHAR(50),
        race VARCHAR(50),
        sex VARCHAR(20),
        last_online_days DECIMAL,
        main_alt VARCHAR(50),
        player_alts TEXT,
        join_date VARCHAR(50),
        promo_date VARCHAR(50),
        rank_history TEXT,
        birthday VARCHAR(50),
        public_note TEXT,
        officer_note TEXT,
        custom_note TEXT,
        faction VARCHAR(20),
        discord_id VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (character_name, class)
      )
    `);
    
    // Create indexes
    await client.query(`CREATE INDEX IF NOT EXISTS idx_guildies_discord_id ON guildies (discord_id)`);
    await client.query(`CREATE INDEX IF NOT EXISTS idx_guildies_class_name ON guildies (class, character_name)`);
    
    client.release();
    
    res.json({
      success: true,
      message: 'Guildies table created successfully!'
    });
  } catch (error) {
    console.error('Error creating guildies table:', error);
    res.status(500).json({ 
      error: error.message,
      success: false 
    });
  }
});

// DEBUG: Endpoint to check guildies table
app.get('/api/debug/check-guildies-table', async (req, res) => {
  try {
    const client = await pool.connect();
    
    // Check if guildies table exists
    const tableExists = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'guildies'
      )
    `);
    
    let tableInfo = null;
    if (tableExists.rows[0].exists) {
      // Get table structure
      tableInfo = await client.query(`
        SELECT column_name, data_type, is_nullable 
        FROM information_schema.columns 
        WHERE table_name = 'guildies'
        ORDER BY ordinal_position
      `);
      
      // Count existing records
      const countResult = await client.query('SELECT COUNT(*) FROM guildies');
      tableInfo.recordCount = countResult.rows[0].count;
    }
    
    client.release();
    
    res.json({
      tableExists: tableExists.rows[0].exists,
      tableInfo: tableInfo ? {
        columns: tableInfo.rows,
        recordCount: tableInfo.recordCount
      } : null
    });
  } catch (error) {
    console.error('Error checking guildies table:', error);
    res.status(500).json({ error: error.message });
  }
});

// DEBUG: Endpoint to clear all caches and check roles
app.get('/api/debug/clear-cache', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Authentication required' });
  }

  try {
    // Clear both caches
    guildRolesCache = null;
    guildRolesCacheTime = 0;
    userMemberCache.clear();
    console.log('üßπ All caches cleared (guild roles + user member data)');

    // Check roles again with fresh data
    const isManagement = await hasManagementRoleById(req.user.id);
    
    res.json({
      message: 'All caches cleared and roles rechecked',
      hasManagementRole: isManagement,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error during cache clear and role check:', error);
    res.status(500).json({ 
      message: 'Error during debug check',
      error: error.message 
    });
  }
});

// DEBUG: Cache status endpoint
app.get('/api/debug/cache-status', (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Authentication required' });
  }

  const now = Date.now();
  const guildCacheAge = guildRolesCache ? Math.floor((now - guildRolesCacheTime) / 1000) : null;
  
  res.json({
    guildRoles: {
      cached: !!guildRolesCache,
      ageSeconds: guildCacheAge,
      roles: guildRolesCache ? guildRolesCache.length : 0
    },
    userMembers: {
      totalCached: userMemberCache.size,
      entries: Array.from(userMemberCache.entries()).map(([key, value]) => ({
        key: key,
        ageSeconds: Math.floor((now - value.timestamp) / 1000),
        roles: value.data.roles.length
      }))
    },
    cacheTtls: {
      userCacheTtlMinutes: USER_CACHE_TTL / (60 * 1000),
      guildCacheTtlMinutes: GUILD_CACHE_TTL / (60 * 1000)
    },
    timestamp: new Date().toISOString()
  });
});

app.get('/db-test', async (req, res) => {
  try {
    const client = await pool.connect();
    const result = await client.query('SELECT NOW() as current_time');
    client.release();

    res.json({
      message: 'Database connection successful!',
      currentTime: result.rows[0].current_time
    });
  } catch (error) {
    console.error('Error executing query:', error.stack);
    res.status(500).json({
        message: 'Error connecting to or querying the database.',
        error: error.message
    });
  }
});

app.get('/api/my-characters', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'User not authenticated.' });
    }

    const discordId = req.user.id;

    try {
        const client = await pool.connect();
        const result = await client.query({
            text: 'SELECT character_name, class FROM players WHERE discord_id = $1 ORDER BY character_name',
            values: [discordId],
        });
        client.release();
        res.json(result.rows);
    } catch (error) {
        console.error('Error fetching user characters:', error.stack);
        res.status(500).json({ message: 'Error fetching characters from the database.' });
    }
});

app.get('/api/players', async (req, res) => {
    try {
        const client = await pool.connect();
        const result = await client.query('SELECT * FROM players ORDER BY character_name');
        client.release();
        res.json(result.rows);
    } catch (error) {
        console.error('Error fetching players:', error.stack);
        res.status(500).json({ message: 'Error fetching players from the database.' });
    }
});

// Update a player's character name in the players table and optionally the current event roster
app.put('/api/players/:discordUserId/fix-name', async (req, res) => {
    const { discordUserId } = req.params;
    const { oldName, newName, characterClass, eventId } = req.body || {};

    if (!newName || !characterClass) {
        return res.status(400).json({ message: 'Missing required fields: newName and characterClass.' });
    }

    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // Gracefully handle rename with composite PK (discord_id, character_name, class)
        const existsNewRes = await client.query(
            `SELECT 1 FROM players 
             WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND LOWER(class) = LOWER($3)`,
            [discordUserId, newName, characterClass]
        );
        const existsOldRes = oldName ? await client.query(
            `SELECT 1 FROM players 
             WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND LOWER(class) = LOWER($3)`,
            [discordUserId, oldName, characterClass]
        ) : { rows: [] };

        const existsNew = existsNewRes.rows.length > 0;
        const existsOld = existsOldRes.rows.length > 0;

        if (existsNew) {
            // New row already exists for this class/name; delete old if present
            if (existsOld && oldName && oldName.toLowerCase() !== newName.toLowerCase()) {
                await client.query(
                    `DELETE FROM players WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND LOWER(class) = LOWER($3)`,
                    [discordUserId, oldName, characterClass]
                );
            }
        } else if (existsOld) {
            // Safe to rename old -> new (no conflict)
            await client.query(
                `UPDATE players 
                 SET character_name = $1 
                 WHERE discord_id = $2 AND LOWER(character_name) = LOWER($3) AND LOWER(class) = LOWER($4)`,
                [newName, discordUserId, oldName, characterClass]
            );
        } else {
            // Neither exists; ensure a row with the new name exists
            await client.query(
                `INSERT INTO players (discord_id, character_name, class)
                 VALUES ($1, $2, $3)
                 ON CONFLICT DO NOTHING`,
                [discordUserId, newName, characterClass]
            );
        }

        // If this request is coming from a specific event context, update roster override name only
        if (eventId) {
            await client.query(
                `UPDATE roster_overrides 
                 SET assigned_char_name = $1 
                 WHERE event_id = $2 AND discord_user_id = $3`,
                [newName, eventId, discordUserId]
            );
        }

        await client.query('COMMIT');
        res.json({ success: true, message: 'Player name updated successfully.', newName });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error fixing player name:', error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// Search players by name (minimum 3 characters)
app.get('/api/players/search', async (req, res) => {
    const { q } = req.query;
    
    if (!q || q.length < 3) {
        return res.json([]);
    }
    
    try {
        const client = await pool.connect();
        const result = await client.query(
            `SELECT discord_id, character_name, class 
             FROM players 
             WHERE LOWER(character_name) LIKE LOWER($1) 
             AND discord_id IS NOT NULL AND discord_id != ''
             ORDER BY character_name 
             LIMIT 10`,
            [`%${q}%`]
        );
        client.release();
        res.json(result.rows);
    } catch (error) {
        console.error('Error searching players:', error.stack);
        res.status(500).json({ message: 'Error searching players from the database.' });
    }
});

// New endpoint to get registered character for a Discord user ID
app.get('/api/registered-character/:discordUserId', async (req, res) => {
    const { discordUserId } = req.params;
    let client;
    
    try {
        client = await pool.connect();
        
        // Get the first registered character for this Discord user (their main character)
        const result = await client.query(
            'SELECT character_name, class FROM players WHERE discord_id = $1 ORDER BY character_name LIMIT 1',
            [discordUserId]
        );
        
        if (result.rows.length === 0) {
            return res.status(404).json({ message: 'No registered character found for this Discord user.' });
        }
        
        const character = result.rows[0];
        res.json({
            characterName: character.character_name,
            characterClass: character.class
        });
        
    } catch (error) {
        console.error('Error fetching registered character:', error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// Get all characters for a Discord user ID (for unmatched roster players display)
app.get('/api/players/by-discord-id/:discordUserId', async (req, res) => {
    const { discordUserId } = req.params;
    let client;
    
    try {
        client = await pool.connect();
        
        // Get all characters for this Discord user
        const result = await client.query(
            'SELECT character_name, class FROM players WHERE discord_id = $1 ORDER BY character_name',
            [discordUserId]
        );
        
        res.json({
            success: true,
            discordId: discordUserId,
            characters: result.rows
        });
        
    } catch (error) {
        console.error('Error fetching characters by Discord ID:', error);
        res.status(500).json({ 
            success: false,
            message: 'Error fetching characters',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// UPDATED: Cached endpoint to fetch upcoming Raid-Helper events
app.get('/api/events', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
  }

  try {
    // Try to get cached events first
    let cachedEvents = await getCachedEvents();
    
    if (!cachedEvents) {
      // No cached data, fetch fresh data
      console.log('üîÑ Cache miss - fetching fresh events data and enriching with channel names');
      const events = await fetchEventsFromAPI();
      console.log(`üì° Fetched ${events.length} raw events from API`);
      const enrichedEvents = await enrichEventsWithDiscordChannelNames(events);
      console.log(`‚úÖ Enriched ${enrichedEvents.length} events with Discord channel names`);
      
      // Cache the enriched events
      await setCachedEvents(enrichedEvents);
      cachedEvents = enrichedEvents;
    } else {
      console.log('üíæ Using cached events data - no enrichment needed');
    }
    
    // Apply channel filters to the events
    const channelFilters = await getChannelFilterSettings();
    
    // Filter out events from hidden channels
    const filteredEvents = cachedEvents.filter(event => {
      // If no channel ID, show the event (default)
      if (!event.channelId) return true;
      
      // If channel has filter setting, use it; otherwise default to visible (true)
      const isVisible = channelFilters.has(event.channelId) 
        ? channelFilters.get(event.channelId) 
        : true;
      
      return isVisible;
    });
    
    console.log(`üì° Filtered events: ${cachedEvents.length} total ‚Üí ${filteredEvents.length} visible`);
    
    res.json({ scheduledEvents: filteredEvents });
    
  } catch (error) {
    console.error('Error in /api/events:', error.response ? error.response.data : error.message);
    if (error.response) {
      console.error('Raid-Helper API Error Response Details (Non-200):', {
          status: error.response.status,
          headers: error.response.headers,
          data: error.response.data
      });
    }
    res.status(error.response ? error.response.status : 500).json({
      message: 'Failed to fetch events from Raid-Helper.',
      error: error.response ? (error.response.data || error.message) : error.message
    });
  }
});

// Manual refresh endpoint for events cache
app.post('/api/events/refresh', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord to refresh events.' });
  }

  try {
    console.log('üîÑ Manual refresh requested - fetching fresh events data');
    
    // Fetch fresh data from API
    const events = await fetchEventsFromAPI();
    const enrichedEvents = await enrichEventsWithDiscordChannelNames(events);
    
    // Update the cache with fresh data
    await setCachedEvents(enrichedEvents);
    
    console.log(`üîç [REFRESH DEBUG] About to apply filtering to ${enrichedEvents.length} events`);
    
    // Apply channel filters to the events (same as /api/events endpoint)
    const channelFilters = await getChannelFilterSettings();
    console.log(`üîç [REFRESH DEBUG] Channel filters loaded: ${channelFilters.size} rules`);
    
    // Filter out events from hidden channels
    const filteredEvents = enrichedEvents.filter(event => {
      // If no channel ID, show the event (default)
      if (!event.channelId) return true;
      
      // If channel has filter setting, use it; otherwise default to visible (true)
      const isVisible = channelFilters.has(event.channelId) 
        ? channelFilters.get(event.channelId) 
        : true;
      
      return isVisible;
    });
    
    console.log(`üì° Filtered events: ${enrichedEvents.length} total ‚Üí ${filteredEvents.length} visible`);
    console.log('‚úÖ Events cache refreshed successfully');
    
    res.json({ 
      message: 'Events refreshed successfully',
      scheduledEvents: filteredEvents 
    });
    
  } catch (error) {
    console.error('Error refreshing events cache:', error.response ? error.response.data : error.message);
    res.status(error.response ? error.response.status : 500).json({
      message: 'Failed to refresh events.',
      error: error.response ? (error.response.data || error.message) : error.message
    });
  }
});

// COMPLETED EVENTS API ENDPOINTS  
// Cached endpoint to fetch completed Raid-Helper events (last year)
app.get('/api/events/historic', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
  }

  try {
    // Try to get cached historic events first
    let cachedEvents = await getCachedHistoricEvents();
    
    if (!cachedEvents) {
      // No cached data, fetch fresh data
      console.log('üîÑ Cache miss - fetching fresh historic events data and enriching with channel names');
      const events = await fetchHistoricEventsFromAPI();
      console.log(`üì° Fetched ${events.length} raw historic events from API`);
      const enrichedEvents = await enrichHistoricEventsWithDiscordChannelNames(events);
      console.log(`‚úÖ Enriched ${enrichedEvents.length} historic events with Discord channel names`);
      
      // Cache the enriched events
      await setCachedHistoricEvents(enrichedEvents);
      cachedEvents = enrichedEvents;
    } else {
      console.log('üíæ Using cached historic events data - no enrichment needed');
    }
    
    // Apply channel filters to the historic events
    const channelFilters = await getChannelFilterSettings();
    
    // Filter out events from hidden channels
    const filteredEvents = cachedEvents.filter(event => {
      // Get the channel ID - try multiple possible property names
      const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
      
      // If no channel ID, show the event (default)
      if (!channelId) return true;
      
      // If channel has filter setting, use it; otherwise default to visible (true)
      const isVisible = channelFilters.has(channelId) 
        ? channelFilters.get(channelId) 
        : true;
      
      return isVisible;
    });
    
    console.log(`üì° Filtered historic events: ${cachedEvents.length} total ‚Üí ${filteredEvents.length} visible`);
    
    // Channel filtering should now work with Discord API channel names
    console.log(`üéØ Channel filtering: ${cachedEvents.length} total ‚Üí ${filteredEvents.length} visible events`);
    
    res.json({ scheduledEvents: filteredEvents });
    
  } catch (error) {
    console.error('Error in /api/events/historic:', error.response ? error.response.data : error.message);
    if (error.response) {
      console.error('Raid-Helper API Error Response Details (Non-200):', {
          status: error.response.status,
          headers: error.response.headers,
          data: error.response.data
      });
    }
    res.status(error.response ? error.response.status : 500).json({
              message: 'Failed to fetch completed events from Raid-Helper.',
      error: error.response ? (error.response.data || error.message) : error.message
    });
  }
});

// Manual refresh endpoint for completed events cache
app.post('/api/events/historic/refresh', async (req, res) => {
  if (!req.isAuthenticated()) {
            return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord to refresh completed events.' });
  }

  try {
    console.log('üîÑ Manual refresh requested - fetching fresh historic events data');
    
    // Fetch fresh data from API
    const events = await fetchHistoricEventsFromAPI();
    const enrichedEvents = await enrichHistoricEventsWithDiscordChannelNames(events);
    
    // Update the cache with fresh data
    await setCachedHistoricEvents(enrichedEvents);
    
    console.log('‚úÖ Historic events cache refreshed successfully');
    
    // Apply channel filters to the refreshed historic events (same as GET endpoint)
    const channelFilters = await getChannelFilterSettings();
    const filteredEvents = enrichedEvents.filter(event => {
      // Get the channel ID - try multiple possible property names
      const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
      
      // If no channel ID, show the event (default)
      if (!channelId) return true;
      
      // If channel has filter setting, use it; otherwise default to visible (true)
      const isVisible = channelFilters.has(channelId) 
        ? channelFilters.get(channelId) 
        : true;
      
      return isVisible;
    });
    
    console.log(`üì° Filtered refreshed historic events: ${enrichedEvents.length} total ‚Üí ${filteredEvents.length} visible`);
    
    res.json({ 
              message: 'Completed events refreshed successfully',
      scheduledEvents: filteredEvents 
    });
    
  } catch (error) {
    console.error('Error refreshing historic events cache:', error.response ? error.response.data : error.message);
    res.status(error.response ? error.response.status : 500).json({
      message: 'Failed to refresh historic events.',
      error: error.response ? (error.response.data || error.message) : error.message
    });
  }
});

// Completed events (24 months) API endpoint
app.get('/api/events/historic-24m', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
  }

  try {
    let cachedEvents = await getCachedHistoricEvents24m();
    if (!cachedEvents) {
      console.log('üîÑ Cache miss - fetching fresh 24-month historic events data and enriching with channel names');
      const events = await fetchHistoricEventsFromAPIWithinMonths(24);
      const enriched = await enrichHistoricEventsWithDiscordChannelNamesWithinMonths(events, 24);
      await setCachedHistoricEvents24m(enriched);
      cachedEvents = enriched;
    } else {
      console.log('üíæ Using cached 24-month historic events data');
    }

    // Apply channel filters
    const channelFilters = await getChannelFilterSettings();
    const filteredEvents = cachedEvents.filter(event => {
      const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
      if (!channelId) return true;
      const isVisible = channelFilters.has(channelId) ? channelFilters.get(channelId) : true;
      return isVisible;
    });

    res.json({ scheduledEvents: filteredEvents });
  } catch (error) {
    console.error('Error in /api/events/historic-24m:', error.response ? error.response.data : error.message);
    res.status(error.response ? error.response.status : 500).json({
      message: 'Failed to fetch 24-month completed events from Raid-Helper.',
      error: error.response ? (error.response.data || error.message) : error.message
    });
  }
});

// Manual refresh 24 months
app.post('/api/events/historic-24m/refresh', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord to refresh completed events.' });
  }

  try {
    console.log('üîÑ Manual refresh requested - fetching fresh 24-month historic events data');
    const events = await fetchHistoricEventsFromAPIWithinMonths(24);
    const enriched = await enrichHistoricEventsWithDiscordChannelNamesWithinMonths(events, 24);
    await setCachedHistoricEvents24m(enriched);

    const channelFilters = await getChannelFilterSettings();
    const filteredEvents = enriched.filter(event => {
      const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
      if (!channelId) return true;
      const isVisible = channelFilters.has(channelId) ? channelFilters.get(channelId) : true;
      return isVisible;
    });

    res.json({ message: 'Completed events (24m) refreshed successfully', scheduledEvents: filteredEvents });
  } catch (error) {
    console.error('Error refreshing 24-month historic events cache:', error.response ? error.response.data : error.message);
    res.status(error.response ? error.response.status : 500).json({
      message: 'Failed to refresh 24-month historic events.',
      error: error.response ? (error.response.data || error.message) : error.message
    });
  }
});

// RPB Google Apps Script Proxy Endpoint
app.post('/api/logs/rpb', async (req, res) => {
  try {
    const { action, logUrl } = req.body;
    
    if (!action) {
      return res.status(400).json({ 
        success: false, 
        error: 'Action is required' 
      });
    }

    // Google Apps Script Web App URL
    const rpbWebAppUrl = 'https://script.google.com/macros/s/AKfycbyilOtCQnVteduqKoRPSE0VNAne9tVPkQezaePajGMUiAiMNKmpn0flIdNBgL8tx5Eo/exec';
    
    // Prepare request data
    const requestData = { action };
    if (logUrl) {
      requestData.logUrl = logUrl;
    }

    console.log(`üîÑ RPB ${action} request:`, requestData);
    
    // Ensure clearF11 action is allowed
    const allowedActions = ['startRPB', 'checkStatus', 'clearF11', 'archiveRPB'];
    if (!allowedActions.includes(action)) {
      return res.status(400).json({
        success: false,
        error: `Invalid action '${action}'. Must be one of: ${allowedActions.join(', ')}`
      });
    }

    // Make request to Google Apps Script
    const response = await axios({
      method: 'POST',
      url: rpbWebAppUrl,
      headers: {
        'Content-Type': 'application/json',
      },
      data: requestData,
      timeout: action === 'startRPB' ? 400000 : 30000, // 6.5 min for startRPB, 30s for status checks
    });

    console.log(`‚úÖ RPB ${action} response:`, response.data);

    // Return the response from Google Apps Script
    res.json(response.data);

  } catch (error) {
    console.error('‚ùå RPB proxy error:', error);
    
    if (error.code === 'ECONNABORTED') {
      return res.status(408).json({
        success: false,
        error: 'RPB processing timed out. Please try again.'
      });
    }

    if (error.response) {
      // Google Apps Script returned an error
      return res.status(error.response.status).json({
        success: false,
        error: error.response.data || 'Google Apps Script error'
      });
    }

    // Network or other error
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to communicate with RPB service'
    });
  }
});

// World Buffs Google Apps Script Proxy Endpoint
app.post('/api/logs/world-buffs', async (req, res) => {
  try {
    const { action, logUrl } = req.body;
    
    if (!action) {
      return res.status(400).json({ 
        success: false, 
        error: 'Action is required' 
      });
    }

    // Google Apps Script Web App URL for World Buffs
    const worldBuffsWebAppUrl = 'https://script.google.com/macros/s/AKfycbzQsvkeJ_CCrEHgRM4COkR5uF9b7SFQ1aIKSCG3SkWLEsu8C37Z0e1UJGNUqp54piTb5A/exec';
    
    // Prepare request data
    const requestData = { action };
    if (logUrl) {
      requestData.logUrl = logUrl;
    }

    console.log(`üåç World Buffs ${action} request:`, requestData);
    
    // Allowed actions for World Buffs
    const allowedActions = ['populateWorldBuffs', 'checkStatus', 'clearStatus'];
    if (!allowedActions.includes(action)) {
      return res.status(400).json({
        success: false,
        error: `Invalid action '${action}'. Must be one of: ${allowedActions.join(', ')}`
      });
    }

    // Make request to Google Apps Script
    const response = await axios({
      method: 'POST',
      url: worldBuffsWebAppUrl,
      headers: {
        'Content-Type': 'application/json',
      },
      data: requestData,
      timeout: action === 'populateWorldBuffs' ? 120000 : 30000, // 2 min for populate, 30s for status checks
    });

    console.log(`‚úÖ World Buffs ${action} response:`, response.data);

    // Return the response from Google Apps Script
    res.json(response.data);

  } catch (error) {
    console.error('‚ùå World Buffs proxy error:', error);
    
    if (error.code === 'ECONNABORTED') {
      return res.status(408).json({
        success: false,
        error: 'World Buffs processing timed out. Please try again.'
      });
    }

    if (error.response) {
      // Google Apps Script returned an error
      return res.status(error.response.status).json({
        success: false,
        error: error.response.data || 'Google Apps Script error'
      });
    }

    // Network or other error
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to communicate with World Buffs service'
    });
  }
});

// CLA Backup Google Apps Script Proxy Endpoint
app.post('/api/logs/cla-backup', async (req, res) => {
  try {
    const { action } = req.body;
    
    if (!action) {
      return res.status(400).json({ 
        success: false, 
        error: 'Action is required' 
      });
    }

    // World Buffs backup - calls the World Buffs spreadsheet (with updated backup code)
    const claBackupWebAppUrl = 'https://script.google.com/macros/s/AKfycbzQsvkeJ_CCrEHgRM4COkR5uF9b7SFQ1aIKSCG3SkWLEsu8C37Z0e1UJGNUqp54piTb5A/exec';
    
    // Prepare request data
    const requestData = { action };

    console.log(`üóÑÔ∏è CLA Backup ${action} request:`, requestData);
    
    // Allowed actions for CLA Backup
    const allowedActions = ['createClaBackup', 'createClaBackupWebApp', 'createClaBackupWithCheck'];
    if (!allowedActions.includes(action)) {
      return res.status(400).json({
        success: false,
        error: `Invalid action '${action}'. Must be one of: ${allowedActions.join(', ')}`
      });
    }

    // Make request to Google Apps Script
    const response = await axios({
      method: 'POST',
      url: claBackupWebAppUrl,
      headers: {
        'Content-Type': 'application/json',
      },
      data: requestData,
      timeout: 60000, // 1 minute timeout for backup creation
    });

    console.log(`‚úÖ CLA Backup ${action} response:`, response.data);

    // Return the response from Google Apps Script
    res.json(response.data);

  } catch (error) {
    console.error('‚ùå CLA Backup proxy error:', error);
    
    if (error.code === 'ECONNABORTED') {
      return res.status(408).json({
        success: false,
        error: 'CLA Backup creation timed out. Please try again.'
      });
    }

    if (error.response) {
      // Google Apps Script returned an error
      return res.status(error.response.status).json({
        success: false,
        error: error.response.data || 'Google Apps Script error'
      });
    }

    // Network or other error
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to communicate with CLA Backup service'
    });
  }
});

// Frost Resistance Google Apps Script Proxy Endpoint
app.post('/api/logs/frost-res', async (req, res) => {
  try {
    const { action, logUrl } = req.body;
    
    if (!action) {
      return res.status(400).json({ 
        success: false, 
        error: 'Action is required' 
      });
    }

    // Frost Resistance backup - calls the Frost Resistance spreadsheet (with updated backup code)
    const frostResWebAppUrl = 'https://script.google.com/macros/s/AKfycbz4Zp2dA4gED4qFAbBcPOqYTBfQbWP0znPULUgo-thTe41yh2KXIIl8dvbBjA9o5p45RQ/exec';
    
    // Prepare request data
    const requestData = { action };
    if (logUrl) {
      requestData.logUrl = logUrl;
    }

    console.log(`üßä Frost Res ${action} request:`, requestData);
    
    // Allowed actions for Frost Resistance
    const allowedActions = ['populateFrostRes', 'checkStatus', 'clearStatus', 'createClaBackup', 'createClaBackupWebApp', 'createClaBackupWithCheck'];
    if (!allowedActions.includes(action)) {
      return res.status(400).json({
        success: false,
        error: `Invalid action '${action}'. Must be one of: ${allowedActions.join(', ')}`
      });
    }

    // Make request to Google Apps Script
    const response = await axios({
      method: 'POST',
      url: frostResWebAppUrl,
      headers: {
        'Content-Type': 'application/json',
      },
      data: requestData,
      timeout: action === 'populateFrostRes' ? 120000 : 60000, // 2 min for populate, 1 min for backup/status
    });

    console.log(`‚úÖ Frost Res ${action} response:`, response.data);

    // Return the response from Google Apps Script
    res.json(response.data);

  } catch (error) {
    console.error('‚ùå Frost Res proxy error:', error);
    
    if (error.code === 'ECONNABORTED') {
      return res.status(408).json({
        success: false,
        error: 'Frost Resistance processing timed out. Please try again.'
      });
    }

    if (error.response) {
      // Google Apps Script returned an error
      return res.status(error.response.status).json({
        success: false,
        error: error.response.data || 'Google Apps Script error'
      });
    }

    // Network or other error
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to communicate with Frost Resistance service'
    });
  }
});

// A helper function to normalize class names to their canonical form
const CLASS_COLORS = {
    'death knight': '196, 31, 59',
    'druid': '255, 125, 10',
    'hunter': '171, 212, 115',
    'mage': '63, 199, 235',
    'paladin': '245, 140, 186',
    'priest': '255, 255, 255',
    'rogue': '255, 245, 105',
    'shaman': '0, 112, 222',
    'warlock': '135, 135, 237',
    'warrior': '199, 156, 110',
    'unknown': '128, 128, 128',
};

const CLASS_ICONS = {
    'warrior': '579532030153588739',
    'paladin': '579532029906124840', // Corrected Paladin Icon
    'hunter': '579532029880827924',
    'rogue': '579532030086217748',
    'priest': '579532029901799437',
    'shaman': '579532030056857600',
    'mage': '579532030161977355',
    'warlock': '579532029851336716',
    'druid': '579532029675438081',
};

const SPEC_DATA = {
    'warrior': [
        { name: 'Arms', emote: '637564445031399474' }, { name: 'Fury', emote: '637564445215948810' }, { name: 'Protection', emote: '637564444834136065' }
    ],
    'hunter': [
        { name: 'Beast Mastery', emote: '637564202021814277' }, { name: 'Marksmanship', emote: '637564202084466708' }, { name: 'Survival', emote: '637564202130866186' }
    ],
    'mage': [
        { name: 'Arcane', emote: '637564231545389056' }, { name: 'Fire', emote: '637564231239073802' }, { name: 'Frost', emote: '637564231469891594' }
    ],
    'paladin': [
        { name: 'Holy', emote: '637564297622454272' }, { name: 'Protection', emote: '637564297647489034' }, { name: 'Retribution', emote: '637564297953673216' }
    ],
    'priest': [
        { name: 'Discipline', emote: '637564323442720768' }, { name: 'Holy', emote: '637564323530539019' }, { name: 'Shadow', emote: '637564323291725825' }
    ],
    'rogue': [
        { name: 'Assassination', emote: '637564351707873324' }, { name: 'Combat', emote: '637564352333086720' }, { name: 'Subtlety', emote: '637564352169508892' }
    ],
    'shaman': [
        { name: 'Restoration', emote: '637564379847458846' }, { name: 'Enhancement', emote: '637564379772223489' }, { name: 'Elemental', emote: '637564379595931649' }
    ],
    'warlock': [
        { name: 'Affliction', emote: '637564406984867861' }, { name: 'Demonology', emote: '637564407001513984' }, { name: 'Destruction', emote: '637564406682877964' }
    ],
    'druid': [
        { name: 'Feral', emote: '637564172061900820' }, { name: 'Balance', emote: '637564171994529798' }, { name: 'Restoration', emote: '637564172007112723' }, { name: 'Bear', emote: '637564171696734209' }
    ]
};

const getCanonicalClass = (className) => {
    if (!className) return 'unknown';
    const lower = className.toLowerCase();

    // Handle common role names from Raid Helper and map them to a default class
    if (lower === 'tank') return 'warrior';
    
    // Handle class names
    if (lower.includes('death knight')) return 'death knight';
    if (lower.includes('druid')) return 'druid';
    if (lower.includes('hunter')) return 'hunter';
    if (lower.includes('mage')) return 'mage';
    if (lower.includes('pala')) return 'paladin';
    if (lower.includes('priest')) return 'priest';
    if (lower.includes('rogue')) return 'rogue';
    if (lower.includes('shaman')) return 'shaman';
    if (lower.includes('warlock')) return 'warlock';
    if (lower.includes('warrior')) return 'warrior';
    return 'unknown';
};

// Refactored helper to ONLY get data from the Raid Helper API
async function getRosterDataFromApi(eventId) {
    try {
        const rosterResponse = await axios.get(`https://raid-helper.dev/api/raidplan/${eventId}`, {
            timeout: 10000, // 10 second timeout
            headers: {
                'User-Agent': 'Classic-WoW-Manager/1.0'
            }
        });
        if (!rosterResponse.data || !rosterResponse.data.raidDrop) {
            throw new Error('Roster data not found or is invalid from Raid Helper API.');
        }
        return rosterResponse.data;
    } catch (error) {
        console.error(`Failed to fetch roster data from Raid Helper API for event ${eventId}:`, error.message);
        
        // Return a minimal roster structure for managed rosters to work
        return {
            raidDrop: [],
            partyPerRaid: 8,
            slotPerParty: 5,
            partyNames: ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5', 'Group 6', 'Group 7', 'Group 8'],
            title: `Event ${eventId} (Offline Mode)`
        };
    }
}

// This function takes an array of player objects and enriches them
// with main character names and alt characters from the database.
async function enrichPlayersWithDbData(players, client) {
    if (!players || !Array.isArray(players) || players.length === 0) {
        return [];
    }

    // 1. Separate actual player objects from nulls
    const playerObjects = players.filter(p => p && p.userid);
    
    // 2. If no actual players, no need to query DB
    if (playerObjects.length === 0) {
        return players; // Return the original array (e.g., [null, null] for empty slots)
    }
    
    // 3. Get all characters for the found discord IDs
    const discordIds = [...new Set(playerObjects.map(p => p.userid))];
    const dbResult = await client.query('SELECT discord_id, character_name, class FROM players WHERE discord_id = ANY($1::text[])', [discordIds]);
    const allPlayerChars = {};
    dbResult.rows.forEach(row => {
        if (!allPlayerChars[row.discord_id]) allPlayerChars[row.discord_id] = [];
        allPlayerChars[row.discord_id].push(row);
    });

    // 4. Create a map of enriched players for easy lookup
    const enrichedPlayersMap = new Map();
    playerObjects.forEach(player => {
        const userChars = allPlayerChars[player.userid] || [];
        let mainChar = userChars.find(c => c.character_name === player.name) || userChars[0];
        
        // Detect if there's a class/spec mismatch indicating API data is newer than DB data
        let mainCharacterClass = player.class; // Start with API class
        let mainCharacterName = player.name; // Start with API name
        
        // Only use DB data if there's a clear match and no obvious mismatch
        if (mainChar && mainChar.class) {
            const apiCanonicalClass = getCanonicalClass(player.class);
            const dbCanonicalClass = getCanonicalClass(mainChar.class);
            
            // If classes match or player has no specific spec, use DB data
            if (apiCanonicalClass === dbCanonicalClass || !player.spec_emote) {
                mainCharacterClass = mainChar.class;
                mainCharacterName = mainChar.character_name;
            } else {
                // There's a mismatch - try to find a better character name for the spec
                // Look for characters in the database that match the API class
                const matchingChar = userChars.find(c => getCanonicalClass(c.class) === apiCanonicalClass);
                if (matchingChar) {
                    mainCharacterName = matchingChar.character_name;
                    try {
                        // Deduplicate noisy logs unless explicitly enabled
                        if (process.env.DEBUG_NAME_CORRECTION === '1') {
                            console.log(`üîÑ Name correction: ${player.name} -> ${matchingChar.character_name} (class mismatch detected)`);
                        }
                    } catch {}
                }
            }
        }

        const alts = userChars
            .filter(char => char && char.character_name !== mainCharacterName)
            .map(alt => {
                const canonicalClass = getCanonicalClass(alt.class);
                return {
                    name: alt.character_name,
                    class: alt.class,
                    color: CLASS_COLORS[canonicalClass],
                    icon: CLASS_ICONS[canonicalClass]
                };
            });
        
        // ALWAYS calculate color based on the definitive canonical class.
        const canonicalClass = getCanonicalClass(mainCharacterClass);
        const playerColor = CLASS_COLORS[canonicalClass] || CLASS_COLORS['unknown'];

        enrichedPlayersMap.set(player.userid, {
            ...player,
            mainCharacterName,
            altCharacters: alts,
            class: mainCharacterClass,
            color: playerColor // Use the recalculated, correct color.
        });
    });

    // 5. Rebuild the original array, substituting enriched players and preserving nulls
    return players.map(p => {
        if (!p || !p.userid) return null; // If it was null or a bad player object, return null
        return enrichedPlayersMap.get(p.userid) || p; // Get the enriched version, or the original if lookup fails
    });
}

// This function is now a simple wrapper around enrichPlayersWithDbData
async function enrichRosterWithDbData(rosterData, client) {
    if (!rosterData || !rosterData.raidDrop) {
        return rosterData;
    }
    const enrichedPlayers = await enrichPlayersWithDbData(rosterData.raidDrop, client);
    return { ...rosterData, raidDrop: enrichedPlayers };
}

// Helper to "fork" a roster from the API into the DB if it's not already managed
async function forkRosterIfNeeded(eventId, client) {
    const checkResult = await client.query('SELECT event_id FROM roster_overrides WHERE event_id = $1 LIMIT 1', [eventId]);
    if (checkResult.rows.length > 0) {
        return; // Already forked
    }

    console.log(`Forking roster for event ${eventId}...`);
    const rosterDataFromApi = await getRosterDataFromApi(eventId);
    const enrichedRoster = await enrichRosterWithDbData(rosterDataFromApi, client);

    const insertPromises = enrichedRoster.raidDrop.map(player => {
        if (!player || !player.userid) return null; // Skip empty slots or players without IDs
        const query = `
            INSERT INTO roster_overrides 
            (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, player_color, party_id, slot_id) 
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        `;
        const values = [
            eventId,
            player.userid,
            player.name, // original_signup_name
            player.mainCharacterName,
            player.class,
            player.spec,
            player.spec_emote,
            player.color,
            player.partyId,
            player.slotId
        ];
        return client.query(query, values);
    }).filter(Boolean);

    await Promise.all(insertPromises);
    console.log(`Roster for event ${eventId} successfully forked.`);
}

// Helper to get a single player's full data, ready for insertion into overrides
async function getPlayerForInsert(eventId, discordUserId, client) {
    const fullEventData = await getFullEventDataFromApi(eventId);
    const signup = fullEventData.signUps.find(s => s.userId === discordUserId);
    if (!signup) throw new Error(`Player with Discord ID ${discordUserId} not found in signups for event ${eventId}.`);

    const playerToEnrich = [{
        userid: signup.userId,
        name: signup.name,
        class: signup.className,
        spec: signup.specName,
        spec_emote: signup.specEmoteId || signup.classEmoteId,
        color: null, // Let enrichPlayersWithDbData determine the correct color
    }];
    
    const [enrichedPlayer] = await enrichPlayersWithDbData(playerToEnrich, client);
    return enrichedPlayer;
}

async function getFullEventDataFromApi(eventId) {
    try {
        const response = await axios.get(`https://raid-helper.dev/api/v2/events/${eventId}`, {
            timeout: 10000, // 10 second timeout
            headers: { 
                'Authorization': process.env.RAID_HELPER_API_KEY,
                'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
            }
        });
        // More robust check: The v2 endpoint returns an object with a 'signUps' array.
        if (!response.data || typeof response.data !== 'object' || !Array.isArray(response.data.signUps)) {
            console.error('[DETAILED LOG] Unexpected API response structure:', response.data);
            throw new Error('Full event data not found or is invalid from Raid Helper API v2.');
        }
        return response.data;
    } catch (error) {
        console.error(`Failed to fetch full event data from Raid Helper API for event ${eventId}:`, error.message);
        
        // Return minimal event data structure for offline mode
        return {
            signUps: []
        };
    }
}


app.get('/api/roster/:eventId', async (req, res) => {
    const { eventId } = req.params;
    let client;
    try {
        client = await pool.connect();
        let rosterData;
        const managedRosterResult = await client.query('SELECT * FROM roster_overrides WHERE event_id = $1', [eventId]);



        const rosterDataFromApi = await getRosterDataFromApi(eventId);
        if (managedRosterResult.rows.length > 0) {
            // Roster IS managed. Reconstruct it from overrides and full signup data.
            const fullEventData = await getFullEventDataFromApi(eventId);

            // Enrich all signed-up players at once for efficiency
            const allSignedUpPlayers = fullEventData.signUps.map(signup => ({
                userid: signup.userId,
                name: signup.name,
                class: signup.className,
                spec: signup.specName,
                spec_emote: signup.specEmoteId || signup.classEmoteId,
                status: signup.status,
            }));
            const enrichedAllPlayers = await enrichPlayersWithDbData(allSignedUpPlayers, client);
            const enrichedPlayersMap = new Map(enrichedAllPlayers.map(p => [p.userid, p]));

            const finalRosterPlayers = [];
            const playersInRosterOverrides = new Set();

            managedRosterResult.rows.forEach(override => {
                if (override.party_id !== null) { // Only add players assigned to a party to the roster
                    const basePlayer = enrichedPlayersMap.get(override.discord_user_id);
                    
                    if (basePlayer) {
                        // Player exists in original signups - use enriched data
                        // Find the original roster position to get isConfirmed status
                        const originalRosterPlayer = rosterDataFromApi.raidDrop?.find(p => p?.userid === override.discord_user_id);
                        finalRosterPlayers.push({
                            ...basePlayer,
                            mainCharacterName: override.assigned_char_name,
                            class: override.assigned_char_class,
                            spec: override.assigned_char_spec,
                            spec_emote: override.assigned_char_spec_emote,
                            partyId: override.party_id,
                            slotId: override.slot_id,
                            color: override.player_color,
                            isConfirmed: originalRosterPlayer?.isConfirmed || false,
                            inRaid: override.in_raid || false,
                            isPlaceholder: override.is_placeholder || false,
                        });
                    } else {
                        // Player doesn't exist in original signups - create from override data only
                        const playerData = {
                            userid: override.discord_user_id,
                            name: override.original_signup_name,
                            mainCharacterName: override.assigned_char_name,
                            class: override.assigned_char_class,
                            spec: override.assigned_char_spec,
                            spec_emote: override.assigned_char_spec_emote,
                            partyId: override.party_id,
                            slotId: override.slot_id,
                            color: override.player_color,
                            altCharacters: [], // No alt data for manually added characters
                            status: 'confirmed', // Assume confirmed for manually added
                            isConfirmed: true, // Manually added players are confirmed
                            inRaid: override.in_raid || false,
                            isPlaceholder: override.is_placeholder || false,
                        };
                        
                        finalRosterPlayers.push(playerData);
                    }
                    if (override.discord_user_id) {
                        playersInRosterOverrides.add(override.discord_user_id);
                    }
                }
            });

            rosterData = { ...rosterDataFromApi, raidDrop: finalRosterPlayers, isManaged: true };

            // Bench logic: players who are in signups but NOT in a roster spot in our overrides table
            const benchPlayers = enrichedAllPlayers.filter(p => !playersInRosterOverrides.has(p.userid));
            rosterData.bench = benchPlayers;

        } else {
            // Roster is NOT managed - original logic
            rosterData = await enrichRosterWithDbData(rosterDataFromApi, client);
            rosterData.isManaged = false;

            // Original bench logic for unmanaged rosters
            try {
                const fullEventData = await getFullEventDataFromApi(eventId);
                const raidDropPlayerIds = new Set(rosterData.raidDrop.map(p => p && p.userid).filter(Boolean));
                
                const benchSignups = fullEventData.signUps.filter(signup => {
                    return signup.userId && !raidDropPlayerIds.has(signup.userId);
                });

                let benchPlayers = benchSignups.map(signup => {
                    const canonicalClass = getCanonicalClass(signup.className);
                    return {
                        userid: signup.userId,
                        name: signup.name,
                        class: signup.className,
                        spec: signup.specName,
                        spec_emote: signup.specEmoteId || signup.classEmoteId,
                        class_emote: signup.classEmoteId,
                        status: signup.status,
                        color: CLASS_COLORS[canonicalClass] || null,
                        partyId: null, 
                        slotId: null
                    };
                });
                
                rosterData.bench = await enrichPlayersWithDbData(benchPlayers, client);
            } catch (error) {
                console.warn(`\n[WARNING] Could not fetch/process bench data for event ${eventId}.\nThe main roster will be displayed, but the bench will be empty.\n\n[DETAILED ERROR] ${error.stack}\n`);
                rosterData.bench = [];
            }
        }
        
        res.json(rosterData);
    } catch (error) {
        console.error(`Error in /api/roster/:eventId for event ${eventId}:\n`, error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) {
            client.release();
        }
    }
});

// Helper function to get details that might not be in our DB
async function getRaidDetailsFromRaidHelper(eventId) {
    try {
        const response = await axios.get(`https://raid-helper.dev/api/raidplan/${eventId}`);
        const event = response.data;
        return {
            title: event.name,
            partyPerRaid: event.raid.parties,
            slotPerParty: event.raid.slots,
            partyNames: event.raid.party_names.map(p => p.name)
        };
    } catch (error) {
        console.error('Error fetching Raid-Helper event details:', error.response ? error.response.data : error.message);
        if (error.response) {
            console.error('Raid-Helper API Error Response Details (Non-200):', {
                status: error.response.status,
                headers: error.response.headers,
                data: error.response.data
            });
        }
        throw new Error(`Failed to fetch event details for event ID: ${eventId}`);
    }
}

// Endpoint to handle swapping a player's character
app.put('/api/roster/:eventId/player/:discordUserId', requireRosterManager, async (req, res) => {
    const { eventId, discordUserId } = req.params;
    let { characterName, characterClass } = req.body;

    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        await forkRosterIfNeeded(eventId, client);

        if (!characterName) { // This is a "revert to registered character" action
            // Get the first registered character for this Discord user
            const originalCharacterResult = await client.query(
                'SELECT character_name, class FROM players WHERE discord_id = $1 ORDER BY character_name LIMIT 1',
                [discordUserId]
            );
            const originalCharacter = originalCharacterResult.rows[0];

            if (!originalCharacter) {
                throw new Error(`Could not find original registered character for discord user ${discordUserId}`);
            }

            const canonicalClass = getCanonicalClass(originalCharacter.class);
            const color = CLASS_COLORS[canonicalClass] || '#808080';
            const classIcon = CLASS_ICONS[canonicalClass] || null;
            
            await client.query(
                `UPDATE roster_overrides SET assigned_char_name = $1, assigned_char_class = $2, player_color = $3, assigned_char_spec = NULL, assigned_char_spec_emote = $4 WHERE event_id = $5 AND discord_user_id = $6`,
                [originalCharacter.character_name, originalCharacter.class, color, classIcon, eventId, discordUserId]
            );

        } else { // This is a "swap to alt" action
            const canonicalClass = getCanonicalClass(characterClass);
            const color = CLASS_COLORS[canonicalClass] || '#808080';
            
            // When swapping characters, reset spec to null and use class icon
            const classIcon = CLASS_ICONS[canonicalClass] || null;

            await client.query(
                `UPDATE roster_overrides 
                 SET assigned_char_name = $1, assigned_char_class = $2, player_color = $3, assigned_char_spec = NULL, assigned_char_spec_emote = $4
                 WHERE event_id = $5 AND discord_user_id = $6`,
                [characterName, characterClass, color, classIcon, eventId, discordUserId]
            );
        }

        await client.query('COMMIT');
        try { broadcastUpdate('roster', eventId, { type: 'roster_changed', byUserId: req.user?.id || null }); } catch {}
        res.json({ message: 'Player character updated successfully.' });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error updating player character:', error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

app.get('/api/specs', (req, res) => {
    res.json(SPEC_DATA);
});

// Endpoint to handle updating a player's spec
app.put('/api/roster/:eventId/player/:discordUserId/spec', requireRosterManager, async (req, res) => {
    const { eventId, discordUserId } = req.params;
    const { specName } = req.body;

    let client;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // Ensure the roster is managed before updating a spec
        const checkResult = await client.query('SELECT assigned_char_class FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2', [eventId, discordUserId]);

        if (checkResult.rows.length === 0) {
            // This case should ideally not be hit if the UI is correct, but as a fallback:
            const rosterData = await getRosterDataFromApi(eventId);
            const enrichedRoster = await enrichRosterWithDbData(rosterData, client);
            const insertPromises = enrichedRoster.raidDrop.filter(p => p && p.userid).map(p => {
                const params = [eventId, p.userid, p.name, p.mainCharacterName || p.name, p.class, p.spec, p.spec_emote, p.color, p.partyId, p.slotId];
                return client.query(`INSERT INTO roster_overrides (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, player_color, party_id, slot_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (event_id, discord_user_id) DO NOTHING`, params);
            });
            await Promise.all(insertPromises);
        }

        // Get the player class after ensuring the override exists
        let playerClass;
        if (checkResult.rows.length > 0) {
            playerClass = checkResult.rows[0].assigned_char_class;
        } else {
            // Query again after the INSERT operations to get the class
            const updatedResult = await client.query('SELECT assigned_char_class FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2', [eventId, discordUserId]);
            if (updatedResult.rows.length === 0) {
                throw new Error(`Player ${discordUserId} not found in roster for event ${eventId}`);
            }
            playerClass = updatedResult.rows[0].assigned_char_class;
        }
        const canonicalClass = getCanonicalClass(playerClass);
        const specsForClass = SPEC_DATA[canonicalClass] || [];
        const selectedSpec = specsForClass.find(s => s.name === specName);

        if (selectedSpec) {
            await client.query(
                `UPDATE roster_overrides SET assigned_char_spec = $1, assigned_char_spec_emote = $2 WHERE event_id = $3 AND discord_user_id = $4`,
                [selectedSpec.name, selectedSpec.emote, eventId, discordUserId]
            );
        }

        await client.query('COMMIT');
        try { broadcastUpdate('roster', eventId, { type: 'roster_changed', byUserId: req.user?.id || null }); } catch {}
        res.json({ message: 'Player spec updated successfully.' });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error updating player spec:', error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
            }
        });

// Endpoint to toggle a player's "in raid" status
app.put('/api/roster/:eventId/player/:discordUserId/in-raid', requireRosterManager, async (req, res) => {
    const { eventId, discordUserId } = req.params;
    const { inRaid } = req.body;

    let client;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // First ensure the player exists in roster_overrides
        const checkResult = await client.query('SELECT in_raid FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2', [eventId, discordUserId]);

        if (checkResult.rows.length === 0) {
            // If player doesn't exist in overrides, we need to fork the roster first
            await forkRosterIfNeeded(eventId, client);
        }

        // Update the in_raid status
        await client.query(
            `UPDATE roster_overrides SET in_raid = $1 WHERE event_id = $2 AND discord_user_id = $3`,
            [inRaid, eventId, discordUserId]
        );

        await client.query('COMMIT');
        try { broadcastUpdate('roster', eventId, { type: 'roster_changed', byUserId: req.user?.id || null }); } catch {}
        res.json({ message: 'Player in-raid status updated successfully.', inRaid });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error updating player in-raid status:', error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to add a placeholder player to roster
app.post('/api/roster/:eventId/add-placeholder', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    const { characterName, characterClass, targetPartyId, targetSlotId } = req.body;
    
    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        
        // Validate inputs
        if (!characterName || !characterClass) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Character name and class are required' });
        }
        
        if (!targetPartyId || !targetSlotId) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Target party and slot are required' });
        }
        
        // Fork the roster first to preserve existing players
        await forkRosterIfNeeded(eventId, client);
        
        // Check if slot is already occupied
        const existingPlayer = await client.query(
            'SELECT id FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3',
            [eventId, targetPartyId, targetSlotId]
        );
        
        if (existingPlayer.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Slot is already occupied' });
        }
        
        // Get class color
        const canonicalClass = (characterClass || '').toLowerCase();
        const classColors = {
            'death knight': '196,30,59',
            'druid': '255,125,10',
            'hunter': '171,212,115',
            'mage': '105,204,240',
            'paladin': '245,140,186',
            'priest': '255,255,255',
            'rogue': '255,245,105',
            'shaman': '0,112,222',
            'warlock': '148,130,201',
            'warrior': '199,156,110'
        };
        const playerColor = classColors[canonicalClass] || '128,128,128';
        
        // Insert placeholder
        await client.query(`
            INSERT INTO roster_overrides 
            (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, 
             player_color, party_id, slot_id, is_placeholder, in_raid) 
            VALUES ($1, NULL, $2, $3, $4, $5, $6, $7, TRUE, FALSE)
        `, [eventId, characterName, characterName, characterClass, playerColor, targetPartyId, targetSlotId]);
        
        await client.query('COMMIT');
        res.json({ 
            success: true,
            message: 'Placeholder added successfully'
        });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error adding placeholder:', error);
        res.status(500).json({ error: 'Internal server error', details: error.message });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to remove a placeholder player from roster
app.post('/api/roster/:eventId/remove-placeholder', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    const { partyId, slotId } = req.body;
    
    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        
        // Delete the placeholder
        const result = await client.query(
            'DELETE FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3 AND is_placeholder = TRUE',
            [eventId, partyId, slotId]
        );
        
        if (result.rowCount === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Placeholder not found' });
        }
        
        await client.query('COMMIT');
        res.json({ 
            success: true,
            message: 'Placeholder removed successfully'
        });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error removing placeholder:', error);
        res.status(500).json({ error: 'Internal server error', details: error.message });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to convert placeholder to real player (add Discord ID)
app.post('/api/roster/:eventId/convert-placeholder', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    const { partyId, slotId, discordId, characterName, characterClass } = req.body;
    
    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        
        // Validate inputs
        if (!discordId) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Discord ID is required' });
        }
        
        // Check if this Discord user is already in the roster for this event
        const existingUser = await client.query(
            'SELECT id FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2 AND is_placeholder = FALSE',
            [eventId, discordId]
        );
        
        if (existingUser.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'This player is already in the roster' });
        }
        
        // Get the placeholder
        const placeholder = await client.query(
            'SELECT * FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3 AND is_placeholder = TRUE',
            [eventId, partyId, slotId]
        );
        
        if (placeholder.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Placeholder not found' });
        }
        
        // Add character to players table
        await client.query(`
            INSERT INTO players (discord_id, character_name, class) 
            VALUES ($1, $2, $3)
            ON CONFLICT DO NOTHING`,
            [discordId, characterName, characterClass]
        );
        
        // Update the placeholder with Discord ID
        await client.query(`
            UPDATE roster_overrides 
            SET discord_user_id = $1,
                assigned_char_name = $2,
                assigned_char_class = $3,
                is_placeholder = FALSE
            WHERE event_id = $4 AND party_id = $5 AND slot_id = $6
        `, [discordId, characterName, characterClass, eventId, partyId, slotId]);
        
        await client.query('COMMIT');
        res.json({ 
            success: true,
            message: 'Placeholder converted to real player successfully'
        });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error converting placeholder:', error);
        res.status(500).json({ error: 'Internal server error', details: error.message });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to handle adding a new character to roster
app.post('/api/roster/:eventId/add-character', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    const { characterName, class: characterClass, discordId, spec, targetPartyId, targetSlotId } = req.body;

    let client;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // Validate input
        if (!characterName || !characterClass || !discordId || !targetPartyId || !targetSlotId) {
            throw new Error('Missing required fields');
        }

        // Validate Discord ID format
        if (!/^\d{17,19}$/.test(discordId)) {
            throw new Error('Invalid Discord ID format');
        }

        // Check if there's already a player in this position
        const existingPlayer = await client.query(
            'SELECT discord_user_id FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3',
            [eventId, targetPartyId, targetSlotId]
        );

        if (existingPlayer.rows.length > 0) {
            throw new Error('Position is already occupied');
        }

        // Check for existing characters with same discord_id, name, and class (refuse creation)
        // With the new PRIMARY KEY (discord_id, character_name, class), the database will prevent duplicates
        // But we check here first to provide a user-friendly error message
        const exactMatch = await client.query(
            'SELECT character_name FROM players WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND class = $3',
            [discordId, characterName, characterClass]
        );

        if (exactMatch.rows.length > 0) {
            return res.status(409).json({ 
                error: 'EXACT_DUPLICATE',
                message: `You already have a character named "${characterName}" with class "${characterClass}". You can have multiple characters with the same name but different classes.`
            });
        }

        // Check for existing characters with same name but different class (show warning)
        const nameMatch = await client.query(
            'SELECT character_name, class FROM players WHERE LOWER(character_name) = LOWER($1) AND class != $2',
            [characterName, characterClass]
        );

        if (nameMatch.rows.length > 0) {
            const existingClass = nameMatch.rows[0].class;
            return res.status(409).json({ 
                error: 'NAME_CONFLICT',
                message: `A character named "${characterName}" already exists with class "${existingClass}". Are you sure you want to create this character with class "${characterClass}"?`,
                existingCharacter: {
                    name: characterName,
                    class: existingClass
                }
            });
        }

        // Check for existing characters with same Discord ID (show warning)
        const discordIdMatches = await client.query(
            'SELECT character_name, class FROM players WHERE discord_id = $1',
            [discordId]
        );

        if (discordIdMatches.rows.length > 0) {
            return res.status(409).json({ 
                error: 'DISCORD_ID_CONFLICT',
                message: `There ${discordIdMatches.rows.length === 1 ? 'is already 1 character' : `are already ${discordIdMatches.rows.length} characters`} with this Discord ID. Do you want to create this character?`,
                existingCharacters: discordIdMatches.rows.map(row => ({
                    name: row.character_name,
                    class: row.class
                }))
            });
        }

        // Ensure roster is managed by creating initial overrides if needed
        await forkRosterIfNeeded(eventId, client);

        // Get canonical class and determine spec
        const canonicalClass = getCanonicalClass(characterClass);
        const specsForClass = SPEC_DATA[canonicalClass] || [];
        
        // Use provided spec if valid, otherwise use default
        let selectedSpec;
        if (spec && specsForClass.find(s => s.name === spec)) {
            selectedSpec = specsForClass.find(s => s.name === spec);
        } else {
            selectedSpec = specsForClass.length > 0 ? specsForClass[0] : { name: characterClass, emote: null };
        }

        // Get class color
        const classColors = {
            'death knight': '196,30,59',
            'druid': '255,125,10',
            'hunter': '171,212,115',
            'mage': '105,204,240',
            'paladin': '245,140,186',
            'priest': '255,255,255',
            'rogue': '255,245,105',
            'shaman': '0,112,222',
            'warlock': '148,130,201',
            'warrior': '199,156,110'
        };
        const playerColor = classColors[canonicalClass] || '128,128,128';

        // First, add the character to the main players table (do nothing on any conflict)
        await client.query(`
            INSERT INTO players (discord_id, character_name, class) 
            VALUES ($1, $2, $3)
            ON CONFLICT DO NOTHING`,
            [discordId, characterName, characterClass]
        );

        // Then, upsert into roster_overrides using explicit existence check
        const existingOverride = await client.query(
            'SELECT 1 FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2',
            [eventId, discordId]
        );
        if (existingOverride.rows.length > 0) {
            await client.query(`
                UPDATE roster_overrides SET 
                    original_signup_name = $3,
                    assigned_char_name = $4,
                    assigned_char_class = $5,
                    assigned_char_spec = $6,
                    assigned_char_spec_emote = $7,
                    player_color = $8,
                    party_id = $9,
                    slot_id = $10
                WHERE event_id = $1 AND discord_user_id = $2
            `, [eventId, discordId, characterName, characterName, characterClass, selectedSpec.name, selectedSpec.emote, playerColor, targetPartyId, targetSlotId]);
        } else {
        await client.query(`
            INSERT INTO roster_overrides 
            (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, player_color, party_id, slot_id) 
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            `, [eventId, discordId, characterName, characterName, characterClass, selectedSpec.name, selectedSpec.emote, playerColor, targetPartyId, targetSlotId]);
        }

        await client.query('COMMIT');
        res.json({ 
            message: 'Character added to roster successfully',
            character: {
                characterName,
                class: characterClass,
                discordId,
                spec: selectedSpec.name,
                partyId: targetPartyId,
                slotId: targetSlotId
            }
        });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error adding character to roster:', error);
        res.status(500).json({ message: error.message || 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to handle adding a new character to roster (force creation, bypassing warnings)
app.post('/api/roster/:eventId/add-character/force', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    const { characterName, class: characterClass, discordId, spec, targetPartyId, targetSlotId } = req.body;

    let client;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // Validate input
        if (!characterName || !characterClass || !discordId || !targetPartyId || !targetSlotId) {
            throw new Error('Missing required fields');
        }

        // Validate Discord ID format
        if (!/^\d{17,19}$/.test(discordId)) {
            throw new Error('Invalid Discord ID format');
        }

        // Check if there's already a player in this position
        const existingPlayer = await client.query(
            'SELECT discord_user_id FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3',
            [eventId, targetPartyId, targetSlotId]
        );

        if (existingPlayer.rows.length > 0) {
            throw new Error('Position is already occupied');
        }

        // Still check for exact duplicates (same discord_id, name, and class) as these should never be allowed
        // With the new PRIMARY KEY (discord_id, character_name, class), the database will prevent duplicates
        // But we check here first to provide a user-friendly error message
        const exactMatch = await client.query(
            'SELECT character_name FROM players WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND class = $3',
            [discordId, characterName, characterClass]
        );

        if (exactMatch.rows.length > 0) {
            throw new Error(`You already have a character named "${characterName}" with class "${characterClass}". You can have multiple characters with the same name but different classes.`);
        }

        // Continue with creation (bypassing name and Discord ID warnings)
        await forkRosterIfNeeded(eventId, client);

        // Get canonical class and determine spec
        const canonicalClass = getCanonicalClass(characterClass);
        const specsForClass = SPEC_DATA[canonicalClass] || [];
        
        // Use provided spec if valid, otherwise use default
        let selectedSpec;
        if (spec && specsForClass.find(s => s.name === spec)) {
            selectedSpec = specsForClass.find(s => s.name === spec);
        } else {
            selectedSpec = specsForClass.length > 0 ? specsForClass[0] : { name: characterClass, emote: null };
        }

        // Get class color
        const classColors = {
            'death knight': '196,30,59',
            'druid': '255,125,10',
            'hunter': '171,212,115',
            'mage': '105,204,240',
            'paladin': '245,140,186',
            'priest': '255,255,255',
            'rogue': '255,245,105',
            'shaman': '0,112,222',
            'warlock': '148,130,201',
            'warrior': '199,156,110'
        };
        const playerColor = classColors[canonicalClass] || '128,128,128';

        // First, add the character to the main players table
        await client.query(`
            INSERT INTO players (discord_id, character_name, class) 
            VALUES ($1, $2, $3)
            ON CONFLICT (discord_id, character_name, class) DO NOTHING`,
            [discordId, characterName, characterClass]
        );

        // Then, insert the new character into the roster
        await client.query(`
            INSERT INTO roster_overrides 
            (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, player_color, party_id, slot_id) 
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            ON CONFLICT (event_id, discord_user_id) 
            DO UPDATE SET 
                assigned_char_name = EXCLUDED.assigned_char_name,
                assigned_char_class = EXCLUDED.assigned_char_class,
                assigned_char_spec = EXCLUDED.assigned_char_spec,
                assigned_char_spec_emote = EXCLUDED.assigned_char_spec_emote,
                player_color = EXCLUDED.player_color,
                party_id = EXCLUDED.party_id,
                slot_id = EXCLUDED.slot_id`,
            [eventId, discordId, characterName, characterName, characterClass, selectedSpec.name, selectedSpec.emote, playerColor, targetPartyId, targetSlotId]
        );

        await client.query('COMMIT');
        res.json({ 
            message: 'Character added to roster successfully',
            character: {
                characterName,
                class: characterClass,
                discordId,
                spec: selectedSpec.name,
                partyId: targetPartyId,
                slotId: targetSlotId
            }
        });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error force adding character to roster:', error);
        res.status(500).json({ message: error.message || 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to add an existing player to roster (from players table)
app.post('/api/roster/:eventId/add-existing-player', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    const { characterName, class: characterClass, discordId, spec, targetPartyId, targetSlotId } = req.body;

    let client;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // Validate input
        if (!characterName || !characterClass || !discordId || !targetPartyId || !targetSlotId) {
            throw new Error('Missing required fields');
        }

        // Validate Discord ID format
        if (!/^\d{17,19}$/.test(discordId)) {
            throw new Error('Invalid Discord ID format');
        }

        // Check if there's already a player in this position
        const existingPlayer = await client.query(
            'SELECT discord_user_id FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3',
            [eventId, targetPartyId, targetSlotId]
        );

        if (existingPlayer.rows.length > 0) {
            throw new Error('Position is already occupied');
        }

        // Verify the player exists in the players table
        const playerExists = await client.query(
            'SELECT character_name, class FROM players WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND class = $3',
            [discordId, characterName, characterClass]
        );

        if (playerExists.rows.length === 0) {
            throw new Error(`Player "${characterName}" with class "${characterClass}" not found in players database`);
        }

        // Fork roster if needed
        await forkRosterIfNeeded(eventId, client);

        // Get canonical class and determine spec
        const canonicalClass = getCanonicalClass(characterClass);
        const specsForClass = SPEC_DATA[canonicalClass] || [];
        
        // Use provided spec if valid, otherwise use default
        let selectedSpec;
        if (spec && specsForClass.find(s => s.name === spec)) {
            selectedSpec = specsForClass.find(s => s.name === spec);
        } else {
            selectedSpec = specsForClass.length > 0 ? specsForClass[0] : { name: characterClass, emote: null };
        }

        // Get class color
        const classColors = {
            'death knight': '196,30,59',
            'druid': '255,125,10',
            'hunter': '171,212,115',
            'mage': '105,204,240',
            'paladin': '245,140,186',
            'priest': '255,255,255',
            'rogue': '255,245,105',
            'shaman': '0,112,222',
            'warlock': '148,130,201',
            'warrior': '199,156,110'
        };
        const playerColor = classColors[canonicalClass] || '128,128,128';

        // Insert/update the existing player into the roster using existence check
        const exists = await client.query('SELECT 1 FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2', [eventId, discordId]);
        if (exists.rows.length > 0) {
            await client.query(`
                UPDATE roster_overrides SET 
                    original_signup_name = $3,
                    assigned_char_name = $4,
                    assigned_char_class = $5,
                    assigned_char_spec = $6,
                    assigned_char_spec_emote = $7,
                    player_color = $8,
                    party_id = $9,
                    slot_id = $10
                WHERE event_id = $1 AND discord_user_id = $2
            `, [eventId, discordId, characterName, characterName, characterClass, selectedSpec.name, selectedSpec.emote, playerColor, targetPartyId, targetSlotId]);
        } else {
        await client.query(`
            INSERT INTO roster_overrides 
            (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, player_color, party_id, slot_id) 
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            `, [eventId, discordId, characterName, characterName, characterClass, selectedSpec.name, selectedSpec.emote, playerColor, targetPartyId, targetSlotId]);
        }

        await client.query('COMMIT');
        res.json({ 
            message: 'Existing player added to roster successfully',
            character: {
                characterName,
                class: characterClass,
                discordId,
                spec: selectedSpec.name,
                partyId: targetPartyId,
                slotId: targetSlotId
            }
        });

    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error adding existing player to roster:', error);
        res.status(500).json({ message: error.message || 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// Endpoint to handle moving a player
app.put('/api/roster/:eventId/player/:discordUserId/position', requireRosterManager, async (req, res) => {
    const { eventId, discordUserId } = req.params;
    const targetPartyId = parseInt(req.body.targetPartyId, 10);
    const targetSlotId = parseInt(req.body.targetSlotId, 10);
    let client;

    try {
        console.log(`[MOVE DEBUG] Starting move: eventId=${eventId}, discordUserId=${discordUserId}, targetParty=${targetPartyId}, targetSlot=${targetSlotId}`);
        
        client = await pool.connect();
        await client.query('BEGIN');
        
        console.log('[MOVE DEBUG] Database transaction started');

        await forkRosterIfNeeded(eventId, client);
        console.log('[MOVE DEBUG] Roster forked if needed');

        const sourcePlayerRes = await client.query('SELECT party_id, slot_id FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2', [eventId, discordUserId]);
        const sourcePlayer = sourcePlayerRes.rows[0];
        const isSourcePlayerInRoster = !!(sourcePlayer && sourcePlayer.party_id !== null);
        console.log(`[MOVE DEBUG] Source player query result:`, { sourcePlayer, isSourcePlayerInRoster });

        const targetPlayerRes = await client.query('SELECT discord_user_id FROM roster_overrides WHERE event_id = $1 AND party_id = $2 AND slot_id = $3', [eventId, targetPartyId, targetSlotId]);
        const targetPlayer = targetPlayerRes.rows[0];
        console.log(`[MOVE DEBUG] Target player query result:`, { targetPlayer });

        if (isSourcePlayerInRoster) {
            // --- MOVING A PLAYER WHO IS ALREADY IN THE ROSTER ---
            if (targetPlayer && targetPlayer.discord_user_id === discordUserId) {
                // Source and target are the same player in the same slot. No action taken.
            } else {
                if (targetPlayer) { // It's a SWAP with another player
                    await client.query(
                        `UPDATE roster_overrides SET party_id = $1, slot_id = $2 WHERE event_id = $3 AND discord_user_id = $4`,
                        [sourcePlayer.party_id, sourcePlayer.slot_id, eventId, targetPlayer.discord_user_id]
                    );
                }
                // This query always runs for a move-to-empty or a swap with another player
                await client.query(
                    `UPDATE roster_overrides SET party_id = $1, slot_id = $2 WHERE event_id = $3 AND discord_user_id = $4`,
                    [targetPartyId, targetSlotId, eventId, discordUserId]
                );
            }
        } else {
            // --- MOVING A PLAYER FROM THE BENCH ---
            if (targetPlayer) {
                // A player is in the destination. DELETE them from the roster.
                // They will reappear on the bench because they're still in the API signups.
                await client.query(`DELETE FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2`, [eventId, targetPlayer.discord_user_id]);
            }

            // The player might exist in our table but with NULL position (if they were moved to bench).
            // A simple delete is cleaner than checking and avoids conflicts.
            await client.query(`DELETE FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2`, [eventId, discordUserId]);
            
            // Now, insert a fresh record for the player from the bench into their new spot.
            const playerToInsert = await getPlayerForInsert(eventId, discordUserId, client);
            await client.query(
                `INSERT INTO roster_overrides (event_id, discord_user_id, original_signup_name, assigned_char_name, assigned_char_class, assigned_char_spec, assigned_char_spec_emote, player_color, party_id, slot_id) 
                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
                [eventId, discordUserId, playerToInsert.name, playerToInsert.mainCharacterName, playerToInsert.class, playerToInsert.spec, playerToInsert.spec_emote, playerToInsert.color, targetPartyId, targetSlotId]
            );
        }

        await client.query('COMMIT');
        console.log('[MOVE DEBUG] Transaction committed successfully');
        res.status(200).json({ message: 'Player position updated successfully.' });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('[MOVE DEBUG] Error occurred:', error.message);
        console.error('[MOVE DEBUG] Full error stack:', error.stack);
        console.error('[MOVE DEBUG] Error details:', {
            name: error.name,
            code: error.code,
            detail: error.detail,
            hint: error.hint,
            position: error.position,
            internalPosition: error.internalPosition,
            internalQuery: error.internalQuery,
            where: error.where,
            schema: error.schema,
            table: error.table,
            column: error.column,
            dataType: error.dataType,
            constraint: error.constraint
        });
        res.status(500).json({ message: 'Internal Server Error', debug: error.message });
    } finally {
        if (client) client.release();
    }
});

app.post('/api/roster/:eventId/player/:discordUserId/bench', requireRosterManager, async (req, res) => {
    const { eventId, discordUserId } = req.params;
    let client;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // Forking ensures the roster is managed, which is a prerequisite for benching.
        await forkRosterIfNeeded(eventId, client);

        // Check if the player is actually in the roster before trying to "bench" them.
        const rosterCheck = await client.query(
            'SELECT * FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2 AND party_id IS NOT NULL',
            [eventId, discordUserId]
        );

        if (rosterCheck.rows.length === 0) {
            // It's good practice to send a success response even if no action was taken,
            // as the desired state (player on bench) is already met.
            await client.query('COMMIT'); // Commit the no-op transaction
            return res.status(200).json({ message: 'Player is already on the bench.' });
        }

        // Deleting the player's override record effectively "benches" them.
        // They will reappear on the bench on the next fetch because they are still in the original API signups.
        await client.query('DELETE FROM roster_overrides WHERE event_id = $1 AND discord_user_id = $2', [eventId, discordUserId]);

        await client.query('COMMIT');
        res.status(200).json({ message: 'Player moved to bench successfully.' });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('Error benching player:', error.stack);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

app.post('/api/roster/:eventId/revert', requireRosterManager, async (req, res) => {
    const { eventId } = req.params;
    let client;

    try {
        client = await pool.connect();
        await client.query('DELETE FROM roster_overrides WHERE event_id = $1', [eventId]);
        res.json({ message: 'Roster reverted to unmanaged.' });
    } catch (error) {
        console.error(`Error reverting roster for event ${eventId}:`, error);
        res.status(500).json({ message: 'Internal Server Error' });
    } finally {
        if (client) client.release();
    }
});

// --- Database Migration Endpoints ---
app.post('/api/admin/setup-database', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        // Create players table
        await client.query(`
            CREATE TABLE IF NOT EXISTS players (
                discord_id VARCHAR(255),
                character_name VARCHAR(255),
                class VARCHAR(50),
                PRIMARY KEY (discord_id, character_name, class)
            )
        `);
        
        // Create roster_overrides table
        await client.query(`
            CREATE TABLE IF NOT EXISTS roster_overrides (
                id SERIAL PRIMARY KEY,
                event_id VARCHAR(255),
                discord_user_id VARCHAR(255),
                original_signup_name VARCHAR(255),
                assigned_char_name VARCHAR(255),
                assigned_char_class VARCHAR(50),
                assigned_char_spec VARCHAR(50),
                assigned_char_spec_emote VARCHAR(50),
                player_color VARCHAR(50),
                party_id INTEGER,
                slot_id INTEGER,
                in_raid BOOLEAN DEFAULT FALSE,
                is_placeholder BOOLEAN DEFAULT FALSE
            )
        `);
        
        // Create unique constraints for roster_overrides
        await client.query(`
            CREATE UNIQUE INDEX IF NOT EXISTS roster_overrides_position_unique 
            ON roster_overrides (event_id, party_id, slot_id) 
            WHERE party_id IS NOT NULL AND slot_id IS NOT NULL
        `);
        
        await client.query(`
            CREATE UNIQUE INDEX IF NOT EXISTS roster_overrides_discord_unique 
            ON roster_overrides (event_id, discord_user_id) 
            WHERE discord_user_id IS NOT NULL AND is_placeholder = FALSE
        `);
        
        // Create player_confirmed_logs table for storing confirmed raid participants
        await client.query(`
            CREATE TABLE IF NOT EXISTS player_confirmed_logs (
                raid_id VARCHAR(255),
                discord_id VARCHAR(255),
                character_name VARCHAR(255),
                character_class VARCHAR(50),
                confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (raid_id, discord_id)
            )
        `);

        // Create log_data table for storing damage and healing data from WoW logs
        await client.query(`
            CREATE TABLE IF NOT EXISTS log_data (
                event_id VARCHAR(255),
                character_name VARCHAR(255),
                character_class VARCHAR(50),
                discord_id VARCHAR(255),
                role_detected VARCHAR(50),
                role_source VARCHAR(50),
                spec_name VARCHAR(50),
                damage_amount BIGINT DEFAULT 0,
                healing_amount BIGINT DEFAULT 0,
                log_id VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (event_id, character_name)
            )
        `);

        // Create guildies table for guild member data
        await client.query(`
            CREATE TABLE IF NOT EXISTS guildies (
                character_name VARCHAR(255),
                rank_name VARCHAR(100),
                level INTEGER,
                class VARCHAR(50),
                race VARCHAR(50),
                sex VARCHAR(20),
                last_online_days DECIMAL,
                main_alt VARCHAR(50),
                player_alts TEXT,
                join_date VARCHAR(50),
                promo_date VARCHAR(50),
                rank_history TEXT,
                birthday VARCHAR(50),
                public_note TEXT,
                officer_note TEXT,
                custom_note TEXT,
                faction VARCHAR(20),
                discord_id VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (character_name, class)
            )
        `);

        // Create sheet_imports table for tracking Google Sheet imports
        await client.query(`
            CREATE TABLE IF NOT EXISTS sheet_imports (
                id SERIAL PRIMARY KEY,
                event_id VARCHAR(255) NOT NULL,
                sheet_url TEXT NOT NULL,
                sheet_title VARCHAR(500),
                imported_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(event_id, sheet_url)
            )
        `);

        // Create sheet_player_abilities table for storing player ability data from sheets
        await client.query(`
            CREATE TABLE IF NOT EXISTS sheet_player_abilities (
                id SERIAL PRIMARY KEY,
                sheet_import_id INTEGER REFERENCES sheet_imports(id) ON DELETE CASCADE,
                event_id VARCHAR(255) NOT NULL,
                character_name VARCHAR(255) NOT NULL,
                character_class VARCHAR(50) NOT NULL,
                ability_name TEXT NOT NULL,
                ability_value TEXT NOT NULL,
                row_number INTEGER,
                column_number INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Create sheet_players_buffs table for storing world buffs data from archived sheets
        await client.query(`
            CREATE TABLE IF NOT EXISTS sheet_players_buffs (
                id SERIAL PRIMARY KEY,
                sheet_import_id INTEGER REFERENCES sheet_imports(id) ON DELETE CASCADE,
                event_id VARCHAR(255) NOT NULL,
                character_name VARCHAR(255) NOT NULL,
                buff_name VARCHAR(100) NOT NULL,
                buff_value VARCHAR(50),
                color_status VARCHAR(100),
                background_color VARCHAR(20),
                amount_summary VARCHAR(50),
                score_summary VARCHAR(50),
                row_number INTEGER,
                column_number INTEGER,
                analysis_type VARCHAR(50) DEFAULT 'world_buffs',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Create sheet_players_frostres table for storing frost resistance data from archived sheets
        await client.query(`
            CREATE TABLE IF NOT EXISTS sheet_players_frostres (
                id SERIAL PRIMARY KEY,
                sheet_import_id INTEGER REFERENCES sheet_imports(id) ON DELETE CASCADE,
                event_id VARCHAR(255) NOT NULL,
                character_name VARCHAR(255) NOT NULL,
                frost_resistance VARCHAR(50),
                row_number INTEGER,
                analysis_type VARCHAR(50) DEFAULT 'frost_resistance',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Create reward_settings table for configurable rewards and deductions
        await client.query(`
            CREATE TABLE IF NOT EXISTS reward_settings (
                id SERIAL PRIMARY KEY,
                setting_type VARCHAR(50) NOT NULL,
                setting_name VARCHAR(100) NOT NULL,
                setting_value DECIMAL(10,2) NOT NULL,
                description TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(setting_type, setting_name)
            )
        `);

        // Add a JSON column for array values
        await client.query(`
            ALTER TABLE reward_settings 
            ADD COLUMN IF NOT EXISTS setting_json JSONB
        `);

        // Insert default reward settings if they don't exist
        await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, description)
            VALUES 
                ('abilities', 'calculation_divisor', 10, 'Divisor used in abilities points calculation: (total used √ó avg targets) √∑ divisor'),
                ('abilities', 'max_points', 20, 'Maximum points that can be earned from abilities (sappers, dynamite, holy water)'),
                ('mana_potions', 'threshold', 10, 'Minimum potions needed before earning points'),
                ('mana_potions', 'points_per_potion', 3, 'Points earned per potion above threshold'),
                ('mana_potions', 'max_points', 10, 'Maximum points that can be earned from mana potions'),
                ('runes', 'usage_divisor', 2, 'Number of runes needed per point'),
                ('runes', 'points_per_division', 1, 'Points earned per rune threshold reached'),
                ('runes', 'max_points', 15, 'Maximum points that can be earned from runes'),
                ('interrupts', 'points_per_interrupt', 1, 'Points earned per interrupt'),
                ('interrupts', 'interrupts_needed', 1, 'Number of interrupts needed per point'),
                ('interrupts', 'max_points', 5, 'Maximum points that can be earned from interrupts'),
                ('disarms', 'points_per_disarm', 1, 'Points earned per disarm'),
                ('disarms', 'disarms_needed', 1, 'Number of disarms needed per point'),
                ('disarms', 'max_points', 5, 'Maximum points that can be earned from disarms'),
                ('curse', 'uptime_threshold', 85, 'Minimum uptime percentage required to earn points'),
                ('curse', 'points', 10, 'Points awarded for achieving uptime threshold'),
                ('curse_shadow', 'uptime_threshold', 85, 'Minimum uptime percentage required to earn points for Curse of Shadow'),
                ('curse_shadow', 'points', 10, 'Points awarded for achieving Curse of Shadow uptime threshold'),
                ('curse_elements', 'uptime_threshold', 85, 'Minimum uptime percentage required to earn points for Curse of Elements'),
                ('curse_elements', 'points', 10, 'Points awarded for achieving Curse of Elements uptime threshold'),
                ('faerie_fire', 'uptime_threshold', 85, 'Minimum uptime percentage required to earn points for Faerie Fire'),
                ('faerie_fire', 'points', 10, 'Points awarded for achieving Faerie Fire uptime threshold'),
                ('scorch', 'tier1_max', 99, 'Maximum scorch count for tier 1 (0 points)'),
                ('scorch', 'tier1_points', 0, 'Points awarded for tier 1 scorch count (0-99)'),
                ('scorch', 'tier2_max', 199, 'Maximum scorch count for tier 2 (5 points)'),
                ('scorch', 'tier2_points', 5, 'Points awarded for tier 2 scorch count (100-199)'),
                ('scorch', 'tier3_points', 10, 'Points awarded for tier 3 scorch count (200+)'),
                ('demo_shout', 'tier1_max', 99, 'Maximum demoralizing shout count for tier 1 (0 points)'),
                ('demo_shout', 'tier1_points', 0, 'Points awarded for tier 1 demoralizing shout count (0-99)'),
                ('demo_shout', 'tier2_max', 199, 'Maximum demoralizing shout count for tier 2 (5 points)'),
                ('demo_shout', 'tier2_points', 5, 'Points awarded for tier 2 demoralizing shout count (100-199)'),
                ('demo_shout', 'tier3_points', 10, 'Points awarded for tier 3 demoralizing shout count (200+)'),
                ('sunder', 'enabled', 1, 'Whether Sunder Armor tracking is enabled'),
                ('ui', 'background_blur', 0, 'Background image blur intensity (0-10)')
            ON CONFLICT (setting_type, setting_name) DO NOTHING
        `);

        // Force updated uptime thresholds for curses and faerie fire to 70%
        await client.query(`
            UPDATE reward_settings 
            SET setting_value = 70
            WHERE setting_name = 'uptime_threshold' 
              AND setting_type IN ('curse','curse_shadow','curse_elements','faerie_fire')
              AND setting_value <> 70
        `);

        // Enforce cap for runes to 15 points
        await client.query(`
            UPDATE reward_settings
            SET setting_value = 15
            WHERE setting_type = 'runes' AND setting_name = 'max_points' AND setting_value <> 15
        `);

        // Insert sunder armor point ranges separately (JSON data)
        await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, setting_json, description)
            VALUES 
                ('sunder', 'point_ranges', 0, '[
                  {"min": 0, "max": 49, "points": -10, "color": "red"},
                  {"min": 50, "max": 99, "points": 0, "color": "gray"},
                  {"min": 100, "max": 119, "points": 5, "color": "green"},
                  {"min": 120, "max": 999, "points": 10, "color": "blue"}
                ]', 'Point ranges for Sunder Armor performance')
            ON CONFLICT (setting_type, setting_name) DO NOTHING
        `);

        // Insert damage and healing point arrays
        await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, setting_json, description)
            VALUES 
                ('damage', 'points_array', 0, '[80, 70, 55, 40, 35, 30, 25, 20, 15, 10, 8, 6, 5, 4, 3]', 'Points awarded for damage dealer rankings (positions 1-15)'),
                ('healing', 'points_array', 0, '[80, 65, 60, 55, 40, 35, 30, 20, 15, 10]', 'Points awarded for healer rankings (positions 1-10)')
            ON CONFLICT (setting_type, setting_name) DO NOTHING
        `);
        
        // Create indexes
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_players_discord_id ON players (discord_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_roster_overrides_event_id ON roster_overrides (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_player_confirmed_logs_raid_id ON player_confirmed_logs (raid_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_log_data_event_id ON log_data (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_guildies_discord_id ON guildies (discord_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_guildies_class_name ON guildies (class, character_name)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_imports_event_id ON sheet_imports (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_player_abilities_event_id ON sheet_player_abilities (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_player_abilities_character ON sheet_player_abilities (character_name, character_class)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_players_buffs_event_id ON sheet_players_buffs (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_players_buffs_character ON sheet_players_buffs (character_name, buff_name)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_players_buffs_analysis_type ON sheet_players_buffs (analysis_type)
        `);

        // Add indexes for sheet_players_frostres
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_players_frostres_event_id ON sheet_players_frostres (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_players_frostres_character ON sheet_players_frostres (character_name)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_sheet_players_frostres_analysis_type ON sheet_players_frostres (analysis_type)
        `);

        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_reward_settings_type ON reward_settings (setting_type)
        `);
        
        // Only create analysis_type index if the column exists
        const analysisTypeColumnExists = await client.query(`
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'rpb_tracking' AND column_name = 'analysis_type'
        `);
        
        if (analysisTypeColumnExists.rows.length > 0) {
            await client.query(`
                CREATE INDEX IF NOT EXISTS idx_rpb_tracking_analysis_type ON rpb_tracking (analysis_type)
            `);
            console.log('‚úÖ [DB SETUP] Created index on analysis_type column');
        } else {
            console.log('‚ÑπÔ∏è [DB SETUP] Skipping analysis_type index - column does not exist yet');
        }
        
        // Fix column size for spec emotes (Discord IDs can be 17-19 chars)
        await client.query(`
            ALTER TABLE roster_overrides 
            ALTER COLUMN assigned_char_spec_emote TYPE VARCHAR(50)
        `);
        
        // Add in_raid column for tracking who has joined the group in-game
        await client.query(`
            ALTER TABLE roster_overrides 
            ADD COLUMN IF NOT EXISTS in_raid BOOLEAN DEFAULT FALSE
        `);
        
        // Create channel_filters table for Discord channel filtering
        await client.query(`
            CREATE TABLE IF NOT EXISTS channel_filters (
                channel_id TEXT PRIMARY KEY,
                channel_name TEXT,
                is_visible BOOLEAN DEFAULT true,
                webhook_url TEXT,
                is_nax BOOLEAN DEFAULT false,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Add index for channel_filters
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_channel_filters_visible ON channel_filters (is_visible)
        `);
        
        // Create events_cache table for caching Raid-Helper API responses
        await client.query(`
            CREATE TABLE IF NOT EXISTS events_cache (
                cache_key VARCHAR(100) PRIMARY KEY,
                events_data JSONB NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                expires_at TIMESTAMP NOT NULL
            )
        `);
        
        // Create RPB tracking table
        await client.query(`
            CREATE TABLE IF NOT EXISTS rpb_tracking (
                id SERIAL PRIMARY KEY,
                event_id VARCHAR(100) NOT NULL,
                log_url TEXT NOT NULL,
                rpb_status VARCHAR(20) DEFAULT 'pending',
                rpb_completed_at TIMESTAMP,
                archive_url TEXT,
                archive_name VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(event_id, log_url)
            )
        `);

        // Add analysis_type column to rpb_tracking table (migration for World Buffs and Frost Resistance support)
        console.log('üîß [DB MIGRATION] Checking if analysis_type column exists...');
        
        // Check if column already exists
        const columnCheck = await client.query(`
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'rpb_tracking' AND column_name = 'analysis_type'
        `);
        
        if (columnCheck.rows.length === 0) {
            console.log('üîß [DB MIGRATION] Adding analysis_type column...');
            await client.query(`
                ALTER TABLE rpb_tracking 
                ADD COLUMN analysis_type VARCHAR(50) DEFAULT 'rpb'
            `);
            console.log('‚úÖ [DB MIGRATION] analysis_type column added successfully');
        } else {
            console.log('‚ÑπÔ∏è [DB MIGRATION] analysis_type column already exists');
        }

        // Update existing records to have 'rpb' as analysis_type if null
        console.log('üîß [DB MIGRATION] Updating existing records...');
        try {
            const updateResult = await client.query(`
                UPDATE rpb_tracking 
                SET analysis_type = 'rpb' 
                WHERE analysis_type IS NULL OR analysis_type = ''
            `);
            console.log(`‚úÖ [DB MIGRATION] Updated ${updateResult.rowCount} records with analysis_type = 'rpb'`);
        } catch (e) {
            console.error('‚ùå [DB MIGRATION] Error updating records:', e.message);
            throw e;
        }

        // Make analysis_type NOT NULL after setting defaults
        console.log('üîß [DB MIGRATION] Setting analysis_type as NOT NULL...');
        try {
            await client.query(`
                ALTER TABLE rpb_tracking 
                ALTER COLUMN analysis_type SET NOT NULL
            `);
            console.log('‚úÖ [DB MIGRATION] analysis_type set as NOT NULL');
        } catch (e) {
            console.log('‚ÑπÔ∏è [DB MIGRATION] analysis_type may already be NOT NULL:', e.message);
        }

        // Handle unique constraint migration more carefully
        console.log('üîß [DB MIGRATION] Checking for existing constraints...');
        
        // First, let's see what constraints exist
        try {
            const constraintCheck = await client.query(`
                SELECT con.conname, con.contype
                FROM pg_constraint con
                JOIN pg_class rel ON rel.oid = con.conrelid
                WHERE rel.relname = 'rpb_tracking' AND con.contype = 'u'
            `);
            console.log('üìã [DB MIGRATION] Existing unique constraints:', constraintCheck.rows);
            
            // Drop any existing unique constraints on this table
            for (const constraint of constraintCheck.rows) {
                try {
                    await client.query(`ALTER TABLE rpb_tracking DROP CONSTRAINT IF EXISTS ${constraint.conname}`);
                    console.log(`‚úÖ [DB MIGRATION] Dropped constraint: ${constraint.conname}`);
                } catch (dropError) {
                    console.log(`‚ÑπÔ∏è [DB MIGRATION] Could not drop constraint ${constraint.conname}:`, dropError.message);
                }
            }
        } catch (e) {
            console.log('‚ÑπÔ∏è [DB MIGRATION] Error checking constraints:', e.message);
        }

        // Create new unique index with analysis_type
        console.log('üîß [DB MIGRATION] Creating new unique index...');
        
        // Verify analysis_type column exists before creating index
        const finalColumnCheck = await client.query(`
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'rpb_tracking' AND column_name = 'analysis_type'
        `);
        
        if (finalColumnCheck.rows.length > 0) {
            try {
                await client.query(`
                    CREATE UNIQUE INDEX IF NOT EXISTS rpb_tracking_event_log_analysis_unique 
                    ON rpb_tracking (event_id, log_url, analysis_type)
                `);
                console.log('‚úÖ [DB MIGRATION] New unique index created successfully');
            } catch (e) {
                console.error('‚ùå [DB MIGRATION] Error creating unique index:', e.message);
                // This might fail if there are duplicate records, which is okay for now
                console.log('‚ÑπÔ∏è [DB MIGRATION] Continuing despite index creation error...');
            }
        } else {
            console.error('‚ùå [DB MIGRATION] Cannot create index: analysis_type column does not exist!');
            throw new Error('analysis_type column was not created successfully');
        }
        
        // Create attendance_cache table for tracking weekly raid attendance
        await client.query(`
            CREATE TABLE IF NOT EXISTS attendance_cache (
                discord_id VARCHAR(255),
                discord_username VARCHAR(255),
                week_year INTEGER,
                week_number INTEGER,
                event_id VARCHAR(255),
                event_date DATE,
                channel_id VARCHAR(255),
                channel_name VARCHAR(255),
                character_name VARCHAR(255),
                character_class VARCHAR(50),
                player_streak INTEGER DEFAULT 0,
                cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (discord_id, week_year, week_number, event_id)
            )
        `);
        
        // Add player_streak column if it doesn't exist (for existing tables)
        await client.query(`
            ALTER TABLE attendance_cache 
            ADD COLUMN IF NOT EXISTS player_streak INTEGER DEFAULT 0
        `);
        
        // Create attendance_channel_filters table for filtering which channels to include
        await client.query(`
            CREATE TABLE IF NOT EXISTS attendance_channel_filters (
                channel_id VARCHAR(255) PRIMARY KEY,
                channel_name VARCHAR(255),
                is_included BOOLEAN DEFAULT true,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Create channel_backgrounds table for storing background images for each channel
        await client.query(`
            CREATE TABLE IF NOT EXISTS channel_backgrounds (
                channel_id VARCHAR(255) PRIMARY KEY,
                channel_name VARCHAR(255),
                background_image_url VARCHAR(500),
                cloudinary_public_id VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Add cloudinary_public_id column if it doesn't exist (for existing tables)
        await client.query(`
            ALTER TABLE channel_backgrounds 
            ADD COLUMN IF NOT EXISTS cloudinary_public_id VARCHAR(255)
        `);

        // Create manual_rewards_deductions table for storing manual rewards and deductions
        await client.query(`
            CREATE TABLE IF NOT EXISTS manual_rewards_deductions (
                id SERIAL PRIMARY KEY,
                event_id VARCHAR(255) NOT NULL,
                player_name VARCHAR(255) NOT NULL,
                player_class VARCHAR(50),
                discord_id VARCHAR(255),
                description TEXT NOT NULL,
                points DECIMAL(10,2) NOT NULL,
                created_by VARCHAR(255) NOT NULL,
                icon_url VARCHAR(500),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Add icon_url column to existing manual_rewards_deductions table if it doesn't exist
        try {
            await client.query(`
                ALTER TABLE manual_rewards_deductions 
                ADD COLUMN IF NOT EXISTS icon_url VARCHAR(500)
            `);
            console.log('‚úÖ [SETUP] Added icon_url column to manual_rewards_deductions (if missing)');
        } catch (error) {
            console.log('‚ö†Ô∏è [SETUP] icon_url column might already exist:', error.message);
        }

        // Create manual_rewards_deductions_templates table for storing template rewards
        await client.query(`
            CREATE TABLE IF NOT EXISTS manual_rewards_deductions_templates (
                id SERIAL PRIMARY KEY,
                description TEXT NOT NULL,
                points DECIMAL(10,2) NOT NULL,
                player_name VARCHAR(255),
                icon_url VARCHAR(500),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Insert default templates if they don't exist
        console.log('üîß [SETUP] Checking and inserting default templates...');
        const templatesCheck = await client.query('SELECT COUNT(*) FROM manual_rewards_deductions_templates');
        const templateCount = parseInt(templatesCheck.rows[0].count);
        
        if (templateCount === 0) {
            console.log('üìù [SETUP] Inserting default template data...');
            await client.query(`
                INSERT INTO manual_rewards_deductions_templates (description, points, player_name, icon_url) VALUES
                ('Main Tank', 100, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg'),
                ('Off Tank 1', 80, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg'),
                ('Off Tank 2', 50, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg'),
                ('Off Tank 3', 30, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg')
            `);
            console.log('‚úÖ [SETUP] Default templates inserted successfully!');
        } else {
            console.log(`üìã [SETUP] Found ${templateCount} existing templates, skipping insertion`);
        }
        
        // ---------------------------------------------------------------------
        // Rewards Snapshot tables (for locking and manual editing of panel data)
        // ---------------------------------------------------------------------
        await client.query(`
            CREATE TABLE IF NOT EXISTS rewards_snapshot_events (
                event_id VARCHAR(255) PRIMARY KEY,
                locked_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                locked_by_id VARCHAR(255),
                locked_by_name VARCHAR(255)
            )
        `);

        await client.query(`
            CREATE TABLE IF NOT EXISTS rewards_and_deductions_points (
                id SERIAL PRIMARY KEY,
                event_id VARCHAR(255) NOT NULL,
                panel_key VARCHAR(100) NOT NULL,
                panel_name VARCHAR(255) NOT NULL,
                discord_user_id VARCHAR(255),
                character_name VARCHAR(255) NOT NULL,
                character_class VARCHAR(50),
                ranking_number_original INTEGER,
                point_value_original DECIMAL(12,2) NOT NULL,
                point_value_edited DECIMAL(12,2),
                character_details_original TEXT,
                character_details_edited TEXT,
                primary_numeric_original DECIMAL(20,4),
                primary_numeric_edited DECIMAL(20,4),
                aux_json JSONB,
                edited_by_id VARCHAR(255),
                edited_by_name VARCHAR(255),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(event_id, panel_key, character_name, ranking_number_original)
            )
        `);

        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_rewards_points_event ON rewards_and_deductions_points (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_rewards_points_panel ON rewards_and_deductions_points (event_id, panel_key)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_rewards_points_discord ON rewards_and_deductions_points (discord_user_id)
        `);
        
        // Create indexes for attendance_cache
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_attendance_cache_discord_id ON attendance_cache (discord_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_attendance_cache_week ON attendance_cache (week_year, week_number)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_attendance_cache_event ON attendance_cache (event_id)
        `);
        
        // Create index for channel_backgrounds
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_channel_backgrounds_channel_name ON channel_backgrounds (channel_name)
        `);
        
        // Create indexes for manual_rewards_deductions
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_manual_rewards_event_id ON manual_rewards_deductions (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_manual_rewards_player ON manual_rewards_deductions (player_name, event_id)
        `);

        // Create indexes for manual_rewards_deductions_templates
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_templates_description ON manual_rewards_deductions_templates (description)
        `);
        
        // Create player_role_mapping table for comprehensive role tracking across multiple sources
        await client.query(`
            CREATE TABLE IF NOT EXISTS player_role_mapping (
                id SERIAL PRIMARY KEY,
                player_name VARCHAR(255) NOT NULL,
                character_class VARCHAR(50),
                discord_id VARCHAR(255),
                event_id VARCHAR(255) NOT NULL,
                warcraft_logs_role VARCHAR(50),
                raid_helper_role VARCHAR(50),
                managed_roster_role VARCHAR(50),
                warcraft_logs_role_event_1 VARCHAR(50),
                warcraft_logs_role_event_2 VARCHAR(50),
                warcraft_logs_role_event_3 VARCHAR(50),
                warcraft_logs_role_event_4 VARCHAR(50),
                warcraft_logs_role_event_5 VARCHAR(50),
                warcraft_logs_role_event_6 VARCHAR(50),
                warcraft_logs_role_event_7 VARCHAR(50),
                warcraft_logs_role_event_8 VARCHAR(50),
                warcraft_logs_role_event_9 VARCHAR(50),
                warcraft_logs_role_event_10 VARCHAR(50),
                warcraft_logs_role_event_11 VARCHAR(50),
                warcraft_logs_role_event_12 VARCHAR(50),
                warcraft_logs_role_event_13 VARCHAR(50),
                warcraft_logs_role_event_14 VARCHAR(50),
                warcraft_logs_role_event_15 VARCHAR(50),
                warcraft_logs_role_event_16 VARCHAR(50),
                warcraft_logs_role_event_17 VARCHAR(50),
                warcraft_logs_role_event_18 VARCHAR(50),
                warcraft_logs_role_event_19 VARCHAR(50),
                warcraft_logs_role_event_20 VARCHAR(50),
                primary_role VARCHAR(50),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(player_name, event_id)
            )
        `);
        
        // Add missing columns for existing tables (migration for events 6-20)
        console.log('üîÑ [SETUP] Adding missing event columns if they don\'t exist...');
        for (let i = 6; i <= 20; i++) {
            try {
                await client.query(`
                    ALTER TABLE player_role_mapping 
                    ADD COLUMN IF NOT EXISTS warcraft_logs_role_event_${i} VARCHAR(50)
                `);
                console.log(`‚úÖ [SETUP] Added column warcraft_logs_role_event_${i} (if missing)`);
            } catch (error) {
                console.log(`‚ö†Ô∏è [SETUP] Column warcraft_logs_role_event_${i} might already exist:`, error.message);
            }
        }
        
        // Add primary_role column if it doesn't exist
        try {
            await client.query(`
                ALTER TABLE player_role_mapping 
                ADD COLUMN IF NOT EXISTS primary_role VARCHAR(50)
            `);
            console.log(`‚úÖ [SETUP] Added primary_role column (if missing)`);
        } catch (error) {
            console.log(`‚ö†Ô∏è [SETUP] primary_role column might already exist:`, error.message);
        }
        
        // Create indexes for player_role_mapping
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_player_role_mapping_event_id ON player_role_mapping (event_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_player_role_mapping_discord_id ON player_role_mapping (discord_id)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_player_role_mapping_player_class ON player_role_mapping (player_name, character_class)
        `);
        
        // Create class_spec_mappings table for fast class/spec -> role/icon/color lookups
        await client.query(`
            CREATE TABLE IF NOT EXISTS class_spec_mappings (
                class_name VARCHAR(50) NOT NULL,
                spec_name VARCHAR(50) NOT NULL,
                role VARCHAR(20) NOT NULL,
                spec_icon_url TEXT,
                class_icon_url TEXT,
                class_color_hex VARCHAR(7),
                PRIMARY KEY (class_name, spec_name)
            )
        `);
        
        // Helpful indexes
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_class_spec_mappings_class ON class_spec_mappings (class_name)
        `);
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_class_spec_mappings_role ON class_spec_mappings (role)
        `);

        // Seed class/spec mapping data (idempotent upsert)
        await client.query(`
            INSERT INTO class_spec_mappings (class_name, spec_name, role, spec_icon_url, class_icon_url, class_color_hex) VALUES
            ('Warrior','Protection','tank','https://cdn.discordapp.com/emojis/580801859221192714.png','https://cdn.discordapp.com/emojis/579532030153588739.png','#C79C6E'),
            ('Warrior','Fury','dps','https://cdn.discordapp.com/emojis/637564445215948810.png','https://cdn.discordapp.com/emojis/579532030153588739.png','#C79C6E'),
            ('Warrior','Arms','dps','https://cdn.discordapp.com/emojis/637564445031399474.png','https://cdn.discordapp.com/emojis/579532030153588739.png','#C79C6E'),
            ('Rogue','Combat','dps','https://cdn.discordapp.com/emojis/637564352333086720.png','https://cdn.discordapp.com/emojis/579532030086217748.png','#FFF569'),
            ('Rogue','Assassination','dps','https://cdn.discordapp.com/emojis/637564351707873324.png','https://cdn.discordapp.com/emojis/579532030086217748.png','#FFF569'),
            ('Rogue','Subtlety','dps','https://cdn.discordapp.com/emojis/637564352169508892.png','https://cdn.discordapp.com/emojis/579532030086217748.png','#FFF569'),
            ('Hunter','Beastmastery','dps','https://cdn.discordapp.com/emojis/637564202021814277.png','https://cdn.discordapp.com/emojis/579532029880827924.png','#ABD473'),
            ('Hunter','Marksmanship','dps','https://cdn.discordapp.com/emojis/637564202084466708.png','https://cdn.discordapp.com/emojis/579532029880827924.png','#ABD473'),
            ('Hunter','Survival','dps','https://cdn.discordapp.com/emojis/637564202130866186.png','https://cdn.discordapp.com/emojis/579532029880827924.png','#ABD473'),
            ('Mage','Arcane','dps','https://cdn.discordapp.com/emojis/637564231545389056.png','https://cdn.discordapp.com/emojis/579532030161977355.png','#69CCF0'),
            ('Mage','Fire','dps','https://cdn.discordapp.com/emojis/637564231239073802.png','https://cdn.discordapp.com/emojis/579532030161977355.png','#69CCF0'),
            ('Mage','Frost','dps','https://cdn.discordapp.com/emojis/637564231469891594.png','https://cdn.discordapp.com/emojis/579532030161977355.png','#69CCF0'),
            ('Warlock','Affliction','dps','https://cdn.discordapp.com/emojis/637564406984867861.png','https://cdn.discordapp.com/emojis/579532029851336716.png','#9482C9'),
            ('Warlock','Demonology','dps','https://cdn.discordapp.com/emojis/637564407001513984.png','https://cdn.discordapp.com/emojis/579532029851336716.png','#9482C9'),
            ('Warlock','Destruction','dps','https://cdn.discordapp.com/emojis/637564406682877964.png','https://cdn.discordapp.com/emojis/579532029851336716.png','#9482C9'),
            ('Shaman','Restoration','healer','https://cdn.discordapp.com/emojis/637564379847458846.png','https://cdn.discordapp.com/emojis/579532030056857600.png','#0070DE'),
            ('Shaman','Elemental','dps','https://cdn.discordapp.com/emojis/637564379595931649.png','https://cdn.discordapp.com/emojis/579532030056857600.png','#0070DE'),
            ('Shaman','Enhancement','dps','https://cdn.discordapp.com/emojis/637564379772223489.png','https://cdn.discordapp.com/emojis/579532030056857600.png','#0070DE'),
            ('Paladin','Holy','healer','https://cdn.discordapp.com/emojis/637564297622454272.png','https://cdn.discordapp.com/emojis/579532029906124840.png','#F58CBA'),
            ('Paladin','Protection','tank','https://cdn.discordapp.com/emojis/637564297647489034.png','https://cdn.discordapp.com/emojis/579532029906124840.png','#F58CBA'),
            ('Paladin','Retribution','dps','https://cdn.discordapp.com/emojis/637564297953673216.png','https://cdn.discordapp.com/emojis/579532029906124840.png','#F58CBA'),
            ('Priest','Discipline','healer','https://cdn.discordapp.com/emojis/637564323442720768.png','https://cdn.discordapp.com/emojis/579532029901799437.png','#FFFFFF'),
            ('Priest','Holy','healer','https://cdn.discordapp.com/emojis/637564323530539019.png','https://cdn.discordapp.com/emojis/579532029901799437.png','#FFFFFF'),
            ('Priest','Shadow','dps','https://cdn.discordapp.com/emojis/637564323291725825.png','https://cdn.discordapp.com/emojis/579532029901799437.png','#FFFFFF'),
            ('Druid','Balance','dps','https://cdn.discordapp.com/emojis/637564171994529798.png','https://cdn.discordapp.com/emojis/579532029675438081.png','#FF7D0A'),
            ('Druid','Dreamstate','dps','https://cdn.discordapp.com/emojis/982381290663866468.png','https://cdn.discordapp.com/emojis/579532029675438081.png','#FF7D0A'),
            ('Druid','Feral','tank','https://cdn.discordapp.com/emojis/637564172061900820.png','https://cdn.discordapp.com/emojis/579532029675438081.png','#FF7D0A'),
            ('Druid','Restoration','healer','https://cdn.discordapp.com/emojis/637564172007112723.png','https://cdn.discordapp.com/emojis/579532029675438081.png','#FF7D0A')
            ON CONFLICT (class_name, spec_name) DO UPDATE SET 
                role = EXCLUDED.role,
                spec_icon_url = EXCLUDED.spec_icon_url,
                class_icon_url = EXCLUDED.class_icon_url,
                class_color_hex = EXCLUDED.class_color_hex
        `);
        
        res.json({ 
            success: true, 
            message: 'Database tables created successfully!' 
        });
        
    } catch (error) {
        console.error('Error setting up database:', error);
        console.error('Error stack:', error.stack);
        res.status(500).json({ 
            success: false, 
            message: 'Error setting up database', 
            error: error.message,
            stack: error.stack 
        });
    } finally {
        if (client) client.release();
    }
});

// Simple test endpoint
app.get('/api/test', (req, res) => {
    console.log('[TEST] Test endpoint called');
    res.json({ message: 'Test endpoint working', timestamp: new Date().toISOString() });
});

app.put('/api/test-put', (req, res) => {
    console.log('[TEST] PUT test endpoint called with body:', req.body);
    res.json({ message: 'PUT test endpoint working', body: req.body, timestamp: new Date().toISOString() });
});

// Debug endpoint to check database schema and data
app.get('/api/admin/debug-db', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        // Get table structure
        const schemaResult = await client.query(`
            SELECT column_name, data_type, is_nullable, column_default 
            FROM information_schema.columns 
            WHERE table_name = 'roster_overrides' 
            ORDER BY ordinal_position
        `);
        
        // Get sample data from roster_overrides
        const dataResult = await client.query('SELECT * FROM roster_overrides LIMIT 5');
        
        // Get sample data from players  
        const playersResult = await client.query('SELECT * FROM players LIMIT 5');
        
        res.json({
            success: true,
            schema: {
                roster_overrides_columns: schemaResult.rows,
                sample_roster_data: dataResult.rows,
                sample_players_data: playersResult.rows
            }
        });
        
    } catch (error) {
        console.error('Error debugging database:', error);
        res.status(500).json({ 
            success: false, 
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Class/Spec mapping viewer (Management only)
app.get('/api/admin/class-spec-mappings', async (req, res) => {
    if (!req.user) {
        return res.status(401).json({ success: false, message: 'Authentication required' });
    }
    const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ success: false, message: 'Management role required' });
    }

    let client;
    try {
        client = await pool.connect();
        const result = await client.query(`
            SELECT class_name, spec_name, role, spec_icon_url, class_icon_url, class_color_hex
            FROM class_spec_mappings
            ORDER BY class_name, spec_name
        `);
        res.json({ success: true, mappings: result.rows });
    } catch (error) {
        console.error('‚ùå [CLASS SPEC MAP] Error fetching mappings:', error);
        res.status(500).json({ success: false, message: 'Error fetching class/spec mappings' });
    } finally {
        if (client) client.release();
    }
});

// Cleanup endpoint to remove players without Discord IDs
app.post('/api/admin/cleanup-players', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        // First, check how many players have empty/null Discord IDs
        const countResult = await client.query(`
            SELECT COUNT(*) as count 
            FROM players 
            WHERE discord_id IS NULL OR discord_id = ''
        `);
        
        const countToDelete = parseInt(countResult.rows[0].count);
        
        if (countToDelete === 0) {
            return res.json({
                success: true,
                message: 'No players found with empty Discord IDs.',
                deletedCount: 0
            });
        }
        
        // Delete players without Discord IDs
        const deleteResult = await client.query(`
            DELETE FROM players 
            WHERE discord_id IS NULL OR discord_id = ''
        `);
        
        res.json({
            success: true,
            message: `Successfully removed ${deleteResult.rowCount} players without Discord IDs.`,
            deletedCount: deleteResult.rowCount
        });
        
    } catch (error) {
        console.error('Error cleaning up players:', error);
        res.status(500).json({
            success: false,
            message: 'Error cleaning up players',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

app.post('/api/admin/migrate-players', async (req, res) => {
    const fs = require('fs');
    const path = require('path');
    let client;
    
    try {
        // Read players.tsv file
        const tsvPath = path.join(__dirname, 'players.tsv');
        if (!fs.existsSync(tsvPath)) {
            return res.status(400).json({ 
                success: false, 
                message: 'players.tsv file not found' 
            });
        }
        
        const tsvContent = fs.readFileSync(tsvPath, 'utf8');
        const lines = tsvContent.split('\n');
        
        client = await pool.connect();
        let processedCount = 0;
        let errors = [];
        
        for (const line of lines) {
            if (line.trim() !== '') {
                const fields = line.split('\t');
                if (fields.length >= 3) {
                    const discordId = fields[0].trim();
                    const characterName = fields[1].trim();
                    const characterClass = fields[2].trim();
                    
                    if (characterName !== '' && characterClass !== '') {
                        try {
                            await client.query(`
                                INSERT INTO players (discord_id, character_name, class) 
                                VALUES ($1, $2, $3) 
                                ON CONFLICT (discord_id, character_name, class) DO NOTHING
                            `, [discordId, characterName, characterClass]);
                            processedCount++;
                        } catch (error) {
                            errors.push(`Error processing ${characterName}: ${error.message}`);
                        }
                    }
                }
            }
        }
        
        res.json({ 
            success: true, 
            message: `Migration completed! Processed ${processedCount} records.`,
            processedCount,
            errors: errors.length > 0 ? errors : undefined
        });
        
    } catch (error) {
        console.error('Error migrating players:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error migrating players', 
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// === CONFIRMED LOGS API ENDPOINTS ===

// Store confirmed player in logs
app.post('/api/confirmed-logs/:raidId/player', async (req, res) => {
    const { raidId } = req.params;
    const { discordId, characterName, characterClass } = req.body;
    
    console.log(`üìù [CONFIRM LOGS] Storing player: raidId=${raidId}, discordId=${discordId}, name=${characterName}, class=${characterClass}`);
    
    if (!discordId || !characterName || !characterClass) {
        console.error('‚ùå [CONFIRM LOGS] Missing required fields:', { raidId, discordId, characterName, characterClass });
        return res.status(400).json({ 
            success: false, 
            message: 'Missing required fields: discordId, characterName, characterClass' 
        });
    }
    
    let client;
    try {
        client = await pool.connect();
        console.log('‚úÖ [CONFIRM LOGS] Database connected');
        
        // First check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'player_confirmed_logs'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('üîß [CONFIRM LOGS] Table does not exist, creating...');
            await client.query(`
                CREATE TABLE player_confirmed_logs (
                    raid_id VARCHAR(255),
                    discord_id VARCHAR(255),
                    character_name VARCHAR(255),
                    character_class VARCHAR(50),
                    manually_matched BOOLEAN DEFAULT false,
                    confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (raid_id, discord_id, character_name)
                )
            `);
            console.log('‚úÖ [CONFIRM LOGS] Table created successfully');
        } else {
            // Check if manually_matched column exists, add it if not
            const columnCheck = await client.query(`
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name = 'player_confirmed_logs' 
                AND column_name = 'manually_matched'
            `);
            
            if (columnCheck.rows.length === 0) {
                console.log('üîß [CONFIRM LOGS] Adding manually_matched column...');
                await client.query(`
                    ALTER TABLE player_confirmed_logs 
                    ADD COLUMN manually_matched BOOLEAN DEFAULT false
                `);
                console.log('‚úÖ [CONFIRM LOGS] Column added successfully');
            }
        }
        
        // Insert or update the confirmed player (manual match)
        console.log(`üîß [DB MANUAL] About to insert/update manual match:`, {
            raidId, discordId, characterName, characterClass, manually_matched: true
        });
        
        // First check if this exact combination already exists
        const existingPlayer = await client.query(`
            SELECT * FROM player_confirmed_logs 
            WHERE raid_id = $1 AND discord_id = $2 AND character_name = $3
        `, [raidId, discordId, characterName]);
        
        let result;
        if (existingPlayer.rows.length > 0) {
            // Update existing record
            console.log(`üîÑ [DB MANUAL] Updating existing manual match for same character`);
            result = await client.query(`
                UPDATE player_confirmed_logs 
                SET character_class = $4, manually_matched = $5, confirmed_at = CURRENT_TIMESTAMP
                WHERE raid_id = $1 AND discord_id = $2 AND character_name = $3
                RETURNING *
            `, [raidId, discordId, characterName, characterClass, true]);
        } else {
            // Insert new record (allows multiple characters per Discord user)
            console.log(`‚ûï [DB MANUAL] Inserting new manual match (multiple chars per user allowed)`);
            try {
                result = await client.query(`
                    INSERT INTO player_confirmed_logs (raid_id, discord_id, character_name, character_class, manually_matched)
                    VALUES ($1, $2, $3, $4, $5)
                    RETURNING *
                `, [raidId, discordId, characterName, characterClass, true]);
            } catch (insertError) {
                if (insertError.code === '23505') { // Unique violation
                    console.log(`üîÑ [DB MANUAL] Constraint conflict - falling back to update existing record`);
                    result = await client.query(`
                        UPDATE player_confirmed_logs 
                        SET character_name = $3, character_class = $4, manually_matched = $5, confirmed_at = CURRENT_TIMESTAMP
                        WHERE raid_id = $1 AND discord_id = $2
                        RETURNING *
                    `, [raidId, discordId, characterName, characterClass, true]);
                } else {
                    throw insertError;
                }
            }
        }
        
        console.log(`‚úÖ [DB MANUAL] Manual match stored/updated:`, result.rows[0]);
        
        console.log('‚úÖ [CONFIRM LOGS] Player stored successfully:', result.rows[0]);
        res.json({ success: true, player: result.rows[0] });
        
    } catch (error) {
        console.error('‚ùå [CONFIRM LOGS] Error storing confirmed player:', error);
        console.error('‚ùå [CONFIRM LOGS] Error details:', {
            message: error.message,
            stack: error.stack,
            code: error.code,
            detail: error.detail
        });
        res.status(500).json({ 
            success: false, 
            message: 'Error storing confirmed player',
            error: error.message,
            detail: error.detail || 'No additional details'
        });
    } finally {
        if (client) client.release();
    }
});

// Get confirmed players for a raid
app.get('/api/confirmed-logs/:raidId/players', async (req, res) => {
    const { raidId } = req.params;
    const { manually_matched } = req.query;
    
    console.log(`üîç [CONFIRM LOGS] Getting confirmed players for raid: ${raidId}, manually_matched: ${manually_matched}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'player_confirmed_logs'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [CONFIRM LOGS] Table does not exist, returning empty array');
            return res.json({ success: true, data: [] });
        }
        
        // Build query based on manually_matched filter
        let query = `SELECT * FROM player_confirmed_logs WHERE raid_id = $1`;
        let params = [raidId];
        
        if (manually_matched === 'true') {
            query += ` AND manually_matched = true`;
        } else if (manually_matched === 'false') {
            query += ` AND manually_matched = false`;
        }
        
        query += ` ORDER BY confirmed_at DESC`;
        
        const result = await client.query(query, params);
        
        console.log(`‚úÖ [CONFIRM LOGS] Found ${result.rows.length} confirmed players for raid ${raidId}`);
        res.json({ success: true, data: result.rows });
        
    } catch (error) {
        console.error('‚ùå [CONFIRM LOGS] Error fetching confirmed players:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error fetching confirmed players',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Bulk store automatically matched players
app.post('/api/confirmed-logs/:raidId/players/bulk', async (req, res) => {
    const { raidId } = req.params;
    const { players } = req.body;
    
    console.log(`üìù [CONFIRM LOGS] Bulk storing ${players?.length || 0} auto-matched players for raid: ${raidId}`);
    
    if (!players || !Array.isArray(players) || players.length === 0) {
        return res.status(400).json({ 
            success: false, 
            message: 'Players array is required and must not be empty' 
        });
    }
    
    let client;
    try {
        client = await pool.connect();
        
        // Ensure table exists (same logic as before)
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'player_confirmed_logs'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('üîß [CONFIRM LOGS] Table does not exist, creating...');
            await client.query(`
                CREATE TABLE player_confirmed_logs (
                    raid_id VARCHAR(255),
                    discord_id VARCHAR(255),
                    character_name VARCHAR(255),
                    character_class VARCHAR(50),
                    manually_matched BOOLEAN DEFAULT false,
                    confirmed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (raid_id, discord_id, character_name)
                )
            `);
            console.log('‚úÖ [CONFIRM LOGS] Table created successfully');
        } else {
            // Check if manually_matched column exists
            const columnCheck = await client.query(`
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name = 'player_confirmed_logs' 
                AND column_name = 'manually_matched'
            `);
            
            if (columnCheck.rows.length === 0) {
                console.log('üîß [CONFIRM LOGS] Adding manually_matched column...');
                await client.query(`
                    ALTER TABLE player_confirmed_logs 
                    ADD COLUMN manually_matched BOOLEAN DEFAULT false
                `);
                console.log('‚úÖ [CONFIRM LOGS] Column added successfully');
            }
        }
        
        let insertedCount = 0;
        let updatedCount = 0;
        
        // Insert each player (automatically matched = false for manually_matched)
        for (const player of players) {
            const { discordId, characterName, characterClass } = player;
            
            if (!discordId || !characterName || !characterClass) {
                console.warn('‚ö†Ô∏è [CONFIRM LOGS] Skipping player with missing data:', player);
                continue;
            }
            
            console.log(`üîß [DB EXACT] About to insert/update exact match:`, {
                raidId, discordId, characterName, characterClass, manually_matched: false
            });
            
            // Check if this exact combination already exists
            const existingExact = await client.query(`
                SELECT * FROM player_confirmed_logs 
                WHERE raid_id = $1 AND discord_id = $2 AND character_name = $3
            `, [raidId, discordId, characterName]);
            
            let result;
            if (existingExact.rows.length > 0) {
                // Only update if it's not manually matched (preserve manual matches)
                if (!existingExact.rows[0].manually_matched) {
                    console.log(`üîÑ [DB EXACT] Updating existing automatic match`);
                    result = await client.query(`
                        UPDATE player_confirmed_logs 
                        SET character_class = $4, confirmed_at = CURRENT_TIMESTAMP
                        WHERE raid_id = $1 AND discord_id = $2 AND character_name = $3 AND manually_matched = false
                        RETURNING *
                    `, [raidId, discordId, characterName, characterClass]);
                } else {
                    console.log(`‚è≠Ô∏è [DB EXACT] Skipping update - manual match takes precedence`);
                    result = { rows: [existingExact.rows[0]] };
                }
            } else {
                // Insert new automatic match
                console.log(`‚ûï [DB EXACT] Inserting new automatic match`);
                try {
                    result = await client.query(`
                        INSERT INTO player_confirmed_logs (raid_id, discord_id, character_name, character_class, manually_matched)
                        VALUES ($1, $2, $3, $4, $5)
                        RETURNING *
                    `, [raidId, discordId, characterName, characterClass, false]);
                } catch (insertError) {
                    if (insertError.code === '23505') { // Unique violation - skip this exact match
                        console.log(`‚è≠Ô∏è [DB EXACT] Skipping exact match due to constraint conflict (manual match likely exists)`);
                        result = { rows: [] };
                    } else {
                        throw insertError;
                    }
                }
            }
            
            console.log(`‚úÖ [DB EXACT] Exact match result:`, result.rows[0]);
            
            if (result.rows.length > 0) {
                insertedCount++;
            }
        }
        
        console.log(`‚úÖ [CONFIRM LOGS] Bulk operation completed: ${insertedCount} players processed`);
        res.json({ 
            success: true, 
            message: `Processed ${insertedCount} automatically matched players`,
            inserted: insertedCount
        });
        
    } catch (error) {
        console.error('‚ùå [CONFIRM LOGS] Error bulk storing players:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error bulk storing players',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Clear confirmed players for a raid (reset functionality)
app.delete('/api/confirmed-logs/:raidId/players', async (req, res) => {
    const { raidId } = req.params;
    
    console.log(`üóëÔ∏è [CONFIRM LOGS] Clearing confirmed players for raid: ${raidId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(
            `DELETE FROM player_confirmed_logs WHERE raid_id = $1 RETURNING *`,
            [raidId]
        );
        
        console.log(`‚úÖ [CONFIRM LOGS] Cleared ${result.rows.length} confirmed players for raid ${raidId}`);
        res.json({ 
            success: true, 
            message: `Cleared ${result.rows.length} confirmed players`,
            data: result.rows
        });
        
    } catch (error) {
        console.error('‚ùå [CONFIRM LOGS] Error clearing confirmed players:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error clearing confirmed players',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get all confirmed players for the gold pot page
app.get('/api/confirmed-logs/:raidId/all-players', async (req, res) => {
    const { raidId } = req.params;
    
    console.log(`üèÜ [GOLD POT] Getting all confirmed players for raid: ${raidId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'player_confirmed_logs'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [GOLD POT] Table does not exist, returning empty array');
            return res.json({ success: true, data: [] });
        }
        
        const result = await client.query(
            `SELECT discord_id, character_name, character_class, manually_matched, confirmed_at 
             FROM player_confirmed_logs 
             WHERE raid_id = $1 
             ORDER BY character_class, character_name`,
            [raidId]
        );
        
        console.log(`‚úÖ [GOLD POT] Found ${result.rows.length} confirmed players for gold pot`);
        res.json({ success: true, data: result.rows });
        
    } catch (error) {
        console.error('‚ùå [GOLD POT] Error fetching confirmed players:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error fetching confirmed players for gold pot',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Store log data (damage and healing) for an event
app.post('/api/log-data/:eventId/store', async (req, res) => {
    const { eventId } = req.params;
    const { logData } = req.body;
    
    console.log(`üíæ [LOG DATA] Storing log data for event: ${eventId}`);
    console.log(`üíæ [LOG DATA] Received ${logData?.length || 0} player records`);
    
    let client;
    try {
        client = await pool.connect();
        
        // First, clear existing data for this event
        await client.query('DELETE FROM log_data WHERE event_id = $1', [eventId]);
        console.log(`üóëÔ∏è [LOG DATA] Cleared existing data for event: ${eventId}`);
        
        if (!logData || logData.length === 0) {
            return res.json({ success: true, message: 'No data to store' });
        }
        
        // Insert new data
        for (const player of logData) {
            await client.query(`
                INSERT INTO log_data (
                    event_id, character_name, character_class, discord_id, 
                    role_detected, role_source, spec_name, damage_amount, 
                    healing_amount, log_id
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                ON CONFLICT (event_id, character_name) 
                DO UPDATE SET
                    character_class = EXCLUDED.character_class,
                    discord_id = EXCLUDED.discord_id,
                    role_detected = EXCLUDED.role_detected,
                    role_source = EXCLUDED.role_source,
                    spec_name = EXCLUDED.spec_name,
                    damage_amount = EXCLUDED.damage_amount,
                    healing_amount = EXCLUDED.healing_amount,
                    log_id = EXCLUDED.log_id,
                    created_at = CURRENT_TIMESTAMP
            `, [
                eventId,
                player.characterName,
                player.characterClass,
                player.discordId,
                player.roleDetected,
                player.roleSource,
                player.specName,
                player.damageAmount || 0,
                player.healingAmount || 0,
                player.logId
            ]);
        }
        
        console.log(`‚úÖ [LOG DATA] Successfully stored ${logData.length} player records`);
        res.json({ 
            success: true, 
            message: `Stored log data for ${logData.length} players`,
            eventId: eventId
        });
        
    } catch (error) {
        console.error('‚ùå [LOG DATA] Error storing log data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error storing log data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Store player role mapping data for an event
app.post('/api/player-role-mapping/:eventId/store', async (req, res) => {
    const { eventId } = req.params;
    const { roleMappingData } = req.body;
    
    console.log(`üéØ [ROLE MAPPING] Storing role mapping for event: ${eventId}`);
    console.log(`üéØ [ROLE MAPPING] Received ${roleMappingData?.length || 0} role mapping records`);
    
    let client;
    try {
        client = await pool.connect();
        
        // First, clear existing data for this event
        await client.query('DELETE FROM player_role_mapping WHERE event_id = $1', [eventId]);
        console.log(`üóëÔ∏è [ROLE MAPPING] Cleared existing role mapping for event: ${eventId}`);
        
        if (!roleMappingData || roleMappingData.length === 0) {
            return res.json({ success: true, message: 'No role mapping data to store' });
        }
        
        // Insert new role mapping data
        for (const mapping of roleMappingData) {
            await client.query(`
                INSERT INTO player_role_mapping (
                    player_name, character_class, discord_id, event_id,
                    warcraft_logs_role, raid_helper_role, managed_roster_role,
                    warcraft_logs_role_event_1, warcraft_logs_role_event_2, warcraft_logs_role_event_3, 
                    warcraft_logs_role_event_4, warcraft_logs_role_event_5, warcraft_logs_role_event_6,
                    warcraft_logs_role_event_7, warcraft_logs_role_event_8, warcraft_logs_role_event_9,
                    warcraft_logs_role_event_10, warcraft_logs_role_event_11, warcraft_logs_role_event_12,
                    warcraft_logs_role_event_13, warcraft_logs_role_event_14, warcraft_logs_role_event_15,
                    warcraft_logs_role_event_16, warcraft_logs_role_event_17, warcraft_logs_role_event_18,
                    warcraft_logs_role_event_19, warcraft_logs_role_event_20, primary_role
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28)
                ON CONFLICT (player_name, event_id) 
                DO UPDATE SET
                    character_class = EXCLUDED.character_class,
                    discord_id = EXCLUDED.discord_id,
                    warcraft_logs_role = EXCLUDED.warcraft_logs_role,
                    raid_helper_role = EXCLUDED.raid_helper_role,
                    managed_roster_role = EXCLUDED.managed_roster_role,
                    warcraft_logs_role_event_1 = EXCLUDED.warcraft_logs_role_event_1,
                    warcraft_logs_role_event_2 = EXCLUDED.warcraft_logs_role_event_2,
                    warcraft_logs_role_event_3 = EXCLUDED.warcraft_logs_role_event_3,
                    warcraft_logs_role_event_4 = EXCLUDED.warcraft_logs_role_event_4,
                    warcraft_logs_role_event_5 = EXCLUDED.warcraft_logs_role_event_5,
                    warcraft_logs_role_event_6 = EXCLUDED.warcraft_logs_role_event_6,
                    warcraft_logs_role_event_7 = EXCLUDED.warcraft_logs_role_event_7,
                    warcraft_logs_role_event_8 = EXCLUDED.warcraft_logs_role_event_8,
                    warcraft_logs_role_event_9 = EXCLUDED.warcraft_logs_role_event_9,
                    warcraft_logs_role_event_10 = EXCLUDED.warcraft_logs_role_event_10,
                    warcraft_logs_role_event_11 = EXCLUDED.warcraft_logs_role_event_11,
                    warcraft_logs_role_event_12 = EXCLUDED.warcraft_logs_role_event_12,
                    warcraft_logs_role_event_13 = EXCLUDED.warcraft_logs_role_event_13,
                    warcraft_logs_role_event_14 = EXCLUDED.warcraft_logs_role_event_14,
                    warcraft_logs_role_event_15 = EXCLUDED.warcraft_logs_role_event_15,
                    warcraft_logs_role_event_16 = EXCLUDED.warcraft_logs_role_event_16,
                    warcraft_logs_role_event_17 = EXCLUDED.warcraft_logs_role_event_17,
                    warcraft_logs_role_event_18 = EXCLUDED.warcraft_logs_role_event_18,
                    warcraft_logs_role_event_19 = EXCLUDED.warcraft_logs_role_event_19,
                    warcraft_logs_role_event_20 = EXCLUDED.warcraft_logs_role_event_20,
                    primary_role = EXCLUDED.primary_role,
                    updated_at = CURRENT_TIMESTAMP
            `, [
                mapping.player_name,
                mapping.character_class,
                mapping.discord_id,
                eventId,
                mapping.warcraft_logs_role,
                mapping.raid_helper_role,
                mapping.managed_roster_role,
                mapping.warcraft_logs_role_event_1,
                mapping.warcraft_logs_role_event_2,
                mapping.warcraft_logs_role_event_3,
                mapping.warcraft_logs_role_event_4,
                mapping.warcraft_logs_role_event_5,
                mapping.warcraft_logs_role_event_6,
                mapping.warcraft_logs_role_event_7,
                mapping.warcraft_logs_role_event_8,
                mapping.warcraft_logs_role_event_9,
                mapping.warcraft_logs_role_event_10,
                mapping.warcraft_logs_role_event_11,
                mapping.warcraft_logs_role_event_12,
                mapping.warcraft_logs_role_event_13,
                mapping.warcraft_logs_role_event_14,
                mapping.warcraft_logs_role_event_15,
                mapping.warcraft_logs_role_event_16,
                mapping.warcraft_logs_role_event_17,
                mapping.warcraft_logs_role_event_18,
                mapping.warcraft_logs_role_event_19,
                mapping.warcraft_logs_role_event_20,
                mapping.primary_role
            ]);
        }
        
        console.log(`‚úÖ [ROLE MAPPING] Successfully stored ${roleMappingData.length} role mapping records`);
        res.json({ 
            success: true, 
            message: `Stored role mapping for ${roleMappingData.length} players`,
            eventId: eventId
        });
        
    } catch (error) {
        console.error('‚ùå [ROLE MAPPING] Error storing role mapping:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error storing role mapping data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Store raw endpoints JSON blobs for an event
app.post('/api/event-endpoints-json/:eventId', express.json({ limit: '10mb' }), async (req, res) => {
  const { eventId } = req.params;
  const { wclSummaryJson, eventRolesJson, fightsJson, realmsJson } = req.body || {};
  if (!eventId) return res.status(400).json({ success: false, message: 'Missing eventId' });
  try {
    await pool.query(`
      INSERT INTO event_endpoints_json (event_id, wcl_summary_json, event_roles_json, realms_json, fights_json, created_at, updated_at)
      VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
      ON CONFLICT (event_id)
      DO UPDATE SET 
        wcl_summary_json = COALESCE(EXCLUDED.wcl_summary_json, event_endpoints_json.wcl_summary_json),
        event_roles_json = COALESCE(EXCLUDED.event_roles_json, event_endpoints_json.event_roles_json),
        realms_json = COALESCE(EXCLUDED.realms_json, event_endpoints_json.realms_json),
        fights_json = COALESCE(EXCLUDED.fights_json, event_endpoints_json.fights_json),
        updated_at = NOW()
    `, [
      String(eventId),
      wclSummaryJson ? JSON.stringify(wclSummaryJson) : null,
      eventRolesJson ? JSON.stringify(eventRolesJson) : null,
      realmsJson ? JSON.stringify(realmsJson) : null,
      fightsJson ? JSON.stringify(fightsJson) : null
    ]);
    res.json({ success: true });
  } catch (err) {
    console.error('‚ùå [EVENT JSON STORE] Failed to upsert JSON blobs:', err);
    res.status(500).json({ success: false, message: 'Failed to store JSON', error: String(err && err.message ? err.message : err) });
  }
});

// Retrieve raw endpoints JSON blobs for an event
app.get('/api/event-endpoints-json/:eventId', async (req, res) => {
  const { eventId } = req.params;
  if (!eventId) return res.status(400).json({ success: false, message: 'Missing eventId' });
  try {
    const result = await pool.query(`
      SELECT event_id, wcl_summary_json, event_roles_json, realms_json, fights_json, created_at, updated_at
      FROM event_endpoints_json
      WHERE event_id = $1
    `, [String(eventId)]);
    if (result.rows.length === 0) return res.json({ success: true, data: null });
    res.json({ success: true, data: result.rows[0] });
  } catch (err) {
    console.error('‚ùå [EVENT JSON GET] Failed to retrieve JSON blobs:', err);
    res.status(500).json({ success: false, message: 'Failed to retrieve JSON', error: String(err && err.message ? err.message : err) });
  }
});

// Compute name -> realm mapping for an event from stored WCL JSON blobs (summary/fights)
app.get('/api/event-realms/:eventId', async (req, res) => {
  const { eventId } = req.params;
  if (!eventId) return res.status(400).json({ success: false, message: 'Missing eventId' });
  let client;
  try {
    client = await pool.connect();
    const r = await client.query(`
      SELECT wcl_summary_json, fights_json FROM event_endpoints_json WHERE event_id = $1
    `, [String(eventId)]);
    if (!r.rows.length) return res.json({ success: true, realms: {}, defaultRealm: null });
    const row = r.rows[0] || {};
    const wcl = row.wcl_summary_json || null;
    const fights = row.fights_json || null;

    const realms = new Map();
    const put = (name, realm) => {
      const n = String(name || '').trim();
      const rm = String(realm || '').trim();
      if (!n || !rm) return;
      const key = n.toLowerCase();
      if (!realms.has(key)) realms.set(key, rm);
    };
    const getRealm = (obj) => {
      if (!obj || typeof obj !== 'object') return '';
      if (typeof obj.server === 'string' && obj.server) return String(obj.server).trim();
      if (obj.server && typeof obj.server === 'object') {
        const cand = obj.server.name || obj.server.slug || obj.server.serverName || obj.server.realm || '';
        if (cand) return String(cand).trim();
      }
      const direct = obj.serverSlug || obj.serverName || obj.realm || obj.realmSlug || '';
      if (direct) return String(direct).trim();
      return '';
    };
    const collectFromArray = (arr) => {
      (arr || []).forEach(p => {
        const nm = String(p && (p.name || p.character_name || p.playerName || p.characterName) || '').trim();
        const rm = getRealm(p);
        if (nm && rm) put(nm, rm);
      });
    };
    // Summary composition arrays
    if (Array.isArray(wcl)) {
      collectFromArray(wcl);
    } else if (wcl && typeof wcl === 'object') {
      Object.values(wcl).forEach(ev => {
        const comp = (ev && (ev.summary && (ev.summary.composition || ev.summary.participants))) || ev && (ev.composition || ev.participants) || [];
        collectFromArray(comp);
      });
    }
    // Fights friendlies
    if (fights && Array.isArray(fights.friendlies)) collectFromArray(fights.friendlies);
    // Deep walk (in case fields are nested)
    const visit = (node) => {
      if (!node || typeof node !== 'object') return;
      const nm = String(node.name || node.playerName || node.characterName || '').trim();
      const rm = getRealm(node);
      if (nm && rm) put(nm, rm);
      if (Array.isArray(node)) { node.forEach(visit); return; }
      Object.values(node).forEach(visit);
    };
    if (wcl) visit(wcl);
    if (fights) visit(fights);

    // Fallback: if current event has few or no realms, try to backfill from recent events
    if (realms.size === 0) {
      try {
        const recent = await client.query(`
          SELECT wcl_summary_json, fights_json
          FROM event_endpoints_json
          WHERE event_id <> $1
          ORDER BY updated_at DESC NULLS LAST, created_at DESC NULLS LAST
          LIMIT 15
        `, [String(eventId)]);
        for (const rec of recent.rows || []) {
          const w = rec && rec.wcl_summary_json; const f = rec && rec.fights_json;
          if (Array.isArray(w)) collectFromArray(w);
          else if (w && typeof w === 'object') {
            Object.values(w).forEach(ev => {
              const comp = (ev && (ev.summary && (ev.summary.composition || ev.summary.participants))) || ev && (ev.composition || ev.participants) || [];
              collectFromArray(comp);
            });
          }
          if (f && Array.isArray(f.friendlies)) collectFromArray(f.friendlies);
          if (realms.size > 0) break; // we have some data
        }
      } catch (_) {}
    }

    // Default realm = most common realm in mapping
    let defaultRealm = null; let bestCnt = 0; const counts = new Map();
    realms.forEach((rm)=>{ const c=(counts.get(rm)||0)+1; counts.set(rm,c); if (c>bestCnt){ bestCnt=c; defaultRealm=rm; } });

    return res.json({ success: true, realms: Object.fromEntries(Array.from(realms.entries())), defaultRealm: defaultRealm || null });
  } catch (err) {
    console.error('‚ùå [/api/event-realms/:eventId] Failed to compute realms:', err);
    return res.status(500).json({ success: false, message: 'Failed to compute realms' });
  } finally {
    if (client) client.release();
  }
});

// Retrieve player role mapping data for an event
app.get('/api/player-role-mapping/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üéØ [ROLE MAPPING] Retrieving role mapping for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check which columns exist first to build a safe query
        const columnCheck = await client.query(`
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'player_role_mapping' 
            AND column_name LIKE 'warcraft_logs_role_event_%'
            ORDER BY column_name
        `);
        
        const existingEventColumns = columnCheck.rows.map(row => row.column_name);
        console.log(`üîç [ROLE MAPPING] Found existing event columns: ${existingEventColumns.join(', ')}`);
        
        // Build dynamic SELECT query with only existing columns
        const baseColumns = `
            player_name,
            character_class,
            discord_id,
            warcraft_logs_role,
            raid_helper_role,
            managed_roster_role,
            warcraft_logs_role_event_1,
            warcraft_logs_role_event_2,
            warcraft_logs_role_event_3,
            warcraft_logs_role_event_4,
            warcraft_logs_role_event_5,
            primary_role
        `;
        
        const additionalEventColumns = existingEventColumns
            .filter(col => !['warcraft_logs_role_event_1', 'warcraft_logs_role_event_2', 'warcraft_logs_role_event_3', 'warcraft_logs_role_event_4', 'warcraft_logs_role_event_5'].includes(col))
            .join(',\n                ');
        
        const allColumns = additionalEventColumns ? 
            `${baseColumns},\n                ${additionalEventColumns},\n                created_at,\n                updated_at` :
            `${baseColumns},\n                created_at,\n                updated_at`;
        
        console.log(`üéØ [ROLE MAPPING] Using columns: ${allColumns.replace(/\s+/g, ' ')}`);
        
        const result = await client.query(`
            SELECT ${allColumns}
            FROM player_role_mapping 
            WHERE event_id = $1
            ORDER BY player_name
        `, [eventId]);
        
        console.log(`üìñ [ROLE MAPPING] Found ${result.rows.length} role mapping records`);
        
        res.json({ 
            success: true, 
            data: result.rows,
            eventId: eventId,
            count: result.rows.length
        });
        
    } catch (error) {
        console.error('‚ùå [ROLE MAPPING] Error retrieving role mapping:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving role mapping data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get primary roles for an event (for filtering too-low performance panels)
app.get('/api/player-role-mapping/:eventId/primary-roles', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üéØ [PRIMARY ROLES] Fetching primary roles for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Get primary roles for all players in this event
        const result = await client.query(`
            SELECT 
                player_name,
                primary_role
            FROM player_role_mapping 
            WHERE event_id = $1 
            AND primary_role IS NOT NULL
            ORDER BY player_name
        `, [eventId]);
        
        // Convert to a map for easy lookup
        const primaryRoles = {};
        result.rows.forEach(row => {
            primaryRoles[row.player_name.toLowerCase()] = row.primary_role.toLowerCase();
        });
        
        console.log(`üìñ [PRIMARY ROLES] Found ${result.rows.length} players with primary roles`);
        
        res.json({ 
            success: true, 
            primaryRoles: primaryRoles,
            eventId: eventId,
            count: result.rows.length
        });
        
    } catch (error) {
        console.error('‚ùå [PRIMARY ROLES] Error fetching primary roles:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error fetching primary roles',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Void damage tracking endpoint (Void Blast and Void Zone)
app.get('/api/void-damage/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    let client;
    try {
        client = await pool.connect();
        
        // Query for void damage taken from specific abilities (robust matching and numeric parsing)
        const result = await client.query(`
            WITH parsed AS (
            SELECT 
                character_name,
                character_class,
                    LOWER(ability_name) AS ability_name_lc,
                    COALESCE(CAST(NULLIF(regexp_replace(ability_value, '[^0-9]', '', 'g'), '') AS INTEGER), 0) AS ability_value_int
            FROM sheet_player_abilities 
            WHERE event_id = $1 
                  AND (
                        ability_name ILIKE '%void blast%'
                     OR ability_name ILIKE '%shadow fissure%'
                     OR ability_name ILIKE '%void zone%'
                  )
            )
            SELECT 
                character_name,
                character_class,
                SUM(CASE WHEN ability_name_lc LIKE '%void blast%' OR ability_name_lc LIKE '%shadow fissure%' THEN ability_value_int ELSE 0 END) AS void_blast_damage,
                SUM(CASE WHEN ability_name_lc LIKE '%void zone%' THEN ability_value_int ELSE 0 END) AS void_zone_damage,
                SUM(ability_value_int) AS total_void_damage,
                COUNT(*) AS void_hits
            FROM parsed
            GROUP BY character_name, character_class
            ORDER BY total_void_damage DESC
        `, [eventId]);
        
        // Calculate points (-10 for Void Blast, -5 for Void Zone)
        const voidDamageData = result.rows.map(row => {
            const voidBlastDamage = parseInt(row.void_blast_damage) || 0;
            const voidZoneDamage = parseInt(row.void_zone_damage) || 0;
            
            let points = 0;
            if (voidBlastDamage > 0) points -= 10; // -10 for Void Blast
            if (voidZoneDamage > 0) points -= 5;   // -5 for Void Zone
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                void_blast_damage: voidBlastDamage,
                void_zone_damage: voidZoneDamage,
                total_void_damage: parseInt(row.total_void_damage) || 0,
                void_hits: parseInt(row.void_hits) || 0,
                points: points
            };
        });
        
        console.log(`üíú [VOID DAMAGE] Found ${voidDamageData.length} players who took void damage`);
        
        res.json({
            success: true,
            data: voidDamageData,
            settings: {
                void_blast_penalty: -10,
                void_zone_penalty: -5,
                abilities: ['Void Blast (Shadow Fissure)', 'Void Zone (Void Zone)']
            }
        });
        
    } catch (error) {
        console.error('‚ùå [VOID DAMAGE] Error fetching void damage data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error fetching void damage data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Helper function to map spec to role (matches frontend logic)
function mapSpecToRole(spec) {
    if (!spec) return 'unknown';
    
    const healingSpecs = ['Holy', 'Discipline', 'Restoration', 'Restoration1', 'Holy1'];
    const tankSpecs = ['Protection', 'Protection1', 'Guardian', 'Bear'];
    
    if (healingSpecs.includes(spec)) return 'healer';
    if (tankSpecs.includes(spec)) return 'tank';
    return 'dps';
}

// Retrieve stored log data for an event with roster override enhancements
app.get('/api/log-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üìñ [LOG DATA] Retrieving enhanced log data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'log_data'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [LOG DATA] Table does not exist, returning empty data');
            return res.json({ success: true, data: [], hasData: false });
        }
        
        // Enhanced query that joins with roster_overrides to get better role/spec data
        const result = await client.query(`
            SELECT 
                ld.character_name, 
                ld.character_class, 
                ld.discord_id, 
                ld.role_detected as original_role_detected,
                ld.role_source, 
                ld.spec_name as original_spec_name,
                ld.damage_amount, 
                ld.healing_amount, 
                ld.log_id, 
                ld.created_at,
                ro.assigned_char_spec as roster_spec,
                ro.assigned_char_spec_emote as roster_spec_emote
            FROM log_data ld
            LEFT JOIN roster_overrides ro ON (
                ld.event_id = ro.event_id AND 
                ld.discord_id = ro.discord_user_id
            )
            WHERE ld.event_id = $1 
            ORDER BY ld.damage_amount DESC, ld.healing_amount DESC
        `, [eventId]);
        
        const hasData = result.rows.length > 0;
        console.log(`üìä [LOG DATA] Found ${result.rows.length} player records for event: ${eventId}`);
        
        // Enhance the data with proper role detection
        const enhancedData = result.rows.map(row => {
            let finalRole = row.original_role_detected;
            let finalSpec = row.original_spec_name;
            
            // If we have roster override data, use that for role detection
            if (row.roster_spec) {
                finalRole = mapSpecToRole(row.roster_spec);
                finalSpec = row.roster_spec;
                console.log(`‚úÖ [ROLE OVERRIDE] ${row.character_name}: ${row.roster_spec} ‚Üí ${finalRole}`);
            }
            
            // Apply performance inference for players without any role detected
            if (!finalRole || finalRole === 'null' || finalRole === null) {
                const damage = parseInt(row.damage_amount) || 0;
                const healing = parseInt(row.healing_amount) || 0;
                
                // Simple threshold-based inference (can be refined later)
                if (damage > 1000000) { // 1M+ damage = likely DPS
                    finalRole = 'dps';
                    console.log(`‚öîÔ∏è [PERFORMANCE INFERENCE] ${row.character_name}: DPS (${damage} damage)`);
                } else if (healing > 500000) { // 500K+ healing = likely healer
                    finalRole = 'healer';
                    console.log(`‚ù§Ô∏è [PERFORMANCE INFERENCE] ${row.character_name}: Healer (${healing} healing)`);
                }
            }
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                discord_id: row.discord_id,
                role_detected: finalRole,
                role_source: row.roster_spec ? 'roster_override' : row.role_source,
                spec_name: finalSpec,
                damage_amount: row.damage_amount,
                healing_amount: row.healing_amount,
                log_id: row.log_id,
                created_at: row.created_at,
                roster_spec_emote: row.roster_spec_emote
            };
        });
        
        console.log(`üéØ [LOG DATA] Enhanced ${enhancedData.length} records with roster override data`);
        
        res.json({ 
            success: true, 
            data: enhancedData,
            hasData: hasData,
            eventId: eventId
        });
        
    } catch (error) {
        console.error('‚ùå [LOG DATA] Error retrieving log data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving log data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get last raid (by event) for a specific character using log_data + cached event metadata
app.get('/api/character/last-raid', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Authentication required' });
    }
    const { discordId, characterName, characterClass } = req.query;
    if (!discordId || !characterName || !characterClass) {
        return res.status(400).json({ success: false, message: 'discordId, characterName and characterClass are required' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure log_data exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'log_data'
            ) as exists;
        `);
        if (!tableCheck.rows[0].exists) {
            return res.json({ success: true, found: false });
        }

        const result = await client.query(`
            SELECT 
                ld.event_id,
                (ec.event_data->>'channelName') as channel_name,
                (ec.event_data->>'startTime')::bigint as start_time
            FROM log_data ld
            LEFT JOIN raid_helper_events_cache ec ON ec.event_id = ld.event_id
            WHERE LOWER(ld.character_name) = LOWER($1)
              AND LOWER(ld.character_class) = LOWER($2)
              AND ld.discord_id = $3
            ORDER BY COALESCE((ec.event_data->>'startTime')::bigint, 0) DESC, ld.created_at DESC
            LIMIT 1
        `, [characterName, characterClass, discordId]);

        if (result.rows.length === 0) {
            return res.json({ success: true, found: false });
        }

        const row = result.rows[0];
        return res.json({
            success: true,
            found: true,
            eventId: row.event_id,
            channelName: row.channel_name || null,
            startTime: row.start_time || null
        });
    } catch (error) {
        console.error('‚ùå [CHAR LAST RAID] Error:', error);
        return res.status(500).json({ success: false, message: 'Error fetching last raid for character' });
    } finally {
        if (client) client.release();
    }
});

// Get player streak data for raid logs
app.get('/api/player-streaks/:eventId', async (req, res) => {
  const { eventId } = req.params;
  console.log(`üî• [PLAYER STREAKS] Retrieving player streak data (local) for event: ${eventId}`);

  let client;
  try {
    client = await pool.connect();

    // Ensure log_data exists
    const logTableCheck = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'log_data'
      );
    `);
    if (!logTableCheck.rows[0].exists) {
      console.log('‚ö†Ô∏è [PLAYER STREAKS] log_data table missing');
      return res.json({ success: true, data: [] });
    }

    const parseEventDate = (dateStr) => {
      const parts = String(dateStr).split('-');
      if (parts.length !== 3) return null;
      const day = parseInt(parts[0]);
      const month = parseInt(parts[1]) - 1;
      const year = parseInt(parts[2]);
      if (isNaN(day) || isNaN(month) || isNaN(year)) return null;
      return new Date(year, month, day);
    };

    // Build 15-week window up to NOW (match /api/attendance behavior)
    const now = new Date();
    const currentWeekInfo = getCustomWeekNumber(now);
    const weeks = [];
    for (let i = 14; i >= 0; i--) {
      const d = new Date(now);
      d.setDate(d.getDate() - (i * 7));
      weeks.push(getCustomWeekNumber(d));
    }
    const allowedWeekKeys = new Set(weeks.map(w => `${w.weekYear}-${w.weekNumber}`));

    // Players in this event (resolve discord_id if missing by name/class)
    const eventRows = await client.query(`
      SELECT character_name, character_class, discord_id
      FROM log_data
      WHERE event_id = $1
    `, [eventId]);

    if (eventRows.rows.length === 0) {
      return res.json({ success: true, data: [] });
    }

    // Build resolvers (same approach as /api/attendance)
    const ldResolver = await client.query(`
      SELECT DISTINCT LOWER(character_name) AS name_lower,
                      LOWER(character_class) AS class_lower,
                      discord_id
      FROM log_data
      WHERE discord_id IS NOT NULL
    `);
    const nameClassToDiscord = new Map(ldResolver.rows.map(r => [`${r.name_lower}|${r.class_lower}`, String(r.discord_id)]));

    const playersResolver = await client.query(`
      SELECT LOWER(character_name) AS name_lower,
             LOWER(class) AS class_lower,
             discord_id
      FROM players
      WHERE discord_id IS NOT NULL
    `);
    const playersNameClassToDiscord = new Map();
    playersResolver.rows.forEach(r => {
      const key = `${r.name_lower}|${r.class_lower}`;
      const did = String(r.discord_id);
      if (!playersNameClassToDiscord.has(key)) playersNameClassToDiscord.set(key, did);
      else if (playersNameClassToDiscord.get(key) !== did) playersNameClassToDiscord.set(key, '__MULTI__');
    });

    // Roster mapping for this event (strongest signal)
    const rosterRes = await client.query(`
      SELECT LOWER(assigned_char_name) AS name_lower, discord_user_id
      FROM roster_overrides
      WHERE event_id = $1 AND discord_user_id IS NOT NULL AND assigned_char_name IS NOT NULL
    `, [eventId]);
    const rosterNameToDiscord = new Map(rosterRes.rows.map(r => [String(r.name_lower), String(r.discord_user_id)]));

    // Name-only unique resolvers (fallback when class mapping ambiguous/missing)
    const ldNameOnlyRes = await client.query(`
      SELECT LOWER(character_name) AS name_lower,
             ARRAY_AGG(DISTINCT discord_id) FILTER (WHERE discord_id IS NOT NULL) AS dids
      FROM log_data
      GROUP BY LOWER(character_name)
    `);
    const ldNameOnly = new Map();
    ldNameOnlyRes.rows.forEach(r => {
      const arr = Array.isArray(r.dids) ? r.dids.map(String).filter(Boolean) : [];
      if (arr.length === 1) ldNameOnly.set(String(r.name_lower), arr[0]);
    });
    const playersNameOnlyRes = await client.query(`
      SELECT LOWER(character_name) AS name_lower,
             ARRAY_AGG(DISTINCT discord_id) FILTER (WHERE discord_id IS NOT NULL) AS dids
      FROM players
      GROUP BY LOWER(character_name)
    `);
    const playersNameOnly = new Map();
    playersNameOnlyRes.rows.forEach(r => {
      const arr = Array.isArray(r.dids) ? r.dids.map(String).filter(Boolean) : [];
      if (arr.length === 1) playersNameOnly.set(String(r.name_lower), arr[0]);
    });

    // Pull all local log rows with cached event dates to compute attendance across window
    // Channel filters map
    const filtersResult = await client.query(`SELECT channel_id, is_included FROM attendance_channel_filters`);
    const channelFilterMap = new Map(filtersResult.rows.map(r => [String(r.channel_id), r.is_included]));

    const dataResult = await client.query(`
      SELECT ld.discord_id,
             ld.character_name,
             ld.character_class,
             (ec.event_data->>'date') as event_date,
             (ec.event_data->>'channelId') as channel_id
      FROM log_data ld
      LEFT JOIN raid_helper_events_cache ec ON ec.event_id = ld.event_id
      WHERE ec.event_data->>'date' IS NOT NULL
    `);

    const attendanceByPlayer = {}; // discord_id -> Set(weekKey)
    for (const row of dataResult.rows) {
      let did = row.discord_id ? String(row.discord_id) : null;
      if (!did) {
        const key = `${String(row.character_name||'').toLowerCase()}|${String(row.character_class||'').toLowerCase()}`;
        did = nameClassToDiscord.get(key) || null;
        if (!did) {
          const pDid = playersNameClassToDiscord.get(key);
          if (pDid && pDid !== '__MULTI__') did = pDid;
        }
      }
      if (!did) continue;
      const d = parseEventDate(row.event_date);
      if (!d) continue;
      const wk = getCustomWeekNumber(d);
      const wkKey = `${wk.weekYear}-${wk.weekNumber}`;
      if (!allowedWeekKeys.has(wkKey)) continue;
      // Apply channel filters to match attendance page
      const chId = row.channel_id ? String(row.channel_id) : null;
      if (chId && channelFilterMap.has(chId)) {
        const inc = channelFilterMap.get(chId);
        if (inc === false) continue;
      }
      if (!attendanceByPlayer[did]) attendanceByPlayer[did] = new Set();
      attendanceByPlayer[did].add(wkKey);
    }

    const computeStreak = (did) => {
      // Only allow skipping the current week; otherwise streak must be continuous
      const last = weeks.length - 1;
      const curKey = `${weeks[last].weekYear}-${weeks[last].weekNumber}`;
      const hasCur = !!(attendanceByPlayer[did] && attendanceByPlayer[did].has(curKey));
      let start = last;
      if (!hasCur) {
        // Allow skipping current week only; require attendance in previous week
        start = last - 1;
        if (start < 0) return 0;
        const prevKey = `${weeks[start].weekYear}-${weeks[start].weekNumber}`;
        const hasPrev = !!(attendanceByPlayer[did] && attendanceByPlayer[did].has(prevKey));
        if (!hasPrev) return 0;
      }
      let streak = 0;
      for (let i = start; i >= 0; i--) {
        const wkKey = `${weeks[i].weekYear}-${weeks[i].weekNumber}`;
        const has = attendanceByPlayer[did] && attendanceByPlayer[did].has(wkKey);
        if (has) streak++; else break;
      }
      return streak;
    };

    // Resolve participants for this event with a discord_id (direct or via name/class mapping)
    const participantsMap = new Map(); // did -> { character_name, character_class }
    for (const r of eventRows.rows) {
      let did = r.discord_id ? String(r.discord_id) : null;
      if (!did) {
        const nm = String(r.character_name||'').toLowerCase();
        const cls = String(r.character_class||'').toLowerCase();
        // 1) roster exact name
        did = rosterNameToDiscord.get(nm) || null;
        if (!did) {
          // 2) name+class from log_data
          const key = `${nm}|${cls}`;
          did = nameClassToDiscord.get(key) || null;
        }
        if (!did) {
          // 3) name+class from players
          const key = `${nm}|${cls}`;
          const pDid = playersNameClassToDiscord.get(key);
          if (pDid && pDid !== '__MULTI__') did = pDid;
        }
        if (!did) {
          // 4) name-only unique resolvers
          did = ldNameOnly.get(nm) || playersNameOnly.get(nm) || null;
        }
      }
      if (!did) continue;
      if (!participantsMap.has(did)) {
        participantsMap.set(did, { character_name: r.character_name, character_class: r.character_class });
      }
    }

    if (participantsMap.size === 0) {
      return res.json({ success: true, data: [], eventId, minStreak: 4, totalCount: 0 });
    }

    // Build response for resolved participants with streak >= 4
    const participants = Array.from(participantsMap.entries()).map(([did, info]) => {
      const s = computeStreak(did);
      return { character_name: info.character_name, character_class: info.character_class, discord_id: did, discord_username: `user-${did.slice(-4)}`, player_streak: s };
    }).filter(p => p.player_streak >= 4)
      .sort((a, b) => b.player_streak - a.player_streak || a.character_name.localeCompare(b.character_name));

    console.log(`üî• [PLAYER STREAKS] Found ${participants.length} players (streak >= 4) for event ${eventId}`);

    return res.json({
      success: true,
      data: participants,
      eventId: eventId,
      minStreak: 4,
      totalCount: participants.length
    });
  } catch (error) {
    console.error('‚ùå [PLAYER STREAKS] Error (local):', error);
    return res.status(500).json({ success: false, message: 'Error retrieving player streak data', error: error.message });
  } finally {
    if (client) client.release();
  }
});

// Get guild membership data for raid logs
app.get('/api/guild-members/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üè∞ [GUILD MEMBERS] Retrieving guild membership data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Ensure tables exist
        const tablesCheck = await client.query(`
            SELECT table_name FROM information_schema.tables WHERE table_name IN ('log_data','guildies')
        `);
        const have = new Set(tablesCheck.rows.map(r => r.table_name));
        if (!have.has('log_data') || !have.has('guildies')) {
            console.log('‚ö†Ô∏è [GUILD MEMBERS] required tables missing');
            return res.json({ success: true, data: [] });
        }
        
        // 1) All rows for this event (may lack discord_id)
        const eventRows = await client.query(`
            SELECT character_name, character_class, discord_id
            FROM log_data
            WHERE event_id = $1
        `, [eventId]);
        if (eventRows.rows.length === 0) {
            return res.json({ success: true, data: [], eventId, pointsPerMember: 10, totalCount: 0 });
        }

        // 2) Build resolvers similar to streaks
        const ldResolver = await client.query(`
            SELECT DISTINCT LOWER(character_name) AS name_lower,
                            LOWER(character_class) AS class_lower,
                            discord_id
            FROM log_data
            WHERE discord_id IS NOT NULL
        `);
        const nameClassToDiscord = new Map(ldResolver.rows.map(r => [`${r.name_lower}|${r.class_lower}`, String(r.discord_id)]));

        const playersResolver = await client.query(`
            SELECT LOWER(character_name) AS name_lower,
                   LOWER(class) AS class_lower,
                   discord_id
            FROM players
            WHERE discord_id IS NOT NULL
        `);
        const playersNameClassToDiscord = new Map();
        playersResolver.rows.forEach(r => {
            const key = `${r.name_lower}|${r.class_lower}`;
            const did = String(r.discord_id);
            if (!playersNameClassToDiscord.has(key)) playersNameClassToDiscord.set(key, did);
            else if (playersNameClassToDiscord.get(key) !== did) playersNameClassToDiscord.set(key, '__MULTI__');
        });

        const rosterRes = await client.query(`
            SELECT LOWER(assigned_char_name) AS name_lower, discord_user_id
            FROM roster_overrides
            WHERE event_id = $1 AND discord_user_id IS NOT NULL AND assigned_char_name IS NOT NULL
        `, [eventId]);
        const rosterNameToDiscord = new Map(rosterRes.rows.map(r => [String(r.name_lower), String(r.discord_user_id)]));

        const ldNameOnlyRes = await client.query(`
            SELECT LOWER(character_name) AS name_lower,
                   ARRAY_AGG(DISTINCT discord_id) FILTER (WHERE discord_id IS NOT NULL) AS dids
            FROM log_data
            GROUP BY LOWER(character_name)
        `);
        const ldNameOnly = new Map();
        ldNameOnlyRes.rows.forEach(r => {
            const arr = Array.isArray(r.dids) ? r.dids.map(String).filter(Boolean) : [];
            if (arr.length === 1) ldNameOnly.set(String(r.name_lower), arr[0]);
        });
        const playersNameOnlyRes = await client.query(`
            SELECT LOWER(character_name) AS name_lower,
                   ARRAY_AGG(DISTINCT discord_id) FILTER (WHERE discord_id IS NOT NULL) AS dids
            FROM players
            GROUP BY LOWER(character_name)
        `);
        const playersNameOnly = new Map();
        playersNameOnlyRes.rows.forEach(r => {
            const arr = Array.isArray(r.dids) ? r.dids.map(String).filter(Boolean) : [];
            if (arr.length === 1) playersNameOnly.set(String(r.name_lower), arr[0]);
        });

        // 3) Resolve participants to discord IDs
        const participantsMap = new Map(); // did -> { character_name, character_class }
        for (const r of eventRows.rows) {
            let did = r.discord_id ? String(r.discord_id) : null;
            if (!did) {
                const nm = String(r.character_name||'').toLowerCase();
                const cls = String(r.character_class||'').toLowerCase();
                did = rosterNameToDiscord.get(nm) || nameClassToDiscord.get(`${nm}|${cls}`) || null;
                if (!did) {
                    const pDid = playersNameClassToDiscord.get(`${nm}|${cls}`);
                    if (pDid && pDid !== '__MULTI__') did = pDid;
                }
                if (!did) did = ldNameOnly.get(nm) || playersNameOnly.get(nm) || null;
            }
            if (!did) continue;
            if (!participantsMap.has(did)) participantsMap.set(did, { character_name: r.character_name, character_class: r.character_class });
        }

        // Direct guild match by name+class (no Discord dependency)
        const directMatchesRes = await client.query(`
            SELECT ld.character_name, ld.character_class
            FROM log_data ld
            JOIN guildies g
              ON LOWER(ld.character_name) = LOWER(g.character_name)
             AND LOWER(ld.character_class) = LOWER(g.class)
            WHERE ld.event_id = $1
        `, [eventId]);
        const directSet = new Set(directMatchesRes.rows.map(r => `${String(r.character_name)}|${String(r.character_class)}`));

        if (participantsMap.size === 0 && directSet.size === 0) {
            return res.json({ success: true, data: [], eventId, pointsPerMember: 10, totalCount: 0 });
        }

        // 4) Intersect with guildies by discord_id (alts in guild)
        const dids = Array.from(participantsMap.keys());
        const guildRes = dids.length ? await client.query(`
            SELECT discord_id, character_name FROM guildies WHERE discord_id = ANY($1)
        `, [dids]) : { rows: [] };
        const guildSet = new Map((guildRes.rows||[]).map(r => [String(r.discord_id), r.character_name]));

        const out = [];
        const seen = new Set();
        // Add direct name+class matches first
        directMatchesRes.rows.forEach(r => {
            const key = `${String(r.character_name)}|${String(r.character_class)}`;
            if (seen.has(key)) return;
            seen.add(key);
            out.push({
                character_name: r.character_name,
                character_class: r.character_class,
                discord_id: null,
                guild_character_name: r.character_name,
                points: 10
            });
        });
        // Add discord-linked matches (covers alts in guild)
        dids.forEach(did => {
            if (!guildSet.has(did)) return;
            const info = participantsMap.get(did);
            if (!info) return;
            const key = `${String(info.character_name)}|${String(info.character_class)}`;
            if (seen.has(key)) return;
            seen.add(key);
            out.push({
                character_name: info.character_name,
                character_class: info.character_class,
                discord_id: did,
                guild_character_name: guildSet.get(did) || info.character_name,
                points: 10
            });
        });

        console.log(`üè∞ [GUILD MEMBERS] Found ${out.length} guild members in raid for event: ${eventId}`);
        
        res.json({ 
            success: true, 
            data: out,
            eventId,
            pointsPerMember: 10,
            totalCount: out.length
        });
        
    } catch (error) {
        console.error('‚ùå [GUILD MEMBERS] Error retrieving guild membership data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving guild membership data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get abilities data for raid logs (Sappers, Dynamite, Holy Water)
app.get('/api/abilities-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üí£ [ABILITIES] Retrieving abilities data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [ABILITIES] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Query for specific abilities: Dense Dynamite, Goblin Sapper Charge, Stratholme Holy Water
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name IN ('Dense Dynamite', 'Goblin Sapper Charge', 'Stratholme Holy Water')
            ORDER BY character_name, ability_name
        `, [eventId]);
        
        console.log(`üí£ [ABILITIES] Found ${result.rows.length} ability records for event: ${eventId}`);
        
        // Debug: Log the raw data
        console.log(`üí£ [ABILITIES] Raw data sample:`, result.rows.slice(0, 3));
        
        // Group by character and calculate points
        const characterData = {};
        
        result.rows.forEach(row => {
            const { character_name, character_class, ability_name, ability_value } = row;
            
            if (!characterData[character_name]) {
                characterData[character_name] = {
                    character_name,
                    character_class,
                    dense_dynamite: 0,
                    dense_dynamite_targets: 0,
                    goblin_sapper_charge: 0,
                    goblin_sapper_targets: 0,
                    stratholme_holy_water: 0,
                    stratholme_targets: 0,
                    total_used: 0,
                    total_targets_hit: 0,
                    points: 0
                };
            }
            
            // Parse the value format: "count (‚åÄavg_targets)" or just "count"
            const parseAbilityValue = (value) => {
                if (!value) return { count: 0, avgTargets: 0 };
                
                // Try to match format: "9 (‚åÄ5)" or "9 (avg5)" or "9"
                const match = value.toString().match(/^(\d+)(?:\s*\(.*?(\d+).*?\))?/);
                if (match) {
                    const count = parseInt(match[1]) || 0;
                    const avgTargets = parseInt(match[2]) || 0;
                    return { count, avgTargets };
                }
                
                // Fallback: try to extract just a number
                const numMatch = value.toString().match(/(\d+)/);
                return { count: numMatch ? parseInt(numMatch[1]) : 0, avgTargets: 0 };
            };
            
            const parsed = parseAbilityValue(ability_value);
            
            // Map ability names to our data structure
            switch (ability_name) {
                case 'Dense Dynamite':
                    characterData[character_name].dense_dynamite = parsed.count;
                    characterData[character_name].dense_dynamite_targets = parsed.avgTargets;
                    break;
                case 'Goblin Sapper Charge':
                    characterData[character_name].goblin_sapper_charge = parsed.count;
                    characterData[character_name].goblin_sapper_targets = parsed.avgTargets;
                    break;
                case 'Stratholme Holy Water':
                    characterData[character_name].stratholme_holy_water = parsed.count;
                    characterData[character_name].stratholme_targets = parsed.avgTargets;
                    break;
            }
        });
        
        // Get dynamic settings for all reward types
        const settingsResult = await client.query(`
            SELECT setting_type, setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type IN ('abilities', 'damage', 'healing', 'mana_potions', 'runes', 'interrupts', 'disarms', 'sunder', 'curse', 'curse_shadow', 'curse_elements', 'faerie_fire', 'scorch', 'demo_shout')
        `);
        
        const allSettings = {};
        settingsResult.rows.forEach(row => {
            if (!allSettings[row.setting_type]) {
                allSettings[row.setting_type] = {};
            }
            
            // Use JSON value if available, otherwise use numeric value
            let value;
            if (row.setting_json) {
                value = row.setting_json; // Already parsed by pg
            } else {
                value = parseFloat(row.setting_value);
            }
            
            allSettings[row.setting_type][row.setting_name] = value;
        });
        
        // Abilities settings
        const calculationDivisor = allSettings.abilities?.calculation_divisor || 10;
        const maxPoints = allSettings.abilities?.max_points || 20;
        
        // Damage and healing settings
        const damagePoints = allSettings.damage?.points_array || [80, 70, 55, 40, 35, 30, 25, 20, 15, 10, 8, 6, 5, 4, 3];
        const healingPoints = allSettings.healing?.points_array || [80, 65, 60, 55, 40, 35, 30, 20, 15, 10];
        
        console.log(`üí£ [ABILITIES] Using dynamic settings: divisor=${calculationDivisor}, max_points=${maxPoints}`);
        console.log(`üí• [DAMAGE] Using dynamic points array (${damagePoints.length} positions):`, damagePoints);
        console.log(`üíö [HEALING] Using dynamic points array (${healingPoints.length} positions):`, healingPoints);

        // Calculate final stats and points for each character
        const finalData = Object.values(characterData).map(char => {
            const totalUsed = char.dense_dynamite + char.goblin_sapper_charge + char.stratholme_holy_water;
            
            // Calculate weighted average targets hit
            let totalTargetsWeighted = 0;
            let weightedCount = 0;
            
            if (char.dense_dynamite > 0) {
                totalTargetsWeighted += char.dense_dynamite * char.dense_dynamite_targets;
                weightedCount += char.dense_dynamite;
            }
            if (char.goblin_sapper_charge > 0) {
                totalTargetsWeighted += char.goblin_sapper_charge * char.goblin_sapper_targets;
                weightedCount += char.goblin_sapper_charge;
            }
            if (char.stratholme_holy_water > 0) {
                totalTargetsWeighted += char.stratholme_holy_water * char.stratholme_targets;
                weightedCount += char.stratholme_holy_water;
            }
            
            const avgTargets = weightedCount > 0 ? totalTargetsWeighted / weightedCount : 0;
            const points = Math.min(maxPoints, Math.floor((totalUsed * avgTargets) / calculationDivisor));
            
            return {
                ...char,
                total_used: totalUsed,
                avg_targets_hit: avgTargets,
                points: points
            };
        }).filter(char => char.total_used > 0) // Only include characters who used at least one ability
          .sort((a, b) => b.points - a.points); // Sort by points descending
        
        console.log(`üí£ [ABILITIES] Processed ${finalData.length} characters with abilities usage`);
        console.log(`üí£ [ABILITIES] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                calculation_divisor: calculationDivisor,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [ABILITIES] Error retrieving abilities data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving abilities data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get shame data for Wall of Shame (deaths, avoidable damage, friendly damage)
app.get('/api/shame-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üíÄ [SHAME] Retrieving shame data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [SHAME] Table does not exist, returning empty data');
            return res.json({ success: true, data: {} });
        }
        
        // Query for shame-related abilities
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name IN (
                '# of deaths in total (just on trash)',
                'Total avoidable damage taken',
                'Damage to hostile players (counts as done to self)'
            )
            ORDER BY character_name, ability_name
        `, [eventId]);
        
        console.log(`üíÄ [SHAME] Found ${result.rows.length} shame records for event: ${eventId}`);
        
        // Process the results to find the worst performers
        const shameData = {};
        const deathsData = [];
        const avoidableDamageData = [];
        const friendlyDamageData = [];
        
        result.rows.forEach(row => {
            const { character_name, character_class, ability_name, ability_value } = row;
            
            switch (ability_name) {
                case '# of deaths in total (just on trash)':
                    // Parse format like "3 (1)" - total deaths (trash deaths)
                    const deathMatch = ability_value.toString().match(/^(\d+)(?:\s*\((\d+)\))?/);
                    if (deathMatch) {
                        const totalDeaths = parseInt(deathMatch[1]) || 0;
                        if (totalDeaths > 0) {
                            deathsData.push({
                                character_name,
                                character_class,
                                ability_value: ability_value.toString(),
                                total_deaths: totalDeaths
                            });
                        }
                    }
                    break;
                    
                case 'Total avoidable damage taken':
                    const avoidableDamage = parseInt(ability_value) || 0;
                    if (avoidableDamage > 0) {
                        avoidableDamageData.push({
                            character_name,
                            character_class,
                            ability_value: avoidableDamage
                        });
                    }
                    break;
                    
                case 'Damage to hostile players (counts as done to self)':
                    const friendlyDamage = parseInt(ability_value) || 0;
                    if (friendlyDamage > 0) {
                        friendlyDamageData.push({
                            character_name,
                            character_class,
                            ability_value: friendlyDamage
                        });
                    }
                    break;
            }
        });
        
        // Find the worst performers
        if (deathsData.length > 0) {
            shameData.most_deaths = deathsData.sort((a, b) => b.total_deaths - a.total_deaths)[0];
        }
        
        if (avoidableDamageData.length > 0) {
            shameData.most_avoidable_damage = avoidableDamageData.sort((a, b) => b.ability_value - a.ability_value)[0];
        }
        
        if (friendlyDamageData.length > 0) {
            shameData.most_friendly_damage = friendlyDamageData.sort((a, b) => b.ability_value - a.ability_value)[0];
        }
        
        console.log(`üíÄ [SHAME] Processed shame data:`, shameData);
        
        res.json({ 
            success: true, 
            data: shameData
        });
        
    } catch (error) {
        console.error('‚ùå [SHAME] Error retrieving shame data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving shame data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get world buffs data for raid logs
app.get('/api/world-buffs-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üåç [WORLD BUFFS] Retrieving world buffs data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // First, get the channel ID for this event to determine buff requirements
        let channelId = null;
        let isNaxChannel = false;
        try {
            const eventResult = await client.query(`
                SELECT event_data->>'channelId' as channel_id
                FROM raid_helper_events_cache 
                WHERE event_id = $1
            `, [eventId]);
            
            if (eventResult.rows.length > 0) {
                channelId = eventResult.rows[0].channel_id;
                console.log(`üåç [WORLD BUFFS] Found channel ID: ${channelId} for event: ${eventId}`);
                // Lookup channel flags
                try {
                    const cf = await client.query(`SELECT is_nax FROM channel_filters WHERE channel_id = $1`, [channelId]);
                    if (cf.rows.length > 0) {
                        isNaxChannel = !!cf.rows[0].is_nax;
                    }
                } catch (e) {
                    console.warn('üåç [WORLD BUFFS] channel_filters lookup failed or table missing:', e.message);
                }
            }
        } catch (err) {
            console.warn(`üåç [WORLD BUFFS] Could not determine channel ID for event ${eventId}:`, err.message);
        }
        
        // Required buffs rule per spec: 4 if not NAX, 6 if NAX (do not add DMF)
        let requiredBuffs = isNaxChannel ? 6 : 4;
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_players_buffs'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [WORLD BUFFS] Table does not exist, returning empty data');
            return res.json({ success: true, data: [], requiredBuffs });
        }
        
        // First get summary data per character (amount_summary should be the same for all buffs of a character)
        const summaryResult = await client.query(`
            SELECT DISTINCT ON (character_name)
                character_name,
                amount_summary,
                score_summary
            FROM sheet_players_buffs 
            WHERE event_id = $1 
            AND analysis_type = 'world_buffs'
            AND amount_summary IS NOT NULL
            ORDER BY character_name
        `, [eventId]);
        
        // Then get all buff details
        const buffsResult = await client.query(`
            SELECT 
                character_name,
                buff_name,
                buff_value,
                color_status,
                background_color
            FROM sheet_players_buffs 
            WHERE event_id = $1 
            AND analysis_type = 'world_buffs'
            ORDER BY character_name, buff_name
        `, [eventId]);
        
        // Debug: Log actual buff names to understand the data structure
        const uniqueBuffNames = [...new Set(buffsResult.rows.map(row => row.buff_name))];
        console.log(`üåç [WORLD BUFFS] Unique buff names in database:`, uniqueBuffNames);
        
        // Also get character class information from log_data if available
        const classResult = await client.query(`
            SELECT DISTINCT character_name, character_class
            FROM log_data
            WHERE event_id = $1
        `, [eventId]);
        
        console.log(`üåç [WORLD BUFFS] Found ${buffsResult.rows.length} buff records for event: ${eventId}`);
        console.log(`üåç [WORLD BUFFS] Found ${summaryResult.rows.length} characters with summary data for event: ${eventId}`);
        console.log(`üåç [WORLD BUFFS] Found ${classResult.rows.length} characters with class data (log_data) for event: ${eventId}`);
        
        // Create character class lookup
        const characterClasses = {};
        classResult.rows.forEach(row => {
            characterClasses[row.character_name] = row.character_class;
        });
        
        // Create character summary lookup
        const characterSummaries = {};
        summaryResult.rows.forEach(row => {
            characterSummaries[row.character_name] = {
                amount_summary: row.amount_summary,
                score_summary: row.score_summary
            };
        });
        
        // Group by character and calculate points
        const characterData = {};
        
        // Initialize characters from summary data - but only for characters who were in the raid (have log_data)
        summaryResult.rows.forEach(row => {
            const character_name = row.character_name;
            
            // Only include characters who actually participated in the raid
            if (characterClasses[character_name]) {
                characterData[character_name] = {
                    character_name,
                    character_class: characterClasses[character_name],
                    buffs: {},
                    total_buffs: 0,
                    missing_buffs: [],
                    amount_summary: row.amount_summary,
                    score_summary: row.score_summary,
                    points: 0
                };
            }
        });
        
        // Add buff details
        buffsResult.rows.forEach(row => {
            const { character_name, buff_name, buff_value, color_status, background_color } = row;
            
            // Only process if we have summary data for this character
            if (characterData[character_name]) {
                characterData[character_name].buffs[buff_name] = {
                    buff_value,
                    color_status,
                    background_color
                };
            }
        });
        
        // First pass: Check if DMF should be displayed as missing (10+ people must have it)
        let dmfCount = 0;
        Object.values(characterData).forEach(char => {
            if (char.buffs['DMF']) {
                dmfCount++;
            }
        });
        
        const includeDMF = dmfCount >= 10;
        
        console.log(`üåç [WORLD BUFFS] DMF count: ${dmfCount}, included in missing list: ${includeDMF}`);
        console.log(`üåç [WORLD BUFFS] Final required buffs: ${requiredBuffs} (isNax=${isNaxChannel})`);
        console.log(`üåç [WORLD BUFFS] Characters with DMF:`, Object.keys(characterData).filter(name => characterData[name].buffs['DMF']));
        
        // Calculate points and missing buffs for each character
        const finalData = Object.values(characterData).map(char => {
            // Extract current buffs from amount_summary (format: "6 / 6" or "5/ 6")
            let currentBuffs = 0;
            if (char.amount_summary) {
                const match = char.amount_summary.match(/^(\d+)/);
                if (match) {
                    currentBuffs = parseInt(match[1]) || 0;
                }
                // Log parsing for debugging
                if (currentBuffs === 0) {
                    console.log(`üåç [WORLD BUFFS] ${char.character_name}: amount_summary="${char.amount_summary}" -> parsed buffs=${currentBuffs}`);
                }
            } else {
                console.log(`üåç [WORLD BUFFS] ${char.character_name}: No amount_summary data`);
            }
            
            char.total_buffs = currentBuffs;
            
            // Calculate penalty points for missing buffs
            if (currentBuffs < requiredBuffs) {
                const missingCount = requiredBuffs - currentBuffs;
                char.points = missingCount * -10; // -10 points per missing buff
            } else {
                char.points = 0; // No penalty if they have enough buffs
            }
            
            // Debug: Show all buffs for this character
            console.log(`üåç [WORLD BUFFS] ${char.character_name} has buffs:`, Object.keys(char.buffs));
            
            // Determine missing buffs based on actual database buff names
            // Group related buffs together (DM Tribute has sub-buffs)
            let buffCategories = {
                'Ony': ['Nef/Ony'],
                'Rend': ['Rend'],
                'ZG': ['ZG heart'],
                'Songflower': ['Songflower'],
                'DM Tribute': ['Mol\'dar', 'Fengus', 'Slip\'kik']
            };
            
            // Only include DMF if 10+ people have it
            if (includeDMF) {
                buffCategories['DMF'] = ['DMF'];
            }
            
            char.missing_buffs = [];
            
            // Check each buff category
            for (const [categoryName, buffNames] of Object.entries(buffCategories)) {
                let hasAnyBuff = false;
                
                // Check if player has any buff from this category
                for (const buffName of buffNames) {
                    if (char.buffs[buffName]) {
                        hasAnyBuff = true;
                        break;
                    }
                }
                
                // If no buffs from this category, mark as missing
                if (!hasAnyBuff) {
                    char.missing_buffs.push(categoryName);
                }
            }
            
            console.log(`üåç [WORLD BUFFS] ${char.character_name} missing buffs:`, char.missing_buffs);
            
            return char;
        });
        
        // Final deduplication step (ensure no character appears twice)
        const uniqueCharacters = new Map();
        finalData.forEach(char => {
            if (!uniqueCharacters.has(char.character_name)) {
                uniqueCharacters.set(char.character_name, char);
            }
        });
        
        const uniqueFinalData = Array.from(uniqueCharacters.values());
        
        // Sort by points (least negative first, then by total buffs)
        uniqueFinalData.sort((a, b) => {
            if (b.points !== a.points) {
                return b.points - a.points; // Higher points first (less negative)
            }
            return b.total_buffs - a.total_buffs; // Then by total buffs
        });
        
        console.log(`üåç [WORLD BUFFS] Processed ${uniqueFinalData.length} characters with world buffs data (after deduplication)`);
        console.log(`üåç [WORLD BUFFS] Character names in final data:`, uniqueFinalData.map(c => c.character_name));
        console.log(`üåç [WORLD BUFFS] Final data sample:`, uniqueFinalData.slice(0, 2));
        console.log(`üåç [WORLD BUFFS] API Response - includeDMF: ${includeDMF}, requiredBuffs: ${requiredBuffs}`);
        
        res.json({ 
            success: true, 
            data: uniqueFinalData,
            eventId: eventId,
            requiredBuffs: requiredBuffs,
            channelId: channelId,
            includeDMF: includeDMF
        });
        
    } catch (error) {
        console.error('‚ùå [WORLD BUFFS] Error retrieving world buffs data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving world buffs data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get frost resistance data for raid logs
app.get('/api/frost-resistance-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üßä [FROST RESISTANCE] Retrieving frost resistance data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if frost resistance table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_players_frostres'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [FROST RESISTANCE] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get frost resistance data
        const frostResResult = await client.query(`
            SELECT 
                character_name,
                frost_resistance
            FROM sheet_players_frostres 
            WHERE event_id = $1 
            AND analysis_type = 'frost_resistance'
            ORDER BY character_name
        `, [eventId]);
        
        // Get character class and role information from log_data
        const logDataResult = await client.query(`
            SELECT DISTINCT 
                character_name, 
                character_class,
                role_detected
            FROM log_data
            WHERE event_id = $1
        `, [eventId]);
        
        console.log(`üßä [FROST RESISTANCE] Found ${frostResResult.rows.length} frost resistance records for event: ${eventId}`);
        console.log(`üßä [FROST RESISTANCE] Found ${logDataResult.rows.length} characters with role/class data for event: ${eventId}`);
        
        // Create lookup maps
        const characterData = {};
        logDataResult.rows.forEach(row => {
            characterData[row.character_name] = {
                character_class: row.character_class,
                role_detected: row.role_detected
            };
        });
        
        // Process frost resistance data
        const processedData = [];
        let maxFrostRes = 0;
        
        frostResResult.rows.forEach(row => {
            const characterName = row.character_name;
            const frostRes = parseInt(row.frost_resistance) || 0;
            const logData = characterData[characterName];
            
            // Skip if no log data (not in raid) or if tank/healer
            if (!logData || 
                logData.role_detected === 'tank' || 
                logData.role_detected === 'healer') {
                return;
            }
            
            // Only include DPS players
            if (logData.role_detected === 'dps') {
                const characterClass = logData.character_class?.toLowerCase();
                
                // Determine if physical or caster DPS
                const physicalClasses = ['warrior', 'rogue', 'hunter'];
                const casterClasses = ['mage', 'warlock', 'priest', 'shaman'];
                
                let dpsType = null;
                let points = 0;
                
                if (physicalClasses.includes(characterClass)) {
                    dpsType = 'physical';
                    if (frostRes < 80) {
                        points = -10;
                    } else if (frostRes < 130) {
                        points = -5;
                    }
                } else if (casterClasses.includes(characterClass)) {
                    dpsType = 'caster';
                    if (frostRes < 80) {
                        points = -10;
                    } else if (frostRes < 150) {
                        points = -5;
                    }
                }
                
                if (dpsType) {
                    maxFrostRes = Math.max(maxFrostRes, frostRes);
                    
                    processedData.push({
                        character_name: characterName,
                        character_class: logData.character_class,
                        role_detected: logData.role_detected,
                        frost_resistance: frostRes,
                        dps_type: dpsType,
                        points: points
                    });
                }
            }
        });
        
        // Add progress percentage for visual bars
        processedData.forEach(char => {
            char.progress_percentage = maxFrostRes > 0 ? Math.round((char.frost_resistance / maxFrostRes) * 100) : 0;
        });
        
        // Sort by points (highest first), then by frost resistance (highest first)
        processedData.sort((a, b) => {
            if (b.points !== a.points) {
                return b.points - a.points; // Higher points first (less negative)
            }
            return b.frost_resistance - a.frost_resistance; // Then by frost resistance
        });
        
        console.log(`üßä [FROST RESISTANCE] Processed ${processedData.length} DPS characters with frost resistance data`);
        console.log(`üßä [FROST RESISTANCE] Max frost resistance: ${maxFrostRes}`);
        console.log(`üßä [FROST RESISTANCE] Sample data:`, processedData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: processedData,
            eventId: eventId,
            maxFrostResistance: maxFrostRes
        });
        
    } catch (error) {
        console.error('‚ùå [FROST RESISTANCE] Error retrieving frost resistance data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving frost resistance data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get reward settings
app.get('/api/admin/reward-settings', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(`
            SELECT setting_type, setting_name, setting_value, setting_json, description
            FROM reward_settings 
            ORDER BY setting_type, setting_name
        `);
        
        // Group settings by type
        const settingsByType = {};
        result.rows.forEach(row => {
            if (!settingsByType[row.setting_type]) {
                settingsByType[row.setting_type] = {};
            }
            
            // Use JSON value if available, otherwise use numeric value
            let value;
            if (row.setting_json) {
                value = row.setting_json; // This will be parsed automatically by pg
            } else {
                value = parseFloat(row.setting_value);
            }
            
            settingsByType[row.setting_type][row.setting_name] = {
                value: value,
                description: row.description
            };
        });
        
        res.json({ 
            success: true, 
            settings: settingsByType
        });
        
    } catch (error) {
        console.error('‚ùå [REWARD SETTINGS] Error retrieving settings:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving reward settings',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Update reward settings
app.post('/api/admin/reward-settings', async (req, res) => {
    const { settings } = req.body;
    
    if (!settings) {
        return res.status(400).json({ 
            success: false, 
            message: 'Settings data is required' 
        });
    }
    
    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        
        console.log('üîß [REWARD SETTINGS] Updating settings:', JSON.stringify(settings, null, 2));
        
        // Update each setting
        for (const settingType of Object.keys(settings)) {
            for (const settingName of Object.keys(settings[settingType])) {
                const value = settings[settingType][settingName];
                
                console.log(`üîß [REWARD SETTINGS] Updating ${settingType}.${settingName}:`, value, 'Type:', typeof value, 'IsArray:', Array.isArray(value));
                
                // Determine if this is a JSON array or numeric value
                if (Array.isArray(value)) {
                    await client.query(`
                        UPDATE reward_settings 
                        SET setting_json = $1, setting_value = 0, updated_at = CURRENT_TIMESTAMP
                        WHERE setting_type = $2 AND setting_name = $3
                    `, [JSON.stringify(value), settingType, settingName]);
                } else {
                    await client.query(`
                        UPDATE reward_settings 
                        SET setting_value = $1, setting_json = NULL, updated_at = CURRENT_TIMESTAMP
                        WHERE setting_type = $2 AND setting_name = $3
                    `, [value, settingType, settingName]);
                }
            }
        }
        
        await client.query('COMMIT');
        console.log('‚úÖ [REWARD SETTINGS] Updated reward settings successfully');
        
        res.json({ 
            success: true, 
            message: 'Reward settings updated successfully'
        });
        
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('‚ùå [REWARD SETTINGS] Error updating settings:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error updating reward settings',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get mana potion data for raid logs
app.get('/api/mana-potions-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üß™ [MANA POTIONS] Retrieving mana potion data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [MANA POTIONS] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for mana potions calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'mana_potions'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const threshold = settings.threshold || 10;
        // New rule: 1 point per 3 potions above threshold, max 10
        const potionsPerPoint = 3;
        const maxPoints = settings.max_points || 10;
        
        console.log(`üß™ [MANA POTIONS] Using dynamic settings: threshold=${threshold}, potions_per_point=${potionsPerPoint}, max_points=${maxPoints}`);
        
        // Query for Major Mana Potion usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = 'Major Mana Potion'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`üß™ [MANA POTIONS] Found ${result.rows.length} potion records for event: ${eventId}`);
        console.log(`üß™ [MANA POTIONS] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the potion count (might be "15" or "15 (some text)")
            const potionMatch = row.ability_value.toString().match(/(\d+)/);
            const potionsUsed = potionMatch ? parseInt(potionMatch[1]) : 0;
            
            // Calculate points: 1 point per 3 potions above threshold (floor), capped at max
            const extraPotions = Math.max(0, potionsUsed - threshold);
            const points = Math.min(maxPoints, Math.floor(extraPotions / potionsPerPoint));
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                potions_used: potionsUsed,
                extra_potions: extraPotions,
                points: points
            };
        }).filter(char => char.potions_used > 0) // Only include characters who used potions
          .sort((a, b) => b.points - a.points); // Sort by points descending
        
        console.log(`üß™ [MANA POTIONS] Processed ${finalData.length} characters with potion usage`);
        console.log(`üß™ [MANA POTIONS] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                threshold: threshold,
                potions_per_point: potionsPerPoint,
                points_per_potion: potionsPerPoint,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [MANA POTIONS] Error retrieving mana potion data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving mana potion data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get runes data for raid logs
app.get('/api/runes-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üîÆ [RUNES] Retrieving runes data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [RUNES] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for runes calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'runes'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const usageDivisor = settings.usage_divisor || 2;
        const pointsPerDivision = settings.points_per_division || 1;
        const maxPoints = settings.max_points || 15;
        
        console.log(`üîÆ [RUNES] Using dynamic settings: usage_divisor=${usageDivisor}, points_per_division=${pointsPerDivision}`);
        
        // Query for Dark Rune and Demonic Rune usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND (ability_name = 'Dark Rune' OR ability_name = 'Demonic Rune' OR ability_name = 'Demonic Rune/Dark Rune')
            ORDER BY character_name, ability_name
        `, [eventId]);
        
        console.log(`üîÆ [RUNES] Found ${result.rows.length} rune records for event: ${eventId}`);
        console.log(`üîÆ [RUNES] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character (combine both rune types)
        const characterData = {};
        
        result.rows.forEach(row => {
            const characterName = row.character_name;
            
            if (!characterData[characterName]) {
                characterData[characterName] = {
                    character_name: row.character_name,
                    character_class: row.character_class,
                    dark_runes: 0,
                    demonic_runes: 0,
                    total_runes: 0
                };
            }
            
            // Parse the rune count (might be "5" or "5 (some text)")
            const runeMatch = row.ability_value.toString().match(/(\d+)/);
            const runesUsed = runeMatch ? parseInt(runeMatch[1]) : 0;
            
            if (row.ability_name === 'Dark Rune') {
                characterData[characterName].dark_runes = runesUsed;
            } else if (row.ability_name === 'Demonic Rune') {
                characterData[characterName].demonic_runes = runesUsed;
            } else if (row.ability_name === 'Demonic Rune/Dark Rune') {
                // Combined entry - add to total for both types
                characterData[characterName].dark_runes += runesUsed;
                characterData[characterName].demonic_runes += runesUsed;
            }
            
            characterData[characterName].total_runes = characterData[characterName].dark_runes + characterData[characterName].demonic_runes;
        });
        
        // Calculate points and convert to array
        const finalData = Object.values(characterData).map(char => {
            // Calculate points: floor(total_runes / divisor) * points_per_division, then clamp to max
            const rawPoints = Math.floor(char.total_runes / usageDivisor) * pointsPerDivision;
            const points = Math.min(maxPoints, rawPoints);
            
            return {
                ...char,
                points: points
            };
        }).filter(char => char.total_runes > 0) // Only include characters who used runes
          .sort((a, b) => b.points - a.points); // Sort by points descending
        
        console.log(`üîÆ [RUNES] Processed ${finalData.length} characters with rune usage`);
        console.log(`üîÆ [RUNES] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                usage_divisor: usageDivisor,
                points_per_division: pointsPerDivision,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [RUNES] Error retrieving runes data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving runes data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get interrupts data for raid logs
app.get('/api/interrupts-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`‚ö° [INTERRUPTS] Retrieving interrupts data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [INTERRUPTS] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for interrupts calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'interrupts'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const pointsPerInterrupt = 1; // fixed per new rule
        const interruptsNeeded = 2;   // 1 pt per 2 interrupts
        const maxPoints = settings.max_points || 5;
        
        console.log(`‚ö° [INTERRUPTS] Using dynamic settings: points_per_interrupt=${pointsPerInterrupt}, interrupts_needed=${interruptsNeeded}, max_points=${maxPoints}`);
        
        // Query for "# of interrupted spells" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = '# of interrupted spells'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`‚ö° [INTERRUPTS] Found ${result.rows.length} interrupt records for event: ${eventId}`);
        console.log(`‚ö° [INTERRUPTS] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the interrupt count (might be "3" or "3 (some text)")
            const interruptMatch = row.ability_value.toString().match(/(\d+)/);
            const interruptsUsed = interruptMatch ? parseInt(interruptMatch[1]) : 0;
            
            // Calculate points: min(max_points, floor(interrupts / needed) * points_per)
            const points = Math.min(maxPoints, Math.floor(interruptsUsed / interruptsNeeded) * pointsPerInterrupt);
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                interrupts_used: interruptsUsed,
                points: points
            };
        }).filter(char => char.interrupts_used > 0) // Only include characters who interrupted
          .sort((a, b) => b.points - a.points); // Sort by points descending
        
        console.log(`‚ö° [INTERRUPTS] Processed ${finalData.length} characters with interrupts`);
        console.log(`‚ö° [INTERRUPTS] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                points_per_interrupt: pointsPerInterrupt,
                interrupts_needed: interruptsNeeded,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [INTERRUPTS] Error retrieving interrupts data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving interrupts data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get disarms data for raid logs
app.get('/api/disarms-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üõ°Ô∏è [DISARMS] Retrieving disarms data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [DISARMS] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for disarms calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'disarms'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const pointsPerDisarm = 1; // fixed per new rule
        const disarmsNeeded = 3;   // 1 pt per 3 disarms
        const maxPoints = settings.max_points || 5;
        
        console.log(`üõ°Ô∏è [DISARMS] Using dynamic settings: points_per_disarm=${pointsPerDisarm}, disarms_needed=${disarmsNeeded}, max_points=${maxPoints}`);
        
        // Query for "Disarm" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = 'Disarm'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`üõ°Ô∏è [DISARMS] Found ${result.rows.length} disarm records for event: ${eventId}`);
        console.log(`üõ°Ô∏è [DISARMS] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the disarm count (might be "3" or "3 (some text)")
            const disarmMatch = row.ability_value.toString().match(/(\d+)/);
            const disarmsUsed = disarmMatch ? parseInt(disarmMatch[1]) : 0;
            
            // Calculate points: min(max_points, floor(disarms / needed) * points_per)
            const points = Math.min(maxPoints, Math.floor(disarmsUsed / disarmsNeeded) * pointsPerDisarm);
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                disarms_used: disarmsUsed,
                points: points
            };
        }).filter(char => char.disarms_used > 0) // Only include characters who disarmed
          .sort((a, b) => b.points - a.points); // Sort by points descending
        
        console.log(`üõ°Ô∏è [DISARMS] Processed ${finalData.length} characters with disarms`);
        console.log(`üõ°Ô∏è [DISARMS] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                points_per_disarm: pointsPerDisarm,
                disarms_needed: disarmsNeeded,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [DISARMS] Error retrieving disarms data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving disarms data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get Windfury Totem data for raid logs
app.get('/api/windfury-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üåÄ [WINDFURY] Retrieving Windfury Totem data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [WINDFURY] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for Windfury calculation
        // Defaults: threshold 10, 1 point per totem above threshold, max 10 points
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'windfury'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const threshold = Number.isFinite(settings.threshold) ? settings.threshold : 10;
        const pointsPerTotem = Number.isFinite(settings.points_per_totem) ? settings.points_per_totem : 1;
        const maxPoints = Number.isFinite(settings.max_points) ? settings.max_points : 10;
        
        console.log(`üåÄ [WINDFURY] Using settings: threshold=${threshold}, points_per_totem=${pointsPerTotem}, max_points=${maxPoints}`);
        
        // Query for Windfury, Tranquil Air, Grace of Air, and Strength of Earth Totem usage (per-type rows)
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name IN ('Windfury Totem', 'Tranquil Air Totem', 'Grace of Air Totem', 'Strength of Earth Totem')
            ORDER BY character_name, ability_name
        `, [eventId]);
        
        console.log(`üåÄ [WINDFURY] Found ${result.rows.length} Totem records for event: ${eventId}`);
        console.log(`üåÄ [WINDFURY] Raw data sample:`, result.rows.slice(0, 3));
        
        // Map rows to per-type entries
        const parseTotemsUsed = (abilityName, abilityValue) => {
            const raw = abilityValue != null ? abilityValue.toString() : '';
            const type = String(abilityName || '').toLowerCase();
            const tryLabels = (labels) => {
                for (const lbl of labels) {
                    // Match the first number following the label, allowing any separators
                    const re = new RegExp(`${lbl}[^0-9]*([0-9]+)`, 'i');
                    const m = raw.match(re);
                    if (m) return parseInt(m[1], 10);
                }
                return null;
            };
            if (type.includes('windfury')) {
                const v = tryLabels(['windfury', 'wf']);
                if (v != null) return v;
            } else if (type.includes('grace of air')) {
                const v = tryLabels(['grace of air', 'grace', 'goa']);
                if (v != null) return v;
            } else if (type.includes('strength of earth')) {
                const v = tryLabels(['strength of earth', 'strength', 'soe']);
                if (v != null) return v;
            } else if (type.includes('tranquil air')) {
                const v = tryLabels(['tranquil air', 'tranq', 'tranquil']);
                if (v != null) return v;
            }
            // Fallback: first number anywhere
            const m = raw.match(/(\d+)/);
            return m ? parseInt(m[1], 10) : 0;
        };

        const finalData = result.rows.map(row => {
            const totemsUsed = parseTotemsUsed(row.ability_name, row.ability_value);
            const extra = Math.max(0, totemsUsed - threshold);
            const points = Math.min(maxPoints, extra * pointsPerTotem);
            return {
                character_name: row.character_name,
                character_class: row.character_class || 'Shaman',
                totem_type: row.ability_name,
                totems_used: totemsUsed,
                extra_totems: extra,
                points: points
            };
        });
        
        console.log(`üåÄ [WINDFURY] Processed ${finalData.length} characters with Windfury Totem usage above threshold`);
        console.log(`üåÄ [WINDFURY] Final data sample:`, finalData.slice(0, 2));

        // --- Augment with group average of "# of extra Windfury Attacks" ---
        // Build roster name->party map for event
        const rosterRes = await client.query(`
            SELECT assigned_char_name, party_id
            FROM roster_overrides
            WHERE event_id = $1 AND assigned_char_name IS NOT NULL
        `, [eventId]);
        const nameToParty = new Map();
        const partyToMembers = new Map();
        for (const r of rosterRes.rows) {
            const key = String(r.assigned_char_name || '').toLowerCase();
            const partyId = r.party_id == null ? null : Number(r.party_id);
            if (!key) continue;
            nameToParty.set(key, partyId);
            if (!partyToMembers.has(partyId)) partyToMembers.set(partyId, []);
            partyToMembers.get(partyId).push(r.assigned_char_name);
        }

        // Fetch extra Windfury attacks per player (>10 only)
        const extraRes = await client.query(`
            SELECT character_name, character_class, ability_value
            FROM sheet_player_abilities
            WHERE event_id = $1
              AND ability_name = '# of extra Windfury Attacks'
        `, [eventId]);
        const extraMap = new Map(); // lowerName -> { value, classLower }
        for (const row of extraRes.rows) {
            const key = String(row.character_name || '').toLowerCase();
            if (!key) continue;
            let val = 0;
            if (row.ability_value != null) {
                const mm = row.ability_value.toString().match(/(\d+)/);
                val = mm ? parseInt(mm[1]) : 0;
            }
            if (val > 10) {
                const classLower = String(row.character_class || '').toLowerCase();
                extraMap.set(key, { value: val, classLower });
            }
        }

        // Attach group averages, totals, and member breakdown to each shaman entry
        for (const entry of finalData) {
            const shamKey = String(entry.character_name || '').toLowerCase();
            const partyId = nameToParty.get(shamKey);
            entry.party_id = partyId == null ? null : partyId;
            if (partyId == null) continue;
            const members = partyToMembers.get(partyId) || [];
            const considered = [];
            for (const name of members) {
                const key = String(name || '').toLowerCase();
                if (extraMap.has(key)) {
                    const rec = extraMap.get(key);
                    considered.push({ character_name: name, extra_attacks: rec.value, character_class: rec.classLower, included_in_avg: false });
                }
            }
            // Determine warrior max extra attacks within party
            const warriors = considered.filter(m => String(m.character_class||'').includes('warrior'));
            const maxWarrior = warriors.length > 0 ? Math.max(...warriors.map(m => Number(m.extra_attacks)||0)) : null;
            // Include only warriors with >= 50% of max warrior
            if (maxWarrior != null && Number.isFinite(maxWarrior)) {
                const cutoff = Math.ceil(maxWarrior * 0.5);
                for (const m of considered) {
                    const isWarrior = String(m.character_class||'').includes('warrior');
                    m.included_in_avg = !!(isWarrior && (Number(m.extra_attacks)||0) >= cutoff);
                }
            } else {
                // No warriors with data => no one included
                for (const m of considered) { m.included_in_avg = false; }
            }
            const included = considered.filter(m => m.included_in_avg);
            if (included.length > 0) {
                const sum = included.reduce((s, m) => s + (Number(m.extra_attacks) || 0), 0);
                const avg = Math.round(sum / included.length);
                entry.group_attacks_avg = avg;
                entry.group_attacks_total = sum;
                entry.group_attacks_members = considered.sort((a,b)=> (b.extra_attacks - a.extra_attacks) || String(a.character_name).localeCompare(String(b.character_name)));
            } else {
                entry.group_attacks_avg = null;
                entry.group_attacks_total = null;
                entry.group_attacks_members = [];
            }
        }

        // Compute baseline: average of each character's average extra attacks (use Windfury Totem entries with a valid group avg)
        // Tank group (party 1) contributes at half weight since they have halved requirements
        const wfAverages = finalData
            .filter(e => String(e.totem_type).toLowerCase().includes('windfury') && Number.isFinite(e.group_attacks_avg))
            .map(e => {
                const avg = Number(e.group_attacks_avg);
                // Tank group (party 1) has 75% of the normal requirement, so contribute at 0.75 weight to baseline
                return (e.party_id === 1 || String(e.party_id) === '1') ? (avg * 0.75) : avg;
            });
        const baseline = wfAverages.length > 0 ? (wfAverages.reduce((s, v) => s + v, 0) / wfAverages.length) : 0;
        console.log(`üåÄ [WINDFURY] Baseline average extra attacks: ${baseline}`);

        // Recalculate points based on baseline tiers
        // Windfury Totem:
        //   < 75% baseline => 0
        //   75% .. 99% baseline (inclusive) => 10
        //   100% .. 125% baseline (inclusive) => 15
        //   > 125% baseline => 20
        // Grace of Air Totem:
        //   Eligible only if totems_used >= 10 AND group_avg >= 75% baseline
        //   Points = floor(totems_used / 10), capped at 20
        // Strength of Earth Totem:
        //   Eligible only if totems_used >= 10 AND group_avg >= 75% baseline
        //   Points = floor(totems_used / 10), capped at 10
        for (const entry of finalData) {
            const avg = Number(entry.group_attacks_avg || 0);
            const typeLower = String(entry.totem_type || '').toLowerCase();
            if (typeLower.includes('windfury')) {
                if (!baseline || avg <= 0) { entry.points = 0; continue; }
                // Tank group has 75% requirement: scale avg by 1/0.75 for fair bracket comparison
                const effAvg = (entry.party_id === 1 || String(entry.party_id) === '1') ? (avg * 1.3333333333) : avg;
                const pct = effAvg / baseline;
                if (pct < 0.75) entry.points = 0;
                else if (pct <= 0.99) entry.points = 10;
                else if (pct <= 1.25) entry.points = 15;
                else entry.points = 20;
            } else if (typeLower.includes('grace of air')) {
                const effAvg = (entry.party_id === 1 || String(entry.party_id) === '1') ? (avg * 1.3333333333) : avg;
                if (!baseline || effAvg < baseline * 0.75 || Number(entry.totems_used || 0) < 10) { entry.points = 0; continue; }
                const pts = Math.min(20, Math.floor(Number(entry.totems_used) / 10));
                entry.points = pts;
            } else if (typeLower.includes('strength of earth')) {
                const effAvg = (entry.party_id === 1 || String(entry.party_id) === '1') ? (avg * 1.3333333333) : avg;
                if (!baseline || effAvg < baseline * 0.75 || Number(entry.totems_used || 0) < 10) { entry.points = 0; continue; }
                const pts = Math.min(10, Math.floor(Number(entry.totems_used) / 10));
                entry.points = pts;
            } else if (typeLower.includes('tranquil air')) {
                // Tranquil Air: 1 point per 10 totems, max 5; independent of baseline/avg
                const pts = Math.min(5, Math.floor(Number(entry.totems_used || 0) / 10));
                entry.points = pts;
            } else {
                entry.points = Number(entry.points) || 0;
            }
        }
        
        // Apply visibility filters and sort AFTER recalculation
        // RELAXED FILTERING: Show all totems that meet minimum usage thresholds
        // This allows admin to see all data for publishing, even if points are 0
        const filteredData = finalData.filter(entry => {
            const typeLower = String(entry.totem_type || '').toLowerCase();
            if (typeLower.includes('windfury')) {
                // Show Windfury rows when we have usable extra-attack data
                return Number.isFinite(entry.group_attacks_avg) && Number(entry.group_attacks_avg) > 0;
            }
            if (typeLower.includes('grace of air') || typeLower.includes('strength of earth') || typeLower.includes('tranquil air')) {
                // Show if they placed at least 10 totems (regardless of points earned)
                // This ensures all totem types are visible for admin review and publishing
                return Number(entry.totems_used || 0) >= 10;
            }
            return true; // Show all other types
        }).sort((a, b) => {
            const aType = String(a.totem_type || '').toLowerCase();
            const bType = String(b.totem_type || '').toLowerCase();
            const aIsWf = aType.includes('windfury');
            const bIsWf = bType.includes('windfury');
            // For Windfury totems, sort by extra attacks first, then by points
            if (aIsWf && bIsWf) {
                const byAvg = (Number(b.group_attacks_avg || 0) - Number(a.group_attacks_avg || 0));
                if (byAvg !== 0) return byAvg;
            }
            // For all totem types, sort by points, then by totems used
            const byPts = (Number(b.points || 0) - Number(a.points || 0));
            if (byPts !== 0) return byPts;
            const byTot = (Number(b.totems_used || 0) - Number(a.totems_used || 0));
            if (byTot !== 0) return byTot;
            return String(a.character_name || '').localeCompare(String(b.character_name || ''));
        });
        
        res.json({ 
            success: true, 
            data: filteredData,
            eventId: eventId,
            settings: {
                threshold,
                points_per_totem: pointsPerTotem,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [WINDFURY] Error retrieving Windfury Totem data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving Windfury Totem data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get all reward settings for raid logs page
app.get('/api/reward-settings', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(`
            SELECT setting_type, setting_name, setting_value, setting_json
            FROM reward_settings 
            ORDER BY setting_type, setting_name
        `);
        
        // Group settings by type
        const settingsByType = {};
        result.rows.forEach(row => {
            if (!settingsByType[row.setting_type]) {
                settingsByType[row.setting_type] = {};
            }
            
            // Use JSON value if available, otherwise use numeric value
            let value;
            if (row.setting_json) {
                value = row.setting_json; // Already parsed by pg
            } else {
                value = parseFloat(row.setting_value);
            }
            
            settingsByType[row.setting_type][row.setting_name] = value;
        });
        
        res.json({ 
            success: true, 
            settings: settingsByType
        });
        
    } catch (error) {
        console.error('‚ùå [REWARD SETTINGS] Error retrieving settings:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving reward settings',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Search players from database (similar to roster functionality)
app.get('/api/search-players', async (req, res) => {
    const { query } = req.query;
    
    if (!query || query.length < 2) {
        return res.json([]);
    }
    
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(`
            SELECT DISTINCT discord_id, character_name, class
            FROM players 
            WHERE LOWER(character_name) LIKE LOWER($1)
            ORDER BY character_name
            LIMIT 20
        `, [`%${query}%`]);
        
        res.json(result.rows);
        
    } catch (error) {
        console.error('Error searching players:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error searching players',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Add new character to database (similar to roster functionality)
app.post('/api/add-character', async (req, res) => {
    const { discordId, characterName, characterClass } = req.body;
    
    if (!discordId || !characterName || !characterClass) {
        return res.status(400).json({ 
            success: false, 
            message: 'Missing required fields: discordId, characterName, characterClass' 
        });
    }
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if character already exists for this discord user
        // With the new PRIMARY KEY (discord_id, character_name, class), the database will prevent duplicates
        // But we check here first to provide a user-friendly error message
        const existingPlayer = await client.query(
            'SELECT discord_id FROM players WHERE discord_id = $1 AND LOWER(character_name) = LOWER($2) AND LOWER(class) = LOWER($3)',
            [discordId, characterName, characterClass]
        );
        
        if (existingPlayer.rows.length > 0) {
            return res.status(409).json({ 
                success: false, 
                message: `You already have a character named "${characterName}" with class "${characterClass}". You can have multiple characters with the same name but different classes.`,
                existingDiscordId: existingPlayer.rows[0].discord_id
            });
        }
        
        // Insert new character
        await client.query(
            'INSERT INTO players (discord_id, character_name, class) VALUES ($1, $2, $3)',
            [discordId, characterName, characterClass]
        );
        
        res.json({ success: true });
        
    } catch (error) {
        console.error('Error adding character:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error adding character',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Raid-Helper API proxy endpoint for CORS with caching
app.get('/api/raid-helper/events/:eventId', async (req, res) => {
    const { eventId } = req.params;
    const forceRefresh = req.query.refresh === 'true';
    
    try {
        // Try cache first (unless force refresh requested)
        if (!forceRefresh) {
            const cachedData = await getCachedRaidHelperEvent(eventId);
            if (cachedData) {
                console.log(`üì¶ [CACHE] Serving cached data for event: ${eventId}`);
                return res.json(cachedData);
            }
        }
        
        console.log(`üîÑ Fetching fresh Raid-Helper data for event: ${eventId}`);
        
        const response = await axios.get(`https://raid-helper.dev/api/v2/events/${eventId}`, {
            timeout: 10000,
            headers: { 
                'Authorization': process.env.RAID_HELPER_API_KEY,
                'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
            }
        });
        
        // Cache the fresh data
        await setCachedRaidHelperEvent(eventId, response.data);
        
        console.log(`‚úÖ Raid-Helper data fetched and cached for event: ${eventId}`);
        res.json(response.data);
        
    } catch (error) {
        console.error(`‚ùå Failed to fetch Raid-Helper data for event ${eventId}:`, error.message);
        
        // Fallback to stale cache if API fails (up to 7 days old)
        if (!forceRefresh) {
            const staleCache = await getCachedRaidHelperEvent(eventId, 24 * 7); // 7 days
            if (staleCache) {
                console.log(`üîÑ [FALLBACK] Using stale cache for event ${eventId} due to API failure`);
                return res.json(staleCache);
            }
        }
        
        if (error.response) {
            // API responded with error status
            res.status(error.response.status).json({
                error: 'Raid-Helper API error',
                message: error.response.data?.message || error.message,
                status: error.response.status
            });
        } else {
            // Network or other error
            res.status(500).json({
                error: 'Failed to fetch Raid-Helper data',
                message: error.message
            });
        }
    }
});

// --- Manual Rewards and Deductions API Endpoints ---
// Get manual rewards/deductions for an event
app.get('/api/manual-rewards/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`‚öñÔ∏è [MANUAL REWARDS] Retrieving manual rewards/deductions for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [MANUAL REWARDS] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Ensure column exists then get manual rewards/deductions for this event
        await client.query(`ALTER TABLE manual_rewards_deductions ADD COLUMN IF NOT EXISTS is_gold BOOLEAN DEFAULT FALSE`);
        const result = await client.query(`
            SELECT 
                id,
                player_name,
                player_class,
                discord_id,
                description,
                points,
                created_by,
                created_at,
                updated_at,
                icon_url,
                COALESCE(is_gold,false) AS is_gold
            FROM manual_rewards_deductions 
            WHERE event_id = $1 
            ORDER BY created_at ASC
        `, [eventId]);
        
        console.log(`‚öñÔ∏è [MANUAL REWARDS] Found ${result.rows.length} manual entries for event: ${eventId}`);
        if (result.rows.length > 0) {
            result.rows.forEach(row => {
                console.log(`  - ${row.player_name}: ${row.points} pts, is_gold=${row.is_gold}, description="${row.description}"`);
            });
        }
        
        res.json({ 
            success: true, 
            data: result.rows,
            eventId: eventId
        });
        
    } catch (error) {
        console.error('‚ùå [MANUAL REWARDS] Error retrieving manual rewards/deductions:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving manual rewards/deductions',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Add manual reward/deduction entry
app.post('/api/manual-rewards/:eventId', requireManagement, async (req, res) => {
    const { eventId } = req.params;
    const { player_name, player_class, discord_id, description, points, icon_url, is_gold } = req.body;
    const createdBy = req.user?.id || 'unknown';
    
    console.log(`‚öñÔ∏è [MANUAL REWARDS] Adding entry for event: ${eventId}, player: ${player_name}, points: ${points}, is_gold: ${is_gold}`);
    
    if (!player_name || !description || points === undefined || points === null) {
        return res.status(400).json({ 
            success: false, 
            message: 'Missing required fields: player_name, description, and points are required' 
        });
    }
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [MANUAL REWARDS] Table does not exist');
            return res.status(500).json({ 
                success: false, 
                message: 'Manual rewards table does not exist. Please run database setup first.' 
            });
        }
        
        // Ensure column exists
        await client.query(`ALTER TABLE manual_rewards_deductions ADD COLUMN IF NOT EXISTS is_gold BOOLEAN DEFAULT FALSE`);
        // Insert new entry
        const result = await client.query(`
            INSERT INTO manual_rewards_deductions 
            (event_id, player_name, player_class, discord_id, description, points, created_by, icon_url, is_gold)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING *
        `, [eventId, player_name, player_class || null, discord_id || null, description, points, createdBy, icon_url || null, !!is_gold]);
        
        const newEntry = result.rows[0];
        console.log(`‚úÖ [MANUAL REWARDS] Created entry with ID: ${newEntry.id}, is_gold: ${newEntry.is_gold}`);
        
        try { broadcastUpdate('raidlogs', eventId, { type: 'manual_rewards_changed', id: newEntry.id, byUserId: createdBy }); } catch {}
        res.json({ 
            success: true, 
            data: newEntry,
            message: 'Manual reward/deduction added successfully'
        });
        
    } catch (error) {
        console.error('‚ùå [MANUAL REWARDS] Error adding manual entry:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error adding manual reward/deduction',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Update manual reward/deduction entry
app.put('/api/manual-rewards/:eventId/:entryId', requireManagement, async (req, res) => {
    const { eventId, entryId } = req.params;
    const { player_name, player_class, discord_id, description, points, is_gold } = req.body;
    
    console.log(`‚öñÔ∏è [MANUAL REWARDS] Updating entry ${entryId} for event: ${eventId}, is_gold: ${is_gold}`);
    
    if (!player_name || !description || points === undefined || points === null) {
        return res.status(400).json({ 
            success: false, 
            message: 'Missing required fields: player_name, description, and points are required' 
        });
    }
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [MANUAL REWARDS] Table does not exist');
            return res.status(500).json({ 
                success: false, 
                message: 'Manual rewards table does not exist. Please run database setup first.' 
            });
        }
        
        // Ensure column exists
        await client.query(`ALTER TABLE manual_rewards_deductions ADD COLUMN IF NOT EXISTS is_gold BOOLEAN DEFAULT FALSE`);
        // Update entry
        const result = await client.query(`
            UPDATE manual_rewards_deductions 
            SET player_name = $1, player_class = $2, discord_id = $3, description = $4, points = $5, is_gold = $6, updated_at = CURRENT_TIMESTAMP
            WHERE id = $7 AND event_id = $8
            RETURNING *
        `, [player_name, player_class, discord_id, description, points, !!is_gold, entryId, eventId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Manual entry not found' 
            });
        }
        
        const updatedEntry = result.rows[0];
        console.log(`‚úÖ [MANUAL REWARDS] Updated entry ID: ${updatedEntry.id}`);
        
        try { broadcastUpdate('raidlogs', eventId, { type: 'manual_rewards_changed', id: updatedEntry.id, byUserId: req.user?.id || null }); } catch {}
        res.json({ 
            success: true, 
            data: updatedEntry,
            message: 'Manual reward/deduction updated successfully'
        });
        
    } catch (error) {
        console.error('‚ùå [MANUAL REWARDS] Error updating manual entry:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error updating manual reward/deduction',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Delete manual reward/deduction entry
app.delete('/api/manual-rewards/:eventId/:entryId', requireManagement, async (req, res) => {
    const { eventId, entryId } = req.params;
    
    console.log(`‚öñÔ∏è [MANUAL REWARDS] Deleting entry ${entryId} for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [MANUAL REWARDS] Table does not exist');
            return res.status(500).json({ 
                success: false, 
                message: 'Manual rewards table does not exist. Please run database setup first.' 
            });
        }
        
        // Delete entry
        const result = await client.query(`
            DELETE FROM manual_rewards_deductions 
            WHERE id = $1 AND event_id = $2
            RETURNING *
        `, [entryId, eventId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Manual entry not found' 
            });
        }
        
        const deletedEntry = result.rows[0];
        console.log(`‚úÖ [MANUAL REWARDS] Deleted entry ID: ${deletedEntry.id}`);
        
        try { broadcastUpdate('raidlogs', eventId, { type: 'manual_rewards_changed', id: deletedEntry.id, op: 'delete', byUserId: req.user?.id || null }); } catch {}
        res.json({ 
            success: true, 
            data: deletedEntry,
            message: 'Manual reward/deduction deleted successfully'
        });
        
    } catch (error) {
        console.error('‚ùå [MANUAL REWARDS] Error deleting manual entry:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error deleting manual reward/deduction',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get player list for dropdown (from current raid participants)
app.get('/api/manual-rewards/:eventId/players', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üë• [MANUAL REWARDS] Getting player list for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        let players = [];
        
        // Try to get players from log_data first
        const logTableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'log_data'
            );
        `);
        
        if (logTableCheck.rows[0].exists) {
            const logResult = await client.query(`
                SELECT DISTINCT 
                    character_name as player_name,
                    character_class as player_class,
                    discord_id
                FROM log_data 
                WHERE event_id = $1 
                ORDER BY character_name
            `, [eventId]);
            
            players = logResult.rows;
            console.log(`üë• [MANUAL REWARDS] Found ${players.length} players from log_data`);
        }
        
        // If no players from log_data, try confirmed logs
        if (players.length === 0) {
            const confirmedTableCheck = await client.query(`
                SELECT EXISTS (
                    SELECT FROM information_schema.tables 
                    WHERE table_name = 'player_confirmed_logs'
                );
            `);
            
            if (confirmedTableCheck.rows[0].exists) {
                const confirmedResult = await client.query(`
                    SELECT DISTINCT 
                        character_name as player_name,
                        character_class as player_class,
                        discord_id
                    FROM player_confirmed_logs 
                    WHERE raid_id = $1 
                    ORDER BY character_name
                `, [eventId]);
                
                players = confirmedResult.rows;
                console.log(`üë• [MANUAL REWARDS] Found ${players.length} players from confirmed logs`);
            }
        }
        
        res.json({ 
            success: true, 
            data: players,
            eventId: eventId
        });
        
    } catch (error) {
        console.error('‚ùå [MANUAL REWARDS] Error getting player list:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error getting player list',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// === Rewards Snapshot API ===

// Status: cheap check if an event is locked in snapshot mode
app.get('/api/rewards-snapshot/:eventId/status', async (req, res) => {
    const { eventId } = req.params;
    let client;
    try {
        client = await pool.connect();
        const result = await client.query(
            `SELECT event_id, locked_at, locked_by_id, locked_by_name
             FROM rewards_snapshot_events WHERE event_id = $1`,
            [eventId]
        );
        if (result.rows.length === 0) {
            return res.json({ success: true, locked: false });
        }
        const row = result.rows[0];
        return res.json({
            success: true,
            locked: true,
            lockedAt: row.locked_at,
            lockedById: row.locked_by_id,
            lockedByName: row.locked_by_name
        });
    } catch (error) {
        console.error('‚ùå [SNAPSHOT] Status error:', error);
        return res.status(500).json({ success: false, message: 'Error fetching snapshot status' });
    } finally {
        if (client) client.release();
    }
});

// Lock and store snapshot entries. Accepts entries from the frontend for speed and fidelity.
// Body: { entries: [ { panel_key, panel_name, discord_user_id, character_name, character_class, ranking_number_original, point_value_original, character_details_original, primary_numeric_original, aux_json } ] }
app.post('/api/rewards-snapshot/:eventId/lock', requireManagement, express.json(), async (req, res) => {
    const { eventId } = req.params;
    const useEngine = !!(req.body && (req.body.useEngine === true));
    let entries = Array.isArray(req.body?.entries) ? req.body.entries : [];
    const header = (req.body && req.body.header) ? req.body.header : null;
    const lockedById = req.user?.id || null;
    const lockedByName = req.user?.username || req.user?.global_name || req.user?.display_name || 'unknown';
    let client;
    try {
        client = await pool.connect();

        await client.query('BEGIN');

        // Ensure snapshot row exists; if already locked, update who is applying changes
        await client.query(
            `INSERT INTO rewards_snapshot_events (event_id, locked_by_id, locked_by_name)
             VALUES ($1, $2, $3)
             ON CONFLICT (event_id) DO UPDATE SET locked_by_id = EXCLUDED.locked_by_id, locked_by_name = EXCLUDED.locked_by_name, locked_at = NOW()`,
            [eventId, lockedById, lockedByName]
        );

        if (header) {
            const {
              raidDurationMinutes = null,
              bossesKilled = null,
              lastBoss = null,
              wowLogsUrl = null,
              rpbArchiveUrl = null
            } = header || {};
            await client.query(
              `UPDATE rewards_snapshot_events
                 SET raid_duration_minutes = COALESCE($2, raid_duration_minutes),
                     bosses_killed = COALESCE($3, bosses_killed),
                     last_boss = COALESCE($4, last_boss),
                     wow_logs_url = COALESCE($5, wow_logs_url),
                     rpb_archive_url = COALESCE($6, rpb_archive_url)
               WHERE event_id = $1`,
              [eventId, raidDurationMinutes, bossesKilled, lastBoss, wowLogsUrl, rpbArchiveUrl]
            );
        }

        // Always replace snapshot rows for the event to avoid resurrecting stale data
        await client.query('DELETE FROM rewards_and_deductions_points WHERE event_id = $1', [eventId]);

        // If requested, lock directly from canonical engine panels (auto mode)
        if (useEngine || entries.length === 0) {
            try {
                // Build from engine auto output to guarantee parity with auto view
                const baseUrl = req.protocol + '://' + req.get('host');
                const appReq = { protocol: req.protocol, get: req.get.bind(req), headers: req.headers, cookies: req.cookies, user: req.user, isAuthenticated: ()=>true };
                const engine = await (async()=>{
                    // Inline require of rewardsEngine helpers is complex; call our own endpoint instead
                    const resp = await fetch(`${baseUrl}/api/rewards/${eventId}/effective`, { headers: { cookie: req.headers.cookie||'' } });
                    if (!resp.ok) throw new Error('engine fetch failed');
                    return resp.json();
                })();
                const panels = Array.isArray(engine.panels) ? engine.panels : [];
                const nameMap = {
                    base: 'Base',
                    damage: 'Damage Dealers',
                    healing: 'Healers',
                    god_gamer_dps: 'God Gamer DPS',
                    god_gamer_healer: 'God Gamer Healer',
                    abilities: 'Engineering & Holywater',
                    mana_potions: 'Major Mana Potions',
                    runes: 'Dark or Demonic runes',
                    windfury_totems: 'Totems',
                    interrupts: 'Interrupted spells',
                    disarms: 'Disarmed enemies',
                    sunder: 'Sunder Armor',
                    curse_recklessness: 'Curse of Recklessness',
                    curse_shadow: 'Curse of Shadow',
                    curse_elements: 'Curse of the Elements',
                    faerie_fire: 'Faerie Fire',
                    scorch: 'Scorch',
                    demo_shout: 'Demoralizing Shout',
                    polymorph: 'Polymorph',
                    power_infusion: 'Power Infusion',
                    decurses: 'Decurses',
                    frost_resistance: 'Frost Resistance',
                    world_buffs_copy: 'World Buffs',
                    void_damage: 'Avoidable Void Damage',
                    shaman_healers: 'Top Shaman Healers',
                    priest_healers: 'Top Priest Healers',
                    druid_healers: 'Top Druid Healer',
                    too_low_damage: 'Too Low Damage',
                    too_low_healing: 'Too Low Healing',
                    attendance_streaks: 'Attendance Streak Champions',
                    guild_members: 'Guild Members',
                    big_buyer: 'Big Buyer Bonus',
                    manual_points: 'Manual'
                };
                // Helper for class icon URLs (stable, no auth)
                const classIconUrl = (cls) => {
                  const k = String(cls||'').toLowerCase();
                  const map = {
                    warrior: 'https://wow.zamimg.com/images/wow/icons/large/classicon_warrior.jpg',
                    paladin: 'https://wow.zamimg.com/images/wow/icons/large/classicon_paladin.jpg',
                    hunter: 'https://wow.zamimg.com/images/wow/icons/large/classicon_hunter.jpg',
                    rogue: 'https://wow.zamimg.com/images/wow/icons/large/classicon_rogue.jpg',
                    priest: 'https://wow.zamimg.com/images/wow/icons/large/classicon_priest.jpg',
                    shaman: 'https://wow.zamimg.com/images/wow/icons/large/classicon_shaman.jpg',
                    mage: 'https://wow.zamimg.com/images/wow/icons/large/classicon_mage.jpg',
                    warlock: 'https://wow.zamimg.com/images/wow/icons/large/classicon_warlock.jpg',
                    druid: 'https://wow.zamimg.com/images/wow/icons/large/classicon_druid.jpg'
                  };
                  return map[k] || null;
                };

                const built = [];
                for (const p of panels) {
                    const panelKey = String(p.panel_key||'');
                    const panelName = nameMap[panelKey] || panelKey;
                    const rows = Array.isArray(p.rows) ? p.rows : [];
                    // Special handling: expand Totems into per-type rows so manual mode preserves sections
                    if (panelKey === 'windfury_totems') {
                        try {
                            const wfResp = await fetch(`${baseUrl}/api/windfury-data/${eventId}`, { headers: { cookie: req.headers.cookie||'' } });
                            if (wfResp && wfResp.ok) {
                                const wf = await wfResp.json();
                                const wfRows = Array.isArray(wf?.data) ? wf.data : [];
                                wfRows.forEach((row, idx) => {
                                    const type = String(row.totem_type||'').toLowerCase();
                                    let itemKey = 'windfury';
                                    let detailsText = 'Windfury Totem';
                                    if (type.includes('grace')) {
                                        itemKey = 'grace_of_air';
                                        detailsText = 'Grace of Air Totem';
                                    } else if (type.includes('strength')) {
                                        itemKey = 'strength_of_earth';
                                        detailsText = 'Strength of Earth Totem';
                                    } else if (type.includes('tranq')) {
                                        itemKey = 'tranquil_air';
                                        detailsText = 'Tranquil Air Totem';
                                    }
                                    built.push({
                                        panel_key: panelKey,
                                        panel_name: panelName,
                                        discord_user_id: null,
                                        character_name: row.character_name || null,
                                        character_class: row.character_class || null,
                                        ranking_number_original: Number.isFinite(idx+1) ? (idx+1) : null,
                                        point_value_original: Number(row.points)||0,
                                        character_details_original: detailsText,
                                        primary_numeric_original: null,
                                        aux_json: { item_key: itemKey }
                                    });
                                });
                                continue; // skip generic add for this panel
                            }
                        } catch (e) {
                            console.warn('‚ö†Ô∏è [SNAPSHOT] Windfury per-type expand failed, falling back to engine rows', e);
                        }
                    }
                    // Generic add for other panels (or fallback) with detail text
                    rows.forEach((r, idx) => {
                        let details = '';
                        try {
                          const nm = String(r.name||'');
                          if (panelKey === 'frost_resistance') {
                            const fr = r.frost_resistance ?? r.value ?? null;
                            if (fr != null) details = `FR ${fr}`;
                          } else if (panelKey === 'world_buffs_copy') {
                            if (Array.isArray(r.missing_buffs) && r.missing_buffs.length) {
                              details = `Missing: ${r.missing_buffs.join(', ')}`;
                            }
                          } else if (panelKey === 'mana_potions') {
                            const used = r.used ?? r.value ?? null;
                            if (used != null) details = `Used: ${used}`;
                          } else if (panelKey === 'runes') {
                            const used = r.used ?? r.value ?? null;
                            if (used != null) details = `Used: ${used}`;
                          } else if (panelKey === 'interrupts') {
                            const cnt = r.count ?? r.value ?? null; if (cnt != null) details = `Interrupts: ${cnt}`;
                          } else if (panelKey === 'disarms') {
                            const cnt = r.count ?? r.value ?? null; if (cnt != null) details = `Disarms: ${cnt}`;
                          } else if (panelKey === 'sunder') {
                            const cnt = r.count ?? r.value ?? null; if (cnt != null) details = `Sunders: ${cnt}`;
                          } else if (panelKey === 'decurses') {
                            const cnt = r.count ?? r.value ?? null; if (cnt != null) details = `Decurses: ${cnt}`;
                          } else if (panelKey === 'polymorph') {
                            const cnt = r.count ?? r.value ?? null; if (cnt != null) details = `Polymorphs: ${cnt}`;
                          } else if (panelKey === 'power_infusion') {
                            const cnt = r.count ?? r.value ?? null; if (cnt != null) details = `Infusions: ${cnt}`;
                          } else if (panelKey === 'abilities') {
                            const used = r.used ?? r.count ?? null; if (used != null) details = `Abilities used: ${used}`;
                          } else if (panelKey === 'void_damage') {
                            if (r.type) details = String(r.type);
                          }
                        } catch {}
                        built.push({
                            panel_key: panelKey,
                            panel_name: panelName,
                            discord_user_id: null,
                            character_name: r.name || null,
                            character_class: null,
                            ranking_number_original: Number.isFinite(idx+1) ? (idx+1) : null,
                            point_value_original: Number(r.points)||0,
                            character_details_original: (details||null),
                            primary_numeric_original: null,
                            aux_json: {}
                        });
                    });
                }
                // Enrich with class and icon from log_data where possible
                try {
                  const clsRes = await client.query(
                    `SELECT LOWER(character_name) AS key, character_class FROM log_data WHERE event_id = $1`,
                    [eventId]
                  );
                  const clsMap = new Map(clsRes.rows.map(r => [String(r.key||'').toLowerCase(), r.character_class]));
                  built.forEach(en => {
                    if (!en.character_class && en.character_name) {
                      const c = clsMap.get(String(en.character_name).toLowerCase());
                      if (c) en.character_class = c;
                    }
                    if (en.character_class) {
                      const icon = classIconUrl(en.character_class);
                      if (icon) en.aux_json = Object.assign({}, en.aux_json||{}, { icon_url: icon });
                    }
                  });
                } catch (e) { console.warn('‚ö†Ô∏è [SNAPSHOT] Class enrichment failed', e?.message||e); }
                entries = built;
            } catch (e) {
                console.error('‚ùå [SNAPSHOT] Engine materialization failed, falling back to provided entries:', e?.message||e);
            }
        }

        if (entries.length > 0) {
            // Bulk insert entries using UNNEST columns
            const cols = {
                panel_key: [], panel_name: [], discord_user_id: [], character_name: [], character_class: [],
                ranking_number_original: [], point_value_original: [], character_details_original: [],
                primary_numeric_original: [], aux_json: []
            };
            for (const e of entries) {
                cols.panel_key.push(e.panel_key || null);
                cols.panel_name.push(e.panel_name || null);
                cols.discord_user_id.push(e.discord_user_id || null);
                cols.character_name.push(e.character_name || null);
                cols.character_class.push(e.character_class || null);
                cols.ranking_number_original.push(Number.isFinite(e.ranking_number_original) ? e.ranking_number_original : null);
                cols.point_value_original.push(e.point_value_original ?? 0);
                cols.character_details_original.push(e.character_details_original || null);
                cols.primary_numeric_original.push(e.primary_numeric_original ?? null);
                cols.aux_json.push(e.aux_json ? JSON.stringify(e.aux_json) : null);
            }

            const query = `
                INSERT INTO rewards_and_deductions_points (
                    event_id, panel_key, panel_name, discord_user_id, character_name, character_class,
                    ranking_number_original, point_value_original, character_details_original,
                    primary_numeric_original, aux_json
                )
                SELECT
                    $1::varchar,
                    unnest($2::varchar[]),
                    unnest($3::varchar[]),
                    unnest($4::varchar[]),
                    unnest($5::varchar[]),
                    unnest($6::varchar[]),
                    unnest($7::int[]),
                    unnest($8::numeric[]),
                    unnest($9::text[]),
                    unnest($10::numeric[]),
                    unnest($11::jsonb[])
            `;

            await client.query(query, [
                eventId,
                cols.panel_key,
                cols.panel_name,
                cols.discord_user_id,
                cols.character_name,
                cols.character_class,
                cols.ranking_number_original,
                cols.point_value_original,
                cols.character_details_original,
                cols.primary_numeric_original,
                cols.aux_json
            ]);
        }

        await client.query('COMMIT');
        try { broadcastUpdate('raidlogs', eventId, { type: 'snapshot_locked', count: entries.length }); } catch {}
        return res.json({ success: true, locked: true, inserted: entries.length });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('‚ùå [SNAPSHOT] Lock error:', error);
        return res.status(500).json({ success: false, message: 'Error locking snapshot' });
    } finally {
        if (client) client.release();
    }
});

// Get snapshot rows for an event
app.get('/api/rewards-snapshot/:eventId', async (req, res) => {
    const { eventId } = req.params;
    let client;
    try {
        client = await pool.connect();
        const rows = await client.query(
            `SELECT * FROM rewards_and_deductions_points WHERE event_id = $1 ORDER BY panel_key, ranking_number_original NULLS LAST, character_name`,
            [eventId]
        );
        // Include header snapshot summary
        const hdr = await client.query(
          `SELECT event_id, locked_at, locked_by_id, locked_by_name, published, version, published_at, published_by_id, published_by_name,
                  raid_duration_minutes, bosses_killed, last_boss, wow_logs_url, rpb_archive_url
           FROM rewards_snapshot_events WHERE event_id = $1`,
          [eventId]
        );
        const header = hdr.rows[0] || null;
        return res.json({ success: true, data: rows.rows, header });
    } catch (error) {
        console.error('‚ùå [SNAPSHOT] Fetch error:', error);
        return res.status(500).json({ success: false, message: 'Error fetching snapshot rows' });
    } finally {
        if (client) client.release();
    }
});

// Update a single snapshot row's edited fields
app.put('/api/rewards-snapshot/:eventId/entry', requireManagement, express.json(), async (req, res) => {
    const { eventId } = req.params;
    const {
        panel_key,
        character_name,
        discord_user_id,
        ranking_number_original,
        point_value_edited,
        character_details_edited,
        primary_numeric_edited,
        aux_json
    } = req.body || {};
    const editedById = req.user?.id || null;
    const editedByName = req.user?.username || req.user?.global_name || req.user?.display_name || 'unknown';

    if (!panel_key || !character_name) {
        return res.status(400).json({ success: false, message: 'panel_key and character_name are required' });
    }

    let client;
    try {
        client = await pool.connect();
        // Optional item_key matching for panels with multiple rows per character (e.g., windfury_totems)
        const itemKey = aux_json && (aux_json.item_key || aux_json['item_key']) ? String(aux_json.item_key || aux_json['item_key']) : null;
        const sql = `UPDATE rewards_and_deductions_points
             SET point_value_edited = COALESCE($1, point_value_edited),
                 character_details_edited = COALESCE($2, character_details_edited),
                 primary_numeric_edited = COALESCE($3, primary_numeric_edited),
                 edited_by_id = $4,
                 edited_by_name = $5,
                 updated_at = CURRENT_TIMESTAMP
             WHERE event_id = $6 AND panel_key = $7
               AND (
                    ($9::varchar IS NOT NULL AND discord_user_id = $9)
                 OR (LOWER(character_name) = LOWER($8))
               )
               AND (
                    $10::text IS NULL
                 OR (aux_json IS NOT NULL AND aux_json->>'item_key' = $10)
               )
               AND (
                    $11::int IS NULL
                 OR ranking_number_original = $11
               )
             RETURNING *`;
        const params = [
                point_value_edited,
                character_details_edited,
                primary_numeric_edited,
                editedById,
                editedByName,
                eventId,
                panel_key,
                character_name,
                discord_user_id || null,
                itemKey,
                Number.isFinite(ranking_number_original) ? ranking_number_original : null
        ];
        const result = await client.query(sql, params);
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, message: 'Snapshot entry not found' });
        }
        try { broadcastUpdate('raidlogs', eventId, { type: 'snapshot_entry_updated', key: panel_key }); } catch {}
        return res.json({ success: true, entry: result.rows[0] });
    } catch (error) {
        console.error('‚ùå [SNAPSHOT] Update error:', error);
        return res.status(500).json({ success: false, message: 'Error updating snapshot entry' });
    } finally {
        if (client) client.release();
    }
});

// Unlock and revert snapshot (delete snapshot rows and event lock)
app.post('/api/rewards-snapshot/:eventId/unlock', requireManagement, async (req, res) => {
    const { eventId } = req.params;
    let client;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        await client.query('DELETE FROM rewards_and_deductions_points WHERE event_id = $1', [eventId]);
        await client.query('DELETE FROM rewards_snapshot_events WHERE event_id = $1', [eventId]);
        await client.query('COMMIT');
        try { broadcastUpdate('raidlogs', eventId, { type: 'snapshot_unlocked' }); } catch {}
        return res.json({ success: true, reverted: true });
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('‚ùå [SNAPSHOT] Unlock error:', error);
        return res.status(500).json({ success: false, message: 'Error unlocking snapshot' });
    } finally {
        if (client) client.release();
    }
});

// Publish current snapshot for an event (mark as published and stamp publisher)
app.post('/api/rewards-snapshot/:eventId/publish', requireManagement, async (req, res) => {
  const { eventId } = req.params;
  const publisherId = req.user?.id || null;
  const publisherName = req.user?.username || req.user?.global_name || req.user?.display_name || 'unknown';
  let client;
  try {
    client = await pool.connect();
    await client.query('BEGIN');
    // Ensure header table exists in case startup migrations didn't run
    await client.query(`
      CREATE TABLE IF NOT EXISTS rewards_snapshot_events (
        event_id VARCHAR(255) PRIMARY KEY,
        locked_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        locked_by_id VARCHAR(255),
        locked_by_name VARCHAR(255)
      )
    `);
    // Defensive: ensure required columns exist before attempting to update
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published BOOLEAN DEFAULT FALSE`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_at TIMESTAMP`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_by_id TEXT`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_by_name TEXT`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS total_gold_pot BIGINT`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS shared_gold_pot BIGINT`);
    // Defensive: ensure manual rewards table exists and has expected columns used by the merge
    await client.query(`
      CREATE TABLE IF NOT EXISTS manual_rewards_deductions (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(255) NOT NULL,
        player_name VARCHAR(255) NOT NULL,
        player_class VARCHAR(50),
        discord_id VARCHAR(255),
        description TEXT NOT NULL,
        points DECIMAL(10,2) NOT NULL,
        created_by VARCHAR(255) NOT NULL,
        icon_url VARCHAR(500),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await client.query(`ALTER TABLE manual_rewards_deductions ADD COLUMN IF NOT EXISTS is_gold BOOLEAN DEFAULT FALSE`);
    // Ensure header exists
    await client.query(
      `INSERT INTO rewards_snapshot_events (event_id, locked_by_id, locked_by_name)
       VALUES ($1, $2, $3)
       ON CONFLICT (event_id) DO NOTHING`,
      [eventId, publisherId, publisherName]
    );
    // Bump version and mark published
    const updRes = await client.query(
      `UPDATE rewards_snapshot_events
         SET published = TRUE,
             published_at = NOW(),
             published_by_id = $2,
             published_by_name = $3,
             version = COALESCE(version, 0) + 1
       WHERE event_id = $1`,
      [eventId, publisherId, publisherName]
    );
    // If no row was updated (very unlikely because of the insert above), force-create then update
    if (updRes.rowCount === 0) {
      await client.query(
        `INSERT INTO rewards_snapshot_events (event_id, locked_at, locked_by_id, locked_by_name)
         VALUES ($1, NOW(), $2, $3)
         ON CONFLICT (event_id) DO NOTHING`,
        [eventId, publisherId, publisherName]
      );
      await client.query(
        `UPDATE rewards_snapshot_events
            SET published = TRUE,
                published_at = NOW(),
                published_by_id = $2,
                published_by_name = $3,
                version = COALESCE(version, 0) + 1
          WHERE event_id = $1`,
        [eventId, publisherId, publisherName]
      );
    }

    // Sanity check and force-set if needed
    const chk = await client.query(
      `SELECT published, published_at FROM rewards_snapshot_events WHERE event_id = $1`,
      [eventId]
    );
    const row = chk.rows && chk.rows[0] ? chk.rows[0] : null;
    if (!row || row.published !== true || !row.published_at) {
      await client.query(
        `UPDATE rewards_snapshot_events SET published = TRUE, published_at = NOW() WHERE event_id = $1`,
        [eventId]
      );
    }

    // Merge Manual Rewards/Deductions into snapshot entries for public view
    // Replace existing manual_points rows then insert from manual_rewards_deductions
    try {
      await client.query(`DELETE FROM rewards_and_deductions_points WHERE event_id = $1 AND panel_key = 'manual_points'`, [eventId]);
      await client.query(`
        INSERT INTO rewards_and_deductions_points (
          event_id, panel_key, panel_name, discord_user_id, character_name, character_class,
          ranking_number_original, point_value_original, character_details_original, primary_numeric_original, aux_json
        )
        SELECT 
          $1::varchar AS event_id,
          'manual_points' AS panel_key,
          'Manual Rewards and Deductions' AS panel_name,
          m.discord_id AS discord_user_id,
          m.player_name AS character_name,
          m.player_class AS character_class,
          NULL::int AS ranking_number_original,
          COALESCE(m.points,0)::int AS point_value_original,
          COALESCE(m.description,'') AS character_details_original,
          NULL::int AS primary_numeric_original,
          jsonb_build_object(
            'is_gold',
            CASE
              WHEN m.is_gold IS TRUE THEN TRUE
              WHEN m.description ILIKE '%[GOLD]%' THEN TRUE
              ELSE FALSE
            END
          ) AS aux_json
        FROM manual_rewards_deductions m
        WHERE m.event_id = $1
      `, [eventId]);
    } catch (e) {
      console.warn('‚ö†Ô∏è [SNAPSHOT PUBLISH] Manual merge failed:', e?.message||e);
    }
    // Compute gold pot aggregates from snapshot entries: shared = sum of non-gold positives? We persist explicit totals only if provided in request; else leave null
    try {
      const providedTotal = req.body && Number.isFinite(Number(req.body.total_gold_pot)) ? Number(req.body.total_gold_pot) : null;
      const providedShared = req.body && Number.isFinite(Number(req.body.shared_gold_pot)) ? Number(req.body.shared_gold_pot) : null;
      if (providedTotal !== null || providedShared !== null) {
        await client.query(
          `UPDATE rewards_snapshot_events SET total_gold_pot = COALESCE($2,total_gold_pot), shared_gold_pot = COALESCE($3, shared_gold_pot) WHERE event_id = $1`,
          [eventId, providedTotal, providedShared]
        );
      } else {
        // Auto-compute from loot_items for this event
        const goldRes = await client.query(
          `SELECT COALESCE(SUM(gold_amount),0) AS total_gold FROM loot_items WHERE event_id = $1`,
          [eventId]
        );
        const totalGold = Number(goldRes.rows && goldRes.rows[0] && goldRes.rows[0].total_gold) || 0;
        const sharedGold = Math.floor(totalGold * 0.85);
        await client.query(
          `UPDATE rewards_snapshot_events SET total_gold_pot = $2, shared_gold_pot = $3 WHERE event_id = $1`,
          [eventId, totalGold, sharedGold]
        );
      }
    } catch {}
    // Return the final header row so client can verify
    const finalHdr = await client.query(
      `SELECT event_id, published, published_at, version,
              raid_duration_minutes, bosses_killed, last_boss, wow_logs_url, rpb_archive_url,
              total_gold_pot, shared_gold_pot
         FROM rewards_snapshot_events WHERE event_id = $1`,
      [eventId]
    );
    await client.query('COMMIT');
    try { broadcastUpdate('raidlogs', eventId, { type: 'snapshot_published' }); } catch {}
    return res.json({ success: true, header: finalHdr.rows && finalHdr.rows[0] ? finalHdr.rows[0] : null });
  } catch (error) {
    if (client) await client.query('ROLLBACK');
    console.error('‚ùå [SNAPSHOT] Publish error:', error);
    return res.status(500).json({ success: false, message: 'Error publishing snapshot', error: String(error && (error.detail || error.message || error)) });
  } finally {
    if (client) client.release();
  }
});

// Unpublish a snapshot: set published=false and clear timestamp/by
app.post('/api/rewards-snapshot/:eventId/unpublish', requireManagement, async (req, res) => {
  const { eventId } = req.params;
  const userId = req.user?.id || null;
  const userName = req.user?.username || req.user?.global_name || req.user?.display_name || 'unknown';
  let client;
  try {
    client = await pool.connect();
    await client.query('BEGIN');
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published BOOLEAN DEFAULT FALSE`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_at TIMESTAMP`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_by_id TEXT`);
    await client.query(`ALTER TABLE rewards_snapshot_events ADD COLUMN IF NOT EXISTS published_by_name TEXT`);
    await client.query(
      `INSERT INTO rewards_snapshot_events (event_id, locked_by_id, locked_by_name)
       VALUES ($1, $2, $3)
       ON CONFLICT (event_id) DO NOTHING`,
      [eventId, userId, userName]
    );
    await client.query(
      `UPDATE rewards_snapshot_events
         SET published = FALSE,
             published_at = NULL,
             published_by_id = NULL,
             published_by_name = NULL,
             version = COALESCE(version, 1)
       WHERE event_id = $1`,
      [eventId]
    );
    await client.query('COMMIT');
    res.json({ success: true });
  } catch (err) {
    if (client) try { await client.query('ROLLBACK'); } catch (_) {}
    res.status(500).json({ success:false, error: err && err.message ? err.message : String(err) });
  } finally {
    if (client) client.release();
  }
});

// Public read: return published snapshot header + entries for event
app.get('/api/raidlogs/published/:eventId', async (req, res) => {
  const { eventId } = req.params;
  let client;
  try {
    client = await pool.connect();
    const hdr = await client.query(
      `SELECT event_id, version, published, published_at, published_by_name,
              raid_duration_minutes, bosses_killed, last_boss, wow_logs_url, rpb_archive_url,
              total_gold_pot, shared_gold_pot
         FROM rewards_snapshot_events
        WHERE event_id = $1 AND published = TRUE
        ORDER BY published_at DESC NULLS LAST, version DESC
        LIMIT 1`,
      [eventId]
    );
    if (hdr.rows.length === 0) {
      return res.json({ success: true, header: null, entries: [] });
    }
    const header = hdr.rows[0];
    const rows = await client.query(
      `SELECT panel_key, panel_name, character_name, character_class,
              point_value_edited, point_value_original,
              character_details_edited, character_details_original,
              COALESCE(point_value_edited, point_value_original) AS points,
              COALESCE(character_details_edited, character_details_original) AS character_details,
              primary_numeric_original, aux_json
         FROM rewards_and_deductions_points
        WHERE event_id = $1
        ORDER BY panel_key, ranking_number_original NULLS LAST, character_name`,
      [eventId]
    );
    res.json({ success: true, header, entries: rows.rows });
  } catch (error) {
    console.error('‚ùå [PUBLISHED] Fetch error:', error);
    res.status(500).json({ success: false, message: 'Error fetching published snapshot' });
  } finally {
    if (client) client.release();
  }
});

// --- Manual Rewards Templates API Endpoints ---
// Get all templates
app.get('/api/manual-rewards-templates', async (req, res) => {
    console.log('üìã [TEMPLATES] Retrieving all templates');
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if templates table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions_templates'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [TEMPLATES] Templates table does not exist');
            return res.json({ 
                success: false, 
                message: 'Templates table does not exist. Please run database setup first.',
                data: [] 
            });
        }
        
        // Get all templates
        const result = await client.query(`
            SELECT 
                id,
                description,
                points,
                player_name,
                icon_url,
                created_at,
                updated_at
            FROM manual_rewards_deductions_templates 
            ORDER BY points DESC, description ASC
        `);
        
        console.log(`üìã [TEMPLATES] Found ${result.rows.length} templates`);
        
        res.json({ 
            success: true, 
            data: result.rows
        });
        
    } catch (error) {
        console.error('‚ùå [TEMPLATES] Error retrieving templates:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving templates',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Insert templates into manual rewards for an event
app.post('/api/manual-rewards/:eventId/from-templates', requireManagement, async (req, res) => {
    const { eventId } = req.params;
    const createdBy = req.user?.id || 'unknown';
    const templateIdsRaw = req.body?.templateIds;

    const templateIds = Array.isArray(templateIdsRaw)
        ? templateIdsRaw
            .map((id) => parseInt(id, 10))
            .filter((n) => Number.isFinite(n))
        : null;

    console.log(`üìã [TEMPLATES] Inserting templates for event: ${eventId} by user: ${createdBy}`);
    if (templateIds && templateIds.length > 0) {
        console.log(`üìã [TEMPLATES] Requested templateIds: ${templateIds.join(', ')}`);
    } else {
        console.log('üìã [TEMPLATES] No specific templateIds provided - will insert all templates');
    }

    let client;
    try {
        client = await pool.connect();

        // Check if templates table exists
        const templatesTableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions_templates'
            );
        `);

        if (!templatesTableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [TEMPLATES] Templates table does not exist');
            return res.status(400).json({ 
                success: false, 
                message: 'Templates table does not exist. Please go to the Admin page and click "Create Templates Table" or "Setup Database".'
            });
        }

        // Check if manual rewards table exists
        const rewardsTableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'manual_rewards_deductions'
            );
        `);

        if (!rewardsTableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [TEMPLATES] Manual rewards table does not exist');
            return res.status(400).json({ 
                success: false, 
                message: 'Manual rewards table does not exist. Please run database setup first.'
            });
        }

        // Get templates (optionally filtered by provided IDs)
        let templatesResult;
        if (templateIds && templateIds.length > 0) {
            templatesResult = await client.query(
                `SELECT id, description, points, player_name, icon_url
                 FROM manual_rewards_deductions_templates
                 WHERE id = ANY($1::int[])
                 ORDER BY id ASC`,
                [templateIds]
            );
        } else {
            templatesResult = await client.query(`
                SELECT id, description, points, player_name, icon_url
                FROM manual_rewards_deductions_templates 
                ORDER BY points DESC, description ASC
            `);
        }

        if (templatesResult.rows.length === 0) {
            console.log('‚ö†Ô∏è [TEMPLATES] No templates found');
            return res.json({ 
                success: true, 
                message: 'No templates found to insert',
                data: []
            });
        }

        // Insert each template as a manual reward entry (with empty player_name for manual editing)
        const insertedEntries = [];
        for (const template of templatesResult.rows) {
            console.log(`üìù [TEMPLATES] Inserting template: ${template.description} (${template.points} pts)`);

            const insertResult = await client.query(
                `INSERT INTO manual_rewards_deductions (
                    event_id, player_name, description, points, created_by, icon_url
                ) VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING *`,
                [
                    eventId,
                    '', // Empty player name - to be filled by user
                    template.description,
                    template.points,
                    createdBy,
                    template.icon_url,
                ]
            );

            insertedEntries.push(insertResult.rows[0]);
        }

        console.log(`‚úÖ [TEMPLATES] Successfully inserted ${insertedEntries.length} template entries for event: ${eventId}`);

        res.json({ 
            success: true, 
            message: `Successfully inserted ${insertedEntries.length} template entries`,
            data: insertedEntries,
            templatesInserted: insertedEntries.length,
        });

    } catch (error) {
        console.error('‚ùå [TEMPLATES] Error inserting templates:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error inserting templates',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Create templates table separately (for troubleshooting)
app.post('/api/admin/create-templates-table', async (req, res) => {
    console.log('üìã [ADMIN] Creating templates table manually...');
    
    let client;
    try {
        client = await pool.connect();
        
        // Create manual_rewards_deductions_templates table
        await client.query(`
            CREATE TABLE IF NOT EXISTS manual_rewards_deductions_templates (
                id SERIAL PRIMARY KEY,
                description TEXT NOT NULL,
                points DECIMAL(10,2) NOT NULL,
                player_name VARCHAR(255),
                icon_url VARCHAR(500),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        console.log('‚úÖ [ADMIN] Templates table created successfully');

        // Create index
        await client.query(`
            CREATE INDEX IF NOT EXISTS idx_templates_description ON manual_rewards_deductions_templates (description)
        `);
        
        console.log('‚úÖ [ADMIN] Templates table index created');

        // Add icon_url column to existing templates table if it doesn't exist
        try {
            await client.query(`
                ALTER TABLE manual_rewards_deductions_templates 
                ADD COLUMN IF NOT EXISTS icon_url VARCHAR(500)
            `);
            console.log('‚úÖ [ADMIN] Added icon_url column to templates table (if missing)');
        } catch (error) {
            console.log('‚ö†Ô∏è [ADMIN] icon_url column might already exist in templates table:', error.message);
        }

        // Prefer importing from CSV shipped with the repo so Heroku matches localhost
        const csvPath = path.join(__dirname, 'manual_rewards_deductions_templates.csv');
        let importedCount = 0;

        // Start a transaction for deterministic results
        await client.query('BEGIN');

        if (fs.existsSync(csvPath)) {
            console.log('üìÑ [ADMIN] Found CSV for templates at:', csvPath);
            const csvRaw = fs.readFileSync(csvPath, 'utf8');
            const lines = csvRaw.split(/\r?\n/).filter(l => l.trim().length > 0);
            if (lines.length > 1) {
                // Remove header
                lines.shift();

                // Clear current table content to mirror local
                await client.query('TRUNCATE TABLE manual_rewards_deductions_templates RESTART IDENTITY');

                const parseCsvLine = (line) => {
                    const result = [];
                    let current = '';
                    let inQuotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const ch = line[i];
                        if (ch === '"') {
                            if (inQuotes && line[i + 1] === '"') {
                                current += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (ch === ',' && !inQuotes) {
                            result.push(current);
                            current = '';
                        } else {
                            current += ch;
                        }
                    }
                    result.push(current);
                    return result.map(v => v.replace(/^\"|\"$/g, ''));
                };

                for (const line of lines) {
                    const cols = parseCsvLine(line);
                    if (cols.length < 7) continue; // skip malformed
                    const [id, description, points, player_name, created_at, updated_at, icon_url] = cols;
                    await client.query(
                        `INSERT INTO manual_rewards_deductions_templates (id, description, points, player_name, created_at, updated_at, icon_url)
                         VALUES ($1,$2,$3,$4,$5,$6,$7)
                         ON CONFLICT (id) DO UPDATE SET description = EXCLUDED.description, points = EXCLUDED.points, player_name = EXCLUDED.player_name, icon_url = EXCLUDED.icon_url, updated_at = EXCLUDED.updated_at`,
                        [id ? parseInt(id, 10) : null, description, parseFloat(points), player_name || null, created_at || null, updated_at || null, icon_url || null]
                    );
                    importedCount++;
                }

                // Ensure the serial sequence is aligned after explicit id inserts
                await client.query(`SELECT setval(pg_get_serial_sequence('manual_rewards_deductions_templates','id'), COALESCE((SELECT MAX(id) FROM manual_rewards_deductions_templates), 1), true)`);
                console.log(`‚úÖ [ADMIN] Imported ${importedCount} templates from CSV`);
            } else {
                console.log('‚ö†Ô∏è [ADMIN] CSV appears empty beyond header; skipping import.');
            }
        } else {
            console.log('‚ö†Ô∏è [ADMIN] CSV not found; falling back to default seed set.');
            const templatesCheck = await client.query('SELECT COUNT(*) FROM manual_rewards_deductions_templates');
            const templateCount = parseInt(templatesCheck.rows[0].count);
            if (templateCount === 0) {
                await client.query(`
                    INSERT INTO manual_rewards_deductions_templates (description, points, player_name, icon_url) VALUES
                    ('Main Tank', 100, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg'),
                    ('Off Tank 1', 80, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg'),
                    ('Off Tank 2', 50, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg'),
                    ('Off Tank 3', 30, '', 'https://wow.zamimg.com/images/wow/icons/large/ability_warrior_defensivestance.jpg')
                `);
                importedCount = 4;
                console.log('‚úÖ [ADMIN] Default templates inserted.');
            } else {
                importedCount = templateCount;
                console.log(`üìã [ADMIN] Found ${templateCount} existing templates, no changes.`);
            }
        }

        await client.query('COMMIT');

        res.json({ 
            success: true, 
            message: 'Templates table created and populated successfully from CSV.',
            templatesCount: importedCount
        });
        
    } catch (error) {
        console.error('‚ùå [ADMIN] Error creating templates table:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error creating templates table', 
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Cache management endpoints for Raid-Helper events
app.get('/api/cache/raid-helper/stats', async (req, res) => {
    try {
        const stats = await pool.query(`
            SELECT 
                COUNT(*) as total_events,
                COUNT(CASE WHEN cached_at > NOW() - INTERVAL '6 hours' THEN 1 END) as fresh_events,
                COUNT(CASE WHEN cached_at <= NOW() - INTERVAL '6 hours' THEN 1 END) as stale_events,
                MIN(cached_at) as oldest_cache,
                MAX(cached_at) as newest_cache,
                AVG(EXTRACT(EPOCH FROM (NOW() - cached_at))/3600) as avg_age_hours
            FROM raid_helper_events_cache
        `);
        
        const sizeStats = await pool.query(`
            SELECT pg_size_pretty(pg_total_relation_size('raid_helper_events_cache')) as table_size
        `);
        
        res.json({
            success: true,
            stats: {
                ...stats.rows[0],
                table_size: sizeStats.rows[0].table_size
            }
        });
    } catch (error) {
        console.error('‚ùå Error getting cache stats:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get cache stats'
        });
    }
});

app.post('/api/cache/raid-helper/cleanup', async (req, res) => {
    try {
        const { olderThanDays = 30 } = req.body;
        const cleanedCount = await cleanupRaidHelperEventCache(olderThanDays);
        
        res.json({
            success: true,
            message: `Cleaned up ${cleanedCount} old cache entries`,
            cleanedCount
        });
    } catch (error) {
        console.error('‚ùå Error cleaning cache:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to clean cache'
        });
    }
});

app.delete('/api/cache/raid-helper/events/:eventId', async (req, res) => {
    try {
        const { eventId } = req.params;
        
        const result = await pool.query(`
            DELETE FROM raid_helper_events_cache 
            WHERE event_id = $1
            RETURNING event_id
        `, [eventId]);
        
        if (result.rows.length > 0) {
            res.json({
                success: true,
                message: `Cache cleared for event ${eventId}`
            });
        } else {
            res.status(404).json({
                success: false,
                message: `No cache found for event ${eventId}`
            });
        }
    } catch (error) {
        console.error('‚ùå Error clearing cache:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to clear cache'
        });
    }
});

// Google Apps Script proxy endpoint for RPB archiving
app.post('/api/logs/rpb-archive', async (req, res) => {
    console.log('üìÅ [RPB ARCHIVE] Starting Google Apps Script proxy request');
    console.log('üîç [RPB ARCHIVE] Environment check - NODE_ENV:', process.env.NODE_ENV);
    
    try {
        // HARDCODED URL to bypass whatever parsing issue is happening
        const scriptUrl = 'https://script.google.com/macros/s/AKfycbyilOtCQnVteduqKoRPSE0VNAne9tVPkQezaePajGMUiAiMNKmpn0flIdNBgL8tx5Eo/exec';
        
        console.log('üîÑ [RPB ARCHIVE] Using hardcoded URL:', scriptUrl.substring(0, 50) + '...');
        
        // Make the request to Google Apps Script with timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
        
        const response = await fetch(scriptUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                action: 'createRpbBackup'
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        console.log('üìä [RPB ARCHIVE] Response status:', response.status, response.statusText);
        console.log('üìä [RPB ARCHIVE] Response headers:', Object.fromEntries(response.headers.entries()));
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå [RPB ARCHIVE] Google Apps Script error response:', errorText);
            throw new Error(`Google Apps Script request failed: ${response.status} ${response.statusText}. Response: ${errorText}`);
        }
        
        const result = await response.json();
        console.log('‚úÖ [RPB ARCHIVE] Google Apps Script response:', result);
        
        // Return the result from Google Apps Script
        res.json(result);
        
    } catch (error) {
        console.error('‚ùå [RPB ARCHIVE] Error calling Google Apps Script:', error);
        
        // Enhanced error reporting
        let errorMessage = error.message || 'Failed to create RPB backup';
        if (error.name === 'AbortError') {
            errorMessage = 'Google Apps Script request timed out after 30 seconds';
        } else if (error.code === 'ENOTFOUND') {
            errorMessage = 'Could not connect to Google Apps Script. Check network connectivity.';
        } else if (error.code === 'ECONNRESET') {
            errorMessage = 'Connection to Google Apps Script was reset. Try again.';
        }
        
        console.log('üîç [RPB ARCHIVE] Full error details:', {
            name: error.name,
            code: error.code,
            message: error.message,
            stack: error.stack
        });
        
        res.status(500).json({
            success: false,
            error: errorMessage,
            details: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
});

// Get sunder armor data for raid logs
app.get('/api/sunder-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`‚öîÔ∏è [SUNDER] Retrieving sunder armor data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [SUNDER] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for sunder armor calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'sunder'
        `);
        
        console.log(`‚öîÔ∏è [SUNDER] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    // Handle case where setting_json might be a string or already parsed
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`‚öîÔ∏è [SUNDER] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`‚öîÔ∏è [SUNDER] Parsed settings:`, settings);
        
        const pointRanges = settings.point_ranges || [
            {"min": 0, "max": 49, "points": -10, "color": "red"},
            {"min": 50, "max": 99, "points": 0, "color": "gray"},
            {"min": 100, "max": 119, "points": 5, "color": "green"},
            {"min": 120, "max": 999, "points": 10, "color": "blue"}
        ];
        
        console.log(`‚öîÔ∏è [SUNDER] Using point ranges:`, pointRanges);
        
        // Query for "Sunder Armor% on targets < 5 stacks" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = 'Sunder Armor% on targets < 5 stacks'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`‚öîÔ∏è [SUNDER] Found ${result.rows.length} sunder records for event: ${eventId}`);
        console.log(`‚öîÔ∏è [SUNDER] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the sunder count from "112 (64%)" format - extract first number
            const sunderMatch = row.ability_value.toString().match(/(\d+)/);
            const sunderCount = sunderMatch ? parseInt(sunderMatch[1]) : 0;
            
            // Find the appropriate range and calculate points
            const range = pointRanges.find(r => sunderCount >= r.min && sunderCount <= r.max);
            const points = range ? range.points : 0;
            const color = range ? range.color : 'gray';
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                sunder_count: sunderCount,
                points: points,
                color: color,
                raw_value: row.ability_value
            };
        })
        // Removed filter for sunder_count > 0 - include all characters even with 0 sunders
          .sort((a, b) => b.points - a.points || b.sunder_count - a.sunder_count); // Sort by points, then by count
        
        console.log(`‚öîÔ∏è [SUNDER] Processed ${finalData.length} characters with sunder usage`);
        console.log(`‚öîÔ∏è [SUNDER] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                point_ranges: pointRanges
            }
        });
        
    } catch (error) {
        console.error('‚ùå [SUNDER] Error retrieving sunder data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving sunder data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get curse of recklessness data for raid logs
app.get('/api/curse-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üîÆ [CURSE] Retrieving curse of recklessness data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [CURSE] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for curse of recklessness calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'curse'
        `);
        
        console.log(`üîÆ [CURSE] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`üîÆ [CURSE] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`üîÆ [CURSE] Parsed settings:`, settings);
        
        const uptimeThreshold = settings.uptime_threshold || 85;
        const points = settings.points || 10;
        
        console.log(`üîÆ [CURSE] Using settings: threshold=${uptimeThreshold}%, points=${points}`);
        
        // Query for "Curse of Recklessness (uptime% - overall: XX%)" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name LIKE 'Curse of Recklessness (uptime%% - overall: %)'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`üîÆ [CURSE] Found ${result.rows.length} curse records for event: ${eventId}`);
        console.log(`üîÆ [CURSE] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the uptime percentage from "133 (85%)" format - extract percentage from brackets
            const uptimeMatch = row.ability_value.toString().match(/\((\d+(?:\.\d+)?)%\)/);
            const uptimePercentage = uptimeMatch ? parseFloat(uptimeMatch[1]) : 0;
            
            // Calculate points based on threshold
            const earnedPoints = uptimePercentage > uptimeThreshold ? points : 0;
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                uptime_percentage: uptimePercentage,
                points: earnedPoints,
                raw_value: row.ability_value
            };
        }).filter(char => char.uptime_percentage >= 0) // Include all characters with valid uptime data
          .sort((a, b) => b.uptime_percentage - a.uptime_percentage); // Sort by uptime percentage descending
        
        console.log(`üîÆ [CURSE] Processed ${finalData.length} characters with curse uptime data`);
        console.log(`üîÆ [CURSE] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                uptime_threshold: uptimeThreshold,
                points: points
            }
        });
        
    } catch (error) {
        console.error('‚ùå [CURSE] Error retrieving curse data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving curse data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get curse of shadow data for raid logs
app.get('/api/curse-shadow-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üåë [CURSE SHADOW] Retrieving curse of shadow data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [CURSE SHADOW] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for curse of shadow calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'curse_shadow'
        `);
        
        console.log(`üåë [CURSE SHADOW] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`üåë [CURSE SHADOW] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`üåë [CURSE SHADOW] Parsed settings:`, settings);
        
        const uptimeThreshold = settings.uptime_threshold || 85;
        const points = settings.points || 10;
        
        console.log(`üåë [CURSE SHADOW] Using settings: threshold=${uptimeThreshold}%, points=${points}`);
        
        // Query for "Curse of Shadow (uptime% - overall: XX%)" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name LIKE 'Curse of Shadow (uptime%% - overall: %)'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`üåë [CURSE SHADOW] Found ${result.rows.length} curse shadow records for event: ${eventId}`);
        console.log(`üåë [CURSE SHADOW] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the uptime percentage from "133 (85%)" format - extract percentage from brackets
            const uptimeMatch = row.ability_value.toString().match(/\((\d+(?:\.\d+)?)%\)/);
            const uptimePercentage = uptimeMatch ? parseFloat(uptimeMatch[1]) : 0;
            
            // Calculate points based on threshold
            const earnedPoints = uptimePercentage > uptimeThreshold ? points : 0;
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                uptime_percentage: uptimePercentage,
                points: earnedPoints,
                raw_value: row.ability_value
            };
        }).filter(char => char.uptime_percentage >= 0) // Include all characters with valid uptime data
          .sort((a, b) => b.uptime_percentage - a.uptime_percentage); // Sort by uptime percentage descending
        
        console.log(`üåë [CURSE SHADOW] Processed ${finalData.length} characters with curse shadow uptime data`);
        console.log(`üåë [CURSE SHADOW] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                uptime_threshold: uptimeThreshold,
                points: points
            }
        });
        
    } catch (error) {
        console.error('‚ùå [CURSE SHADOW] Error retrieving curse shadow data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving curse shadow data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get curse of elements data for raid logs
app.get('/api/curse-elements-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Retrieving curse of elements data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [CURSE ELEMENTS] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for curse of elements calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'curse_elements'
        `);
        
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`‚ùÑÔ∏è [CURSE ELEMENTS] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Parsed settings:`, settings);
        
        const uptimeThreshold = settings.uptime_threshold || 85;
        const points = settings.points || 10;
        
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Using settings: threshold=${uptimeThreshold}%, points=${points}`);
        
        // Query for "Curse of the Elements (uptime% - overall: XX%)" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name LIKE 'Curse of the Elements (uptime%% - overall: %)'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Found ${result.rows.length} curse elements records for event: ${eventId}`);
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the uptime percentage from "133 (85%)" format - extract percentage from brackets
            const uptimeMatch = row.ability_value.toString().match(/\((\d+(?:\.\d+)?)%\)/);
            const uptimePercentage = uptimeMatch ? parseFloat(uptimeMatch[1]) : 0;
            
            // Calculate points based on threshold
            const earnedPoints = uptimePercentage > uptimeThreshold ? points : 0;
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                uptime_percentage: uptimePercentage,
                points: earnedPoints,
                raw_value: row.ability_value
            };
        }).filter(char => char.uptime_percentage >= 0) // Include all characters with valid uptime data
          .sort((a, b) => b.uptime_percentage - a.uptime_percentage); // Sort by uptime percentage descending
        
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Processed ${finalData.length} characters with curse elements uptime data`);
        console.log(`‚ùÑÔ∏è [CURSE ELEMENTS] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                uptime_threshold: uptimeThreshold,
                points: points
            }
        });
        
    } catch (error) {
        console.error('‚ùå [CURSE ELEMENTS] Error retrieving curse elements data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving curse elements data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get faerie fire data for raid logs
app.get('/api/faerie-fire-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üåü [FAERIE FIRE] Retrieving faerie fire data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [FAERIE FIRE] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for faerie fire calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'faerie_fire'
        `);
        
        console.log(`üåü [FAERIE FIRE] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`üåü [FAERIE FIRE] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`üåü [FAERIE FIRE] Parsed settings:`, settings);
        
        const uptimeThreshold = settings.uptime_threshold || 85;
        const points = settings.points || 10;
        
        console.log(`üåü [FAERIE FIRE] Using settings: threshold=${uptimeThreshold}%, points=${points}`);
        
        // Query for "Faerie Fire (uptime% - overall: XX%)" usage (both base and Feral versions)
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name LIKE 'Faerie Fire%uptime%% - overall:%'
            ORDER BY character_name, ability_name
        `, [eventId]);
        
        console.log(`üåü [FAERIE FIRE] Found ${result.rows.length} faerie fire records for event: ${eventId}`);
        console.log(`üåü [FAERIE FIRE] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        // Group by character name and use the HIGHEST uptime from all Faerie Fire variants
        const byCharacter = new Map();
        result.rows.forEach(row => {
            const name = row.character_name;
            // Parse the uptime percentage from "133 (85%)" format or just "0" - extract percentage from brackets
            const uptimeMatch = row.ability_value.toString().match(/\((\d+(?:\.\d+)?)%\)/);
            const uptimePercentage = uptimeMatch ? parseFloat(uptimeMatch[1]) : 0;
            
            if (!byCharacter.has(name) || byCharacter.get(name).uptime_percentage < uptimePercentage) {
                byCharacter.set(name, {
                character_name: row.character_name,
                character_class: row.character_class,
                uptime_percentage: uptimePercentage,
                    ability_name: row.ability_name,
                raw_value: row.ability_value
                });
            }
        });
        
        const finalData = Array.from(byCharacter.values()).map(char => {
            // Calculate points based on threshold (inclusive - >= instead of >)
            const earnedPoints = char.uptime_percentage >= uptimeThreshold ? points : 0;
            // Format uptime for display (e.g., "64%" or "64.5%")
            const formattedUptime = char.uptime_percentage % 1 === 0 
                ? `${char.uptime_percentage}%` 
                : `${char.uptime_percentage.toFixed(1)}%`;
            return {
                character_name: char.character_name,
                character_class: char.character_class,
                uptime_percentage: char.uptime_percentage,
                uptime: formattedUptime, // Formatted string for display
                points: earnedPoints,
                raw_value: char.raw_value
            };
        }).filter(char => char.uptime_percentage >= 0) // Include all characters with valid uptime data
          .sort((a, b) => b.uptime_percentage - a.uptime_percentage); // Sort by uptime percentage descending
        
        console.log(`üåü [FAERIE FIRE] Processed ${finalData.length} characters with faerie fire uptime data`);
        console.log(`üåü [FAERIE FIRE] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                uptime_threshold: uptimeThreshold,
                points: points
            }
        });
        
    } catch (error) {
        console.error('‚ùå [FAERIE FIRE] Error retrieving faerie fire data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving faerie fire data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get scorch data for raid logs
app.get('/api/scorch-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üî• [SCORCH] Retrieving scorch data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [SCORCH] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for scorch calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'scorch'
        `);
        
        console.log(`üî• [SCORCH] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`üî• [SCORCH] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`üî• [SCORCH] Parsed settings:`, settings);
        
        const tier1Max = settings.tier1_max || 99;
        const tier1Points = settings.tier1_points || 0;
        const tier2Max = settings.tier2_max || 199;
        const tier2Points = settings.tier2_points || 5;
        const tier3Points = settings.tier3_points || 10;
        
        console.log(`üî• [SCORCH] Using settings: 0-${tier1Max}=${tier1Points}pts, ${tier1Max + 1}-${tier2Max}=${tier2Points}pts, ${tier2Max + 1}+=${tier3Points}pts`);
        
        // Query for "Scorch% on targets < 5 stacks" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = 'Scorch% on targets < 5 stacks'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`üî• [SCORCH] Found ${result.rows.length} scorch records for event: ${eventId}`);
        console.log(`üî• [SCORCH] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the scorch count from "334 (74%)" format - extract number before brackets
            const scorchMatch = row.ability_value.toString().match(/^(\d+)/);
            const scorchCount = scorchMatch ? parseInt(scorchMatch[1]) : 0;
            
            // Calculate points based on tiers
            let earnedPoints = tier1Points; // default 0-99 range
            if (scorchCount > tier2Max) {
                earnedPoints = tier3Points; // 200+
            } else if (scorchCount > tier1Max) {
                earnedPoints = tier2Points; // 100-199
            }
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                scorch_count: scorchCount,
                points: earnedPoints,
                raw_value: row.ability_value
            };
        }).filter(char => char.scorch_count >= 0) // Include all characters with valid scorch data
          .sort((a, b) => b.scorch_count - a.scorch_count); // Sort by scorch count descending
        
        console.log(`üî• [SCORCH] Processed ${finalData.length} characters with scorch data`);
        console.log(`üî• [SCORCH] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                tier1_max: tier1Max,
                tier1_points: tier1Points,
                tier2_max: tier2Max,
                tier2_points: tier2Points,
                tier3_points: tier3Points
            }
        });
        
    } catch (error) {
        console.error('‚ùå [SCORCH] Error retrieving scorch data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving scorch data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get demoralizing shout data for raid logs
app.get('/api/demo-shout-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`‚öîÔ∏è [DEMO SHOUT] Retrieving demoralizing shout data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [DEMO SHOUT] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for demoralizing shout calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value, setting_json
            FROM reward_settings 
            WHERE setting_type = 'demo_shout'
        `);
        
        console.log(`‚öîÔ∏è [DEMO SHOUT] Raw settings from DB:`, settingsResult.rows);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            if (row.setting_json) {
                try {
                    if (typeof row.setting_json === 'string') {
                        settings[row.setting_name] = JSON.parse(row.setting_json);
                    } else {
                        settings[row.setting_name] = row.setting_json;
                    }
                } catch (error) {
                    console.error(`‚öîÔ∏è [DEMO SHOUT] Error parsing JSON for ${row.setting_name}:`, error);
                    settings[row.setting_name] = null;
                }
            } else {
                settings[row.setting_name] = parseFloat(row.setting_value);
            }
        });
        
        console.log(`‚öîÔ∏è [DEMO SHOUT] Parsed settings:`, settings);
        
        const tier1Max = settings.tier1_max || 99;
        const tier1Points = settings.tier1_points || 0;
        const tier2Max = settings.tier2_max || 199;
        const tier2Points = settings.tier2_points || 5;
        const tier3Points = settings.tier3_points || 10;
        
        console.log(`‚öîÔ∏è [DEMO SHOUT] Using settings: 0-${tier1Max}=${tier1Points}pts, ${tier1Max + 1}-${tier2Max}=${tier2Points}pts, ${tier2Max + 1}+=${tier3Points}pts`);
        
        // Query for "Demoralizing Shout (uptime% - overall: XX%)" usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name LIKE 'Demoralizing Shout (uptime%% - overall: %)'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`‚öîÔ∏è [DEMO SHOUT] Found ${result.rows.length} demoralizing shout records for event: ${eventId}`);
        console.log(`‚öîÔ∏è [DEMO SHOUT] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the demoralizing shout count from "113 (51%)" format - extract number before brackets
            const demoShoutMatch = row.ability_value.toString().match(/^(\d+)/);
            const demoShoutCount = demoShoutMatch ? parseInt(demoShoutMatch[1]) : 0;
            
            // Calculate points based on tiers
            let earnedPoints = tier1Points; // default 0-99 range
            if (demoShoutCount > tier2Max) {
                earnedPoints = tier3Points; // 200+
            } else if (demoShoutCount > tier1Max) {
                earnedPoints = tier2Points; // 100-199
            }
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                demo_shout_count: demoShoutCount,
                points: earnedPoints,
                raw_value: row.ability_value
            };
        }).filter(char => char.demo_shout_count >= 0) // Include all characters with valid demo shout data
          .sort((a, b) => b.demo_shout_count - a.demo_shout_count); // Sort by demo shout count descending
        
        console.log(`‚öîÔ∏è [DEMO SHOUT] Processed ${finalData.length} characters with demoralizing shout data`);
        console.log(`‚öîÔ∏è [DEMO SHOUT] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                tier1_max: tier1Max,
                tier1_points: tier1Points,
                tier2_max: tier2Max,
                tier2_points: tier2Points,
                tier3_points: tier3Points
            }
        });
        
    } catch (error) {
        console.error('‚ùå [DEMO SHOUT] Error retrieving demoralizing shout data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving demoralizing shout data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get polymorph data for raid logs
app.get('/api/polymorph-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üîÆ [POLYMORPH] Retrieving polymorph data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [POLYMORPH] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for polymorph calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'polymorph'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const pointsPerDivision = settings.points_per_division || 1;
        const polymorphsNeeded = settings.polymorphs_needed || 2;
        const maxPoints = settings.max_points || 5;
        
        console.log(`üîÆ [POLYMORPH] Using dynamic settings: points_per_division=${pointsPerDivision}, polymorphs_needed=${polymorphsNeeded}, max_points=${maxPoints}`);
        
        // Query for "Polymorph" ability usage
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = 'Polymorph'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`üîÆ [POLYMORPH] Found ${result.rows.length} polymorph records for event: ${eventId}`);
        console.log(`üîÆ [POLYMORPH] Raw data sample:`, result.rows.slice(0, 3));
        
        // Process and calculate points for each character
        const finalData = result.rows.map(row => {
            // Parse the polymorph count (might be "6" or "6 (some text)")
            const polymorphMatch = row.ability_value.toString().match(/(\d+)/);
            const polymorphsUsed = polymorphMatch ? parseInt(polymorphMatch[1]) : 0;
            
            // Calculate points: min(max_points, floor(polymorphs / needed) * points_per_division)
            // 1 point per 2 polymorphs, max 5 points
            const points = Math.min(maxPoints, Math.floor(polymorphsUsed / polymorphsNeeded) * pointsPerDivision);
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                polymorphs_used: polymorphsUsed,
                points: points
            };
        }).filter(char => char.polymorphs_used > 0) // Only include characters who used polymorph
          .sort((a, b) => b.points - a.points); // Sort by points descending
        
        console.log(`üîÆ [POLYMORPH] Processed ${finalData.length} characters with polymorphs`);
        console.log(`üîÆ [POLYMORPH] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                points_per_division: pointsPerDivision,
                polymorphs_needed: polymorphsNeeded,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [POLYMORPH] Error retrieving polymorph data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving polymorph data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get power infusion data for raid logs
app.get('/api/power-infusion-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üí´ [POWER_INFUSION] Retrieving power infusion data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [POWER_INFUSION] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for power infusion calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'power_infusion'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const pointsPerDivision = settings.points_per_division || 1;
        const infusionsNeeded = settings.infusions_needed || 2;
        const maxPoints = settings.max_points || 10;
        
        console.log(`üí´ [POWER_INFUSION] Using dynamic settings: points_per_division=${pointsPerDivision}, infusions_needed=${infusionsNeeded}, max_points=${maxPoints}`);
        
        // Query for both power infusion abilities
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_name,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND (ability_name = 'Power Infusion used or gained* on bosses' 
                OR ability_name = 'Power Infusion used or gained* on trash')
            ORDER BY character_name, ability_name
        `, [eventId]);
        
        console.log(`üí´ [POWER_INFUSION] Found ${result.rows.length} power infusion records for event: ${eventId}`);
        console.log(`üí´ [POWER_INFUSION] Raw data sample:`, result.rows.slice(0, 5));
        
        // Group by character and combine abilities
        const characterMap = new Map();
        
        result.rows.forEach(row => {
            const characterName = row.character_name;
            
            if (!characterMap.has(characterName)) {
                characterMap.set(characterName, {
                    character_name: characterName,
                    character_class: row.character_class,
                    boss_infusions: 0,
                    trash_infusions: 0,
                    boss_raw: '',
                    trash_raw: ''
                });
            }
            
            const character = characterMap.get(characterName);
            const abilityValue = row.ability_value.toString();
            
            // Parse ability value: "15 (5 self)" -> 15 - 5 = 10
            // or "5" -> 5
            const mainMatch = abilityValue.match(/^(\d+)/);
            const selfMatch = abilityValue.match(/\((\d+)\s+self\)/i);
            
            const mainCount = mainMatch ? parseInt(mainMatch[1]) : 0;
            const selfCount = selfMatch ? parseInt(selfMatch[1]) : 0;
            const effectiveCount = Math.max(0, mainCount - selfCount);
            
            if (row.ability_name.includes('bosses')) {
                character.boss_infusions = effectiveCount;
                character.boss_raw = abilityValue;
            } else if (row.ability_name.includes('trash')) {
                character.trash_infusions = effectiveCount;
                character.trash_raw = abilityValue;
            }
        });
        
        // Process and calculate points for each character
        const finalData = Array.from(characterMap.values()).map(character => {
            const totalInfusions = character.boss_infusions + character.trash_infusions;
            
            // Calculate points: min(max_points, floor(infusions / needed) * points_per_division)
            // 1 point per 2 power infusions, max 5 points
            const points = Math.min(maxPoints, Math.floor(totalInfusions / infusionsNeeded) * pointsPerDivision);
            
            return {
                character_name: character.character_name,
                character_class: character.character_class,
                boss_infusions: character.boss_infusions,
                trash_infusions: character.trash_infusions,
                total_infusions: totalInfusions,
                boss_raw: character.boss_raw,
                trash_raw: character.trash_raw,
                points: points
            };
        }).filter(char => char.total_infusions > 0) // Only include characters who used power infusion
          .sort((a, b) => b.total_infusions - a.total_infusions); // Sort by total infusions descending
        
        console.log(`üí´ [POWER_INFUSION] Processed ${finalData.length} characters with power infusions`);
        console.log(`üí´ [POWER_INFUSION] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                points_per_division: pointsPerDivision,
                infusions_needed: infusionsNeeded,
                max_points: maxPoints
            }
        });
        
    } catch (error) {
        console.error('‚ùå [POWER_INFUSION] Error retrieving power infusion data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving power infusion data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Get decurses data for raid logs
app.get('/api/decurses-data/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`ü™Ñ [DECURSES] Retrieving decurses data for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Check if table exists
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'sheet_player_abilities'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è [DECURSES] Table does not exist, returning empty data');
            return res.json({ success: true, data: [] });
        }
        
        // Get dynamic settings for decurses calculation
        const settingsResult = await client.query(`
            SELECT setting_name, setting_value
            FROM reward_settings 
            WHERE setting_type = 'decurses'
        `);
        
        const settings = {};
        settingsResult.rows.forEach(row => {
            settings[row.setting_name] = parseFloat(row.setting_value);
        });
        
        const pointsPerDivision = settings.points_per_division || 1;
        const decursesNeeded = settings.decurses_needed || 3;
        const maxPoints = settings.max_points || 10;
        const minPoints = settings.min_points || -10;
        
        console.log(`ü™Ñ [DECURSES] Using dynamic settings: points_per_division=${pointsPerDivision}, decurses_needed=${decursesNeeded}, max_points=${maxPoints}, min_points=${minPoints}`);
        
        // Query for "Remove Lesser Curse" usage by mages
        const result = await client.query(`
            SELECT 
                character_name,
                character_class,
                ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            AND ability_name = 'Remove Lesser Curse'
            AND character_class = 'Mage'
            ORDER BY character_name
        `, [eventId]);
        
        console.log(`ü™Ñ [DECURSES] Found ${result.rows.length} decurse records for event: ${eventId}`);
        console.log(`ü™Ñ [DECURSES] Raw data sample:`, result.rows.slice(0, 3));
        
        if (result.rows.length === 0) {
            return res.json({ 
                success: true, 
                data: [],
                eventId: eventId,
                settings: {
                    points_per_division: pointsPerDivision,
                    decurses_needed: decursesNeeded,
                    max_points: maxPoints,
                    min_points: minPoints,
                    average_decurses: 0
                }
            });
        }
        
        // Parse decurse counts
        const mageData = result.rows.map(row => {
            const decurseMatch = row.ability_value.toString().match(/(\d+)/);
            const decursesUsed = decurseMatch ? parseInt(decurseMatch[1]) : 0;
            
            return {
                character_name: row.character_name,
                character_class: row.character_class,
                decurses_used: decursesUsed
            };
        });
        
        // Calculate average decurses
        const totalDecurses = mageData.reduce((sum, mage) => sum + mage.decurses_used, 0);
        const averageDecurses = mageData.length > 0 ? totalDecurses / mageData.length : 0;
        
        console.log(`ü™Ñ [DECURSES] Average decurses: ${averageDecurses.toFixed(1)} (total: ${totalDecurses}, mages: ${mageData.length})`);
        
        // Calculate points for each mage based on difference from average
        const finalData = mageData.map(mage => {
            const differenceFromAverage = mage.decurses_used - averageDecurses;
            
            // Calculate points: +1 point per 3 above average, -1 point per 3 below average
            const rawPoints = Math.floor(differenceFromAverage / decursesNeeded) * pointsPerDivision;
            
            // Cap at max/min points
            const points = Math.max(minPoints, Math.min(maxPoints, rawPoints));
            
            return {
                character_name: mage.character_name,
                character_class: mage.character_class,
                decurses_used: mage.decurses_used,
                difference_from_average: differenceFromAverage,
                points: points
            };
        }).sort((a, b) => b.decurses_used - a.decurses_used); // Sort by decurses used descending
        
        console.log(`ü™Ñ [DECURSES] Processed ${finalData.length} mages with decurses`);
        console.log(`ü™Ñ [DECURSES] Final data sample:`, finalData.slice(0, 2));
        
        res.json({ 
            success: true, 
            data: finalData,
            eventId: eventId,
            settings: {
                points_per_division: pointsPerDivision,
                decurses_needed: decursesNeeded,
                max_points: maxPoints,
                min_points: minPoints,
                average_decurses: averageDecurses
            }
        });
        
    } catch (error) {
        console.error('‚ùå [DECURSES] Error retrieving decurses data:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Error retrieving decurses data',
            error: error.message 
        });
    } finally {
        if (client) client.release();
    }
});

// Debug endpoint for checking environment variables on Heroku (remove after debugging)
app.get('/api/debug/env', (req, res) => {
    const googleVars = Object.keys(process.env).filter(key => key.startsWith('GOOGLE_'));
    
    res.json({
        NODE_ENV: process.env.NODE_ENV,
        hasGoogleAppsScriptUrl: !!process.env.GOOGLE_APPS_SCRIPT_URL,
        googleVarsCount: googleVars.length,
        googleVars: googleVars,
        scriptUrlLength: process.env.GOOGLE_APPS_SCRIPT_URL ? process.env.GOOGLE_APPS_SCRIPT_URL.length : 0,
        scriptUrlStart: process.env.GOOGLE_APPS_SCRIPT_URL ? process.env.GOOGLE_APPS_SCRIPT_URL.substring(0, 50) + '...' : 'NOT SET'
    });
});

// Migration endpoint to add missing reward settings
app.post('/api/admin/migrate-reward-settings', async (req, res) => {
    let client;
    try {
        console.log('üîß [MIGRATION] Starting reward settings migration...');
        client = await pool.connect();
        
        // Check current reward settings
        const currentSettings = await client.query(`
            SELECT setting_type, setting_name 
            FROM reward_settings 
            ORDER BY setting_type, setting_name
        `);
        
        console.log('üìä [MIGRATION] Current settings:', currentSettings.rows.map(r => `${r.setting_type}.${r.setting_name}`));
        
        // Insert missing reward settings
        const result = await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, description)
            VALUES 
                ('mana_potions', 'threshold', 10, 'Minimum potions needed before earning points'),
                ('mana_potions', 'points_per_potion', 3, 'Points earned per potion above threshold'),
                ('mana_potions', 'max_points', 10, 'Maximum points that can be earned from mana potions'),
                ('runes', 'usage_divisor', 2, 'Number of runes needed per point'),
                ('runes', 'points_per_division', 1, 'Points earned per rune threshold reached'),
                ('interrupts', 'points_per_interrupt', 1, 'Points earned per interrupt'),
                ('interrupts', 'interrupts_needed', 1, 'Number of interrupts needed per point'),
                ('interrupts', 'max_points', 5, 'Maximum points that can be earned from interrupts'),
                ('disarms', 'points_per_disarm', 1, 'Points earned per disarm'),
                ('disarms', 'disarms_needed', 1, 'Number of disarms needed per point'),
                ('disarms', 'max_points', 5, 'Maximum points that can be earned from disarms'),
                ('sunder', 'enabled', 1, 'Whether Sunder Armor tracking is enabled')
            ON CONFLICT (setting_type, setting_name) DO NOTHING
            RETURNING setting_type, setting_name
        `);
        
        // Insert sunder armor point ranges separately (JSON data)
        const sunderResult = await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, setting_json, description)
            VALUES 
                ('sunder', 'point_ranges', 0, '[
                  {"min": 0, "max": 49, "points": -10, "color": "red"},
                  {"min": 50, "max": 99, "points": 0, "color": "gray"},
                  {"min": 100, "max": 119, "points": 5, "color": "green"},
                  {"min": 120, "max": 999, "points": 10, "color": "blue"}
                ]', 'Point ranges for Sunder Armor performance')
            ON CONFLICT (setting_type, setting_name) DO NOTHING
            RETURNING setting_type, setting_name
        `);
        
        console.log(`‚úÖ [MIGRATION] Added ${result.rows.length} new reward settings:`, result.rows);
        console.log(`‚úÖ [MIGRATION] Added ${sunderResult.rows.length} sunder settings:`, sunderResult.rows);
        
        // Get final count
        const finalSettings = await client.query(`
            SELECT setting_type, COUNT(*) as count
            FROM reward_settings 
            GROUP BY setting_type
            ORDER BY setting_type
        `);
        
        res.json({
            success: true,
            message: `Migration completed. Added ${result.rows.length} new settings.`,
            addedSettings: result.rows,
            finalCounts: finalSettings.rows
        });
        
    } catch (error) {
        console.error('‚ùå [MIGRATION] Migration failed:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// --- RPB Tracking Endpoints ---

// Get tracking status for an event (with optional analysis type and logUrl)
app.get('/api/rpb-tracking/:eventId', async (req, res) => {
  try {
    const { eventId } = req.params;
    const { analysisType, logUrl } = req.query; // Optional query parameters
    
    console.log(`üìä [TRACKING] Getting tracking status for event: ${eventId}, type: ${analysisType || 'all'}, logUrl: ${logUrl || 'any'}`);
    
    let query, params;
    
    if (analysisType && logUrl) {
      // Get specific analysis type and logUrl
      query = 'SELECT * FROM rpb_tracking WHERE event_id = $1 AND analysis_type = $2 AND log_url = $3 ORDER BY created_at DESC LIMIT 1';
      params = [eventId, analysisType, logUrl];
    } else if (analysisType) {
      // Get specific analysis type (most recent first)
      query = 'SELECT * FROM rpb_tracking WHERE event_id = $1 AND analysis_type = $2 ORDER BY created_at DESC, id DESC LIMIT 1';
      params = [eventId, analysisType];
    } else {
      // Get all analysis types for the event
      query = 'SELECT * FROM rpb_tracking WHERE event_id = $1 ORDER BY analysis_type, created_at DESC';
      params = [eventId];
    }
    
    const result = await pool.query(query, params);
    
    // Debug: Show all matching records
    if (analysisType === 'world_buffs') {
      console.log(`üîç [TRACKING DEBUG] Found ${result.rows.length} world_buffs records for event ${eventId}:`);
      result.rows.forEach((row, index) => {
        console.log(`üîç [TRACKING DEBUG] Record ${index + 1}:`, {
          id: row.id,
          log_url: row.log_url,
          archive_url: row.archive_url,
          archive_name: row.archive_name,
          created_at: row.created_at,
          rpb_status: row.rpb_status
        });
      });
    }
    
    if (result.rows.length === 0) {
      console.log(`üìä [TRACKING] No tracking found for event: ${eventId}, type: ${analysisType || 'any'}`);
      return res.json({
        success: true,
        hasData: false,
        data: null
      });
    }
    
    if (analysisType) {
      // Return single analysis result (backward compatibility)
      const tracking = result.rows[0];
      console.log(`üìä [TRACKING] Found ${analysisType} tracking for event ${eventId}: ${tracking.rpb_status}`);
      
      res.json({
        success: true,
        hasRPB: true, // Keep for backward compatibility
        hasData: true,
        status: tracking.rpb_status,
        logUrl: tracking.log_url,
        completedAt: tracking.rpb_completed_at,
        archiveUrl: tracking.archive_url,
        archiveName: tracking.archive_name,
        analysisType: tracking.analysis_type
      });
    } else {
      // Return all analysis types
      console.log(`üìä [TRACKING] Found ${result.rows.length} tracking records for event ${eventId}`);
      
      const trackingData = {};
      result.rows.forEach(row => {
        trackingData[row.analysis_type] = {
          status: row.rpb_status,
          logUrl: row.log_url,
          completedAt: row.rpb_completed_at,
          archiveUrl: row.archive_url,
          archiveName: row.archive_name,
          analysisType: row.analysis_type
        };
      });
      
      res.json({
        success: true,
        hasData: true,
        data: trackingData
      });
    }
    
  } catch (error) {
    console.error('‚ùå [TRACKING] Error getting tracking status:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// --- Rewards Snapshot APIs ---
// Stores a locked snapshot of the current raid log panels so managers can make manual adjustments

// Ensure rewards snapshot tables exist
async function ensureRewardsSnapshotTables(client) {
  await client.query(`
    CREATE TABLE IF NOT EXISTS rewards_snapshot_status (
      event_id VARCHAR(100) PRIMARY KEY,
      locked BOOLEAN DEFAULT FALSE,
      locked_by_user_id TEXT,
      locked_by_username TEXT,
      locked_at TIMESTAMP WITH TIME ZONE
    );
  `);

  await client.query(`
    CREATE TABLE IF NOT EXISTS rewards_snapshot_entries (
      id SERIAL PRIMARY KEY,
      event_id VARCHAR(100) NOT NULL,
      panel_key TEXT NOT NULL,
      panel_name TEXT,
      discord_user_id TEXT,
      character_name TEXT NOT NULL,
      character_class TEXT,
      ranking_number_original INTEGER,
      point_value_original INTEGER,
      character_details_original TEXT,
      primary_numeric_original INTEGER,
      aux_json JSONB,
      point_value_edited INTEGER,
      character_details_edited TEXT,
      updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
      UNIQUE(event_id, panel_key, character_name)
    );
  `);
}

// Get snapshot lock status
app.get('/api/rewards-snapshot/:eventId/status', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }

  const { eventId } = req.params;
  let client;
  try {
    client = await pool.connect();
    // Do not attempt to create tables here; just detect presence to avoid 500s on read
    const existsRes = await client.query(
      `SELECT to_regclass('public.rewards_snapshot_status') AS status_table, to_regclass('public.rewards_snapshot_entries') AS entries_table;`
    );
    const haveTables = !!(existsRes.rows && existsRes.rows[0] && existsRes.rows[0].status_table);
    if (!haveTables) {
      return res.json({
        success: true,
        initialized: false,
        status: { locked: false, lockedByUserId: null, lockedByUsername: null, lockedAt: null }
      });
    }

    const statusRes = await client.query(
      `SELECT locked, locked_by_user_id, locked_by_username, locked_at FROM rewards_snapshot_status WHERE event_id = $1`,
      [eventId]
    );
    const row = statusRes.rows[0] || null;
    return res.json({
      success: true,
      initialized: true,
      status: row ? {
        locked: !!row.locked,
        lockedByUserId: row.locked_by_user_id || null,
        lockedByUsername: row.locked_by_username || null,
        lockedAt: row.locked_at || null
      } : { locked: false, lockedByUserId: null, lockedByUsername: null, lockedAt: null }
    });
  } catch (error) {
    console.error('‚ùå [SNAPSHOT] Error fetching status:', error);
    const debug = String(req.query && req.query.debug || '') === '1';
    return res.status(500).json({ 
      success: false, 
      message: 'Error fetching snapshot status',
      error: debug ? (error && (error.detail || error.message || String(error))) : undefined
    });
  } finally {
    if (client) client.release();
  }
});

// Explicit initializer to create snapshot tables (management-only)
app.post('/api/rewards-snapshot/:eventId/init', requireManagement, async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }
  let client;
  try {
    client = await pool.connect();
    await ensureRewardsSnapshotTables(client);
    return res.json({ success: true });
  } catch (error) {
    const debug = String(req.query && req.query.debug || '') === '1';
    console.error('‚ùå [SNAPSHOT INIT] Error creating tables:', error);
    return res.status(500).json({ success: false, message: 'Error creating snapshot tables', error: debug ? (error.detail || error.message || String(error)) : undefined });
  } finally {
    if (client) client.release();
  }
});

// Get snapshot entries data
app.get('/api/rewards-snapshot/:eventId/data', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }

  const { eventId } = req.params;
  let client;
  try {
    client = await pool.connect();
    await ensureRewardsSnapshotTables(client);
    const entriesRes = await client.query(
      `SELECT id, event_id, panel_key, panel_name, discord_user_id, character_name, character_class, ranking_number_original, point_value_original, character_details_original, primary_numeric_original, aux_json, point_value_edited, character_details_edited, updated_at
       FROM rewards_snapshot_entries WHERE event_id = $1 ORDER BY panel_key, ranking_number_original, character_name`,
      [eventId]
    );
    return res.json({ success: true, entries: entriesRes.rows });
  } catch (error) {
    console.error('‚ùå [SNAPSHOT] Error fetching entries:', error);
    return res.status(500).json({ success: false, message: 'Error fetching snapshot entries' });
  } finally {
    if (client) client.release();
  }
});

// Lock snapshot from current view (replace entries for event)
app.post('/api/rewards-snapshot/:eventId/lock', requireManagement, async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }
  const { eventId } = req.params;
  const entries = Array.isArray(req.body && req.body.entries) ? req.body.entries : [];
  if (!entries || entries.length === 0) {
    return res.status(400).json({ success: false, message: 'entries array is required' });
  }

  let client;
  try {
    client = await pool.connect();
    await client.query('BEGIN');
    await ensureRewardsSnapshotTables(client);

    // If already locked, keep owner but allow replacing entries to reflect latest view
    const statusRes = await client.query(`SELECT locked, locked_by_user_id FROM rewards_snapshot_status WHERE event_id = $1`, [eventId]);
    if (statusRes.rows.length === 0) {
      await client.query(
        `INSERT INTO rewards_snapshot_status (event_id, locked, locked_by_user_id, locked_by_username, locked_at)
         VALUES ($1, TRUE, $2, $3, NOW())`,
        [eventId, req.user.id, `${req.user.username}#${req.user.discriminator}`]
      );
    } else if (!statusRes.rows[0].locked) {
      await client.query(
        `UPDATE rewards_snapshot_status SET locked = TRUE, locked_by_user_id = $2, locked_by_username = $3, locked_at = NOW() WHERE event_id = $1`,
        [eventId, req.user.id, `${req.user.username}#${req.user.discriminator}`]
      );
    }

    // Replace entries for event
    await client.query(`DELETE FROM rewards_snapshot_entries WHERE event_id = $1`, [eventId]);

    for (const e of entries) {
      await client.query(
        `INSERT INTO rewards_snapshot_entries (
            event_id, panel_key, panel_name, discord_user_id, character_name, character_class,
            ranking_number_original, point_value_original, character_details_original,
            primary_numeric_original, aux_json, point_value_edited, character_details_edited
         ) VALUES (
            $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
         ) ON CONFLICT (event_id, panel_key, character_name) DO UPDATE SET
            panel_name = EXCLUDED.panel_name,
            discord_user_id = EXCLUDED.discord_user_id,
            character_class = EXCLUDED.character_class,
            ranking_number_original = EXCLUDED.ranking_number_original,
            point_value_original = EXCLUDED.point_value_original,
            character_details_original = EXCLUDED.character_details_original,
            primary_numeric_original = EXCLUDED.primary_numeric_original,
            aux_json = EXCLUDED.aux_json,
            updated_at = NOW()
        `,
        [
          eventId,
          e.panel_key || null,
          e.panel_name || null,
          e.discord_user_id || null,
          e.character_name || null,
          e.character_class || null,
          Number(e.ranking_number_original) || null,
          Number(e.point_value_original) || null,
          e.character_details_original || null,
          Number(e.primary_numeric_original) || null,
          e.aux_json ? JSON.stringify(e.aux_json) : null,
          e.point_value_edited != null ? Number(e.point_value_edited) : null,
          e.character_details_edited != null ? e.character_details_edited : null
        ]
      );
    }

    await client.query('COMMIT');
    return res.json({ success: true });
  } catch (error) {
    if (client) await client.query('ROLLBACK');
    console.error('‚ùå [SNAPSHOT] Error locking snapshot:', error);
    return res.status(500).json({ success: false, message: 'Error locking snapshot' });
  } finally {
    if (client) client.release();
  }
});

// Update a single snapshot entry (edited values)
app.put('/api/rewards-snapshot/:eventId/entry', requireManagement, async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }
  const { eventId } = req.params;
  const {
    panel_key,
    panel_name,
    character_name,
    character_class,
    discord_user_id,
    ranking_number_original,
    point_value_edited,
    character_details_edited
  } = req.body || {};

  if (!panel_key || !character_name) {
    return res.status(400).json({ success: false, message: 'panel_key and character_name are required' });
  }

  let client;
  try {
    client = await pool.connect();
    await ensureRewardsSnapshotTables(client);

    // Require locked snapshot before edits
    const statusRes = await client.query(`SELECT locked FROM rewards_snapshot_status WHERE event_id = $1`, [eventId]);
    const locked = statusRes.rows[0] ? !!statusRes.rows[0].locked : false;
    if (!locked) {
      return res.status(409).json({ success: false, message: 'Snapshot must be locked before editing entries' });
    }

    // Upsert entry
    const upsertRes = await client.query(
      `INSERT INTO rewards_snapshot_entries (
         event_id, panel_key, panel_name, discord_user_id, character_name, character_class, ranking_number_original,
         point_value_edited, character_details_edited
       ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
       ON CONFLICT (event_id, panel_key, character_name) DO UPDATE SET
         panel_name = COALESCE(EXCLUDED.panel_name, rewards_snapshot_entries.panel_name),
         discord_user_id = COALESCE(EXCLUDED.discord_user_id, rewards_snapshot_entries.discord_user_id),
         character_class = COALESCE(EXCLUDED.character_class, rewards_snapshot_entries.character_class),
         ranking_number_original = COALESCE(EXCLUDED.ranking_number_original, rewards_snapshot_entries.ranking_number_original),
         point_value_edited = EXCLUDED.point_value_edited,
         character_details_edited = EXCLUDED.character_details_edited,
         updated_at = NOW()
       RETURNING id, event_id, panel_key, panel_name, discord_user_id, character_name, character_class, ranking_number_original, point_value_original, character_details_original, primary_numeric_original, aux_json, point_value_edited, character_details_edited, updated_at
      `,
      [
        eventId,
        panel_key,
        panel_name || null,
        discord_user_id || null,
        character_name,
        character_class || null,
        ranking_number_original != null ? Number(ranking_number_original) : null,
        point_value_edited != null ? Number(point_value_edited) : null,
        character_details_edited != null ? character_details_edited : null
      ]
    );

    const entry = upsertRes.rows[0];
    return res.json({ success: true, entry });
  } catch (error) {
    console.error('‚ùå [SNAPSHOT] Error updating entry:', error);
    return res.status(500).json({ success: false, message: 'Error updating snapshot entry' });
  } finally {
    if (client) client.release();
  }
});

// --- Google Sheet Import Endpoints ---

// Import World Buffs or Frost Resistance data from Google Sheet
app.post('/api/import-world-buffs', async (req, res) => {
  const { sheetUrl, eventId, analysisType = 'world_buffs' } = req.body;
  
  try {
    
    if (!sheetUrl || !eventId) {
      return res.status(400).json({
        success: false,
        message: 'Sheet URL and Event ID are required'
      });
    }

    const logPrefix = analysisType === 'frost_resistance' ? 'üßä [FROST RES IMPORT]' : 'üåç [WORLD BUFFS IMPORT]';
    console.log(`${logPrefix} Starting import for event ${eventId} from ${sheetUrl}`);

    // Extract sheet ID from URL
    const sheetIdMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
    if (!sheetIdMatch) {
      return res.status(400).json({
        success: false,
        message: 'Invalid Google Sheets URL format'
      });
    }

    const sheetId = sheetIdMatch[1];
    
    // Try multiple CSV export methods (ordered to try more flexible options first)
    const csvUrls = [
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`, // Gets first sheet with data
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&single=true`, // Single sheet export
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`, // Specifically first tab
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&single=true&gid=0` // Single sheet, first tab
    ];

    let csvResponse = null;
    let successfulUrl = null;

    for (const csvUrl of csvUrls) {
      try {
        console.log(`${logPrefix} Trying CSV URL: ${csvUrl}`);
        
        csvResponse = await axios.get(csvUrl, {
          timeout: 60000, // Increased to 60 seconds
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
          },
          validateStatus: function (status) {
            return status >= 200 && status < 300;
          },
          maxRedirects: 5
        });
        
        // Check if response is actually CSV (not HTML error page)
        const contentType = csvResponse.headers['content-type'] || '';
        if (contentType.includes('text/csv') || contentType.includes('text/plain') || 
            !csvResponse.data.includes('<!DOCTYPE html>')) {
          successfulUrl = csvUrl;
          console.log(`‚úÖ ${logPrefix} Successfully fetched CSV from: ${csvUrl}`);
          break;
        } else {
          console.log(`‚ùå ${logPrefix} Response was HTML, not CSV from: ${csvUrl}`);
          csvResponse = null;
        }
      } catch (error) {
        console.log(`‚ùå ${logPrefix} Failed to fetch from ${csvUrl}: ${error.message}`);
        continue;
      }
    }

    if (!csvResponse) {
      throw new Error('Unable to fetch CSV data from any of the attempted URLs. Please ensure the sheet is publicly accessible.');
    }

    const csvData = csvResponse.data;
    console.log(`${logPrefix} Received CSV data, length: ${csvData.length} characters`);
    console.log(`${logPrefix} First 500 characters of CSV data:`, csvData.substring(0, 500));
    console.log(`${logPrefix} CSV data (first 10 lines):`, csvData.split('\n').slice(0, 10));

    let dbResult;
    let sheetTitle = 'Unknown Sheet';

    if (analysisType === 'frost_resistance') {
      // Parse Frost Resistance CSV data
      const parsedData = parseFrostResCSV(csvData, eventId, analysisType);
      
      // Store frost resistance data in database
      dbResult = await storeFrostResDataInDB(parsedData, eventId, sheetUrl, sheetTitle, analysisType);
      
      const actionMessage = 'imported'; // Frost res doesn't have wasReplacement logic yet
      console.log(`${logPrefix} Successfully ${actionMessage} ${dbResult.playerCount} players with frost resistance data`);

      res.json({
        success: true,
        message: `Successfully imported ${dbResult.playerCount} players with frost resistance data`,
        eventId: eventId,
        sheetTitle: sheetTitle,
        playerCount: dbResult.playerCount,
        frostResCount: dbResult.playerCount // Use playerCount as frostResCount for consistency
      });
    } else {
      // Parse World Buffs CSV data
      const parsedData = parseWorldBuffsCSV(csvData, eventId, analysisType);
      
      if (!parsedData.success) {
        return res.status(400).json(parsedData);
      }

      // Store world buffs data in database
      dbResult = await storeWorldBuffsDataInDB(parsedData.data, eventId, sheetUrl, parsedData.sheetTitle, analysisType);

      const actionMessage = dbResult.wasReplacement ? 'replaced' : 'imported';
      console.log(`${logPrefix} Successfully ${actionMessage} ${dbResult.playerCount} players with ${dbResult.buffsCount} buff entries`);

      res.json({
        success: true,
        message: dbResult.wasReplacement 
          ? `Successfully replaced existing data with ${dbResult.playerCount} players and ${dbResult.buffsCount} buff entries`
          : `Successfully imported ${dbResult.playerCount} players with ${dbResult.buffsCount} buff entries`,
        eventId: eventId,
        sheetTitle: parsedData.sheetTitle,
        playerCount: dbResult.playerCount,
        buffsCount: dbResult.buffsCount,
        wasReplacement: dbResult.wasReplacement
      });
    }

  } catch (error) {
    const logPrefix = analysisType === 'frost_resistance' ? 'üßä [FROST RES IMPORT]' : 'üåç [WORLD BUFFS IMPORT]';
    console.error(`‚ùå ${logPrefix} Error importing sheet:`, error);
    
    let errorMessage = analysisType === 'frost_resistance' ? 'Failed to import Frost Resistance data' : 'Failed to import World Buffs data';
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      errorMessage = 'Unable to connect to Google Sheets. Please check the URL and try again.';
    } else if (error.response && error.response.status === 404) {
      errorMessage = 'Sheet not found or not publicly accessible. Please make sure the sheet is shared publicly.';
    } else if (error.response && error.response.status === 403) {
      errorMessage = 'Access denied to the sheet. Please make sure the sheet is shared publicly.';
    }

    res.status(500).json({
      success: false,
      message: errorMessage,
      error: error.message
    });
  }
});

// Import data from Google Sheet
app.post('/api/import-sheet', async (req, res) => {
  try {
    const { sheetUrl, eventId } = req.body;
    
    if (!sheetUrl || !eventId) {
      return res.status(400).json({
        success: false,
        message: 'Sheet URL and Event ID are required'
      });
    }

    console.log(`üìä [SHEET IMPORT] Starting import for event ${eventId} from ${sheetUrl}`);

    // Extract sheet ID from URL
    const sheetIdMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
    if (!sheetIdMatch) {
      return res.status(400).json({
        success: false,
        message: 'Invalid Google Sheets URL format'
      });
    }

    const sheetId = sheetIdMatch[1];
    
    // Try multiple CSV export methods (ordered to try more flexible options first)
    const csvUrls = [
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`, // Gets first sheet with data
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&single=true`, // Single sheet export
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`, // Specifically first tab
      `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&single=true&gid=0` // Single sheet, first tab
    ];

    let csvResponse = null;
    let successfulUrl = null;

    for (const csvUrl of csvUrls) {
      try {
        console.log(`üìä [SHEET IMPORT] Trying CSV URL: ${csvUrl}`);
        
        csvResponse = await axios.get(csvUrl, {
          timeout: 60000, // Increased to 60 seconds
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
          },
          validateStatus: function (status) {
            return status >= 200 && status < 300;
          },
          maxRedirects: 5
        });
        
        // Check if response is actually CSV (not HTML error page)
        const contentType = csvResponse.headers['content-type'] || '';
        if (contentType.includes('text/csv') || contentType.includes('text/plain') || 
            !csvResponse.data.includes('<!DOCTYPE html>')) {
          successfulUrl = csvUrl;
          console.log(`‚úÖ [SHEET IMPORT] Successfully fetched CSV from: ${csvUrl}`);
          break;
        } else {
          console.log(`‚ùå [SHEET IMPORT] Response was HTML, not CSV from: ${csvUrl}`);
          csvResponse = null;
        }
      } catch (error) {
        console.log(`‚ùå [SHEET IMPORT] Failed to fetch from ${csvUrl}: ${error.message}`);
        continue;
      }
    }

    if (!csvResponse) {
      throw new Error('Unable to fetch CSV data from any of the attempted URLs. Please ensure the sheet is publicly accessible.');
    }

    const csvData = csvResponse.data;
    console.log(`üìä [SHEET IMPORT] Received CSV data, length: ${csvData.length} characters`);
    console.log(`üìä [SHEET IMPORT] First 500 characters of CSV data:`, csvData.substring(0, 500));
    console.log(`üìä [SHEET IMPORT] Lines 5-10 of CSV data:`, csvData.split('\n').slice(4, 10));

    // Parse CSV data
    const parsedData = parseGoogleSheetCSV(csvData, eventId);
    
    if (!parsedData.success) {
      return res.status(400).json(parsedData);
    }

    // Store data in database
    const dbResult = await storeSheetDataInDB(parsedData.data, eventId, sheetUrl, parsedData.sheetTitle);

    const actionMessage = dbResult.wasReplacement ? 'replaced' : 'imported';
    console.log(`üìä [SHEET IMPORT] Successfully ${actionMessage} ${dbResult.playerCount} players with ${dbResult.abilitiesCount} abilities`);

    // Fetch the stored data to return
    const storedData = await getStoredSheetData(eventId);

    res.json({
      success: true,
      message: dbResult.wasReplacement 
        ? `Successfully replaced existing data with ${dbResult.playerCount} players and ${dbResult.abilitiesCount} abilities`
        : `Successfully imported ${dbResult.playerCount} players with ${dbResult.abilitiesCount} abilities`,
      eventId: eventId,
      sheetTitle: parsedData.sheetTitle,
      playerCount: dbResult.playerCount,
      abilitiesCount: dbResult.abilitiesCount,
      playerData: storedData,
      wasReplacement: dbResult.wasReplacement
    });

  } catch (error) {
    console.error('‚ùå [SHEET IMPORT] Error importing sheet:', error);
    
    let errorMessage = 'Failed to import sheet data';
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      errorMessage = 'Unable to connect to Google Sheets. Please check the URL and try again.';
    } else if (error.response && error.response.status === 404) {
      errorMessage = 'Sheet not found or not publicly accessible. Please make sure the sheet is shared publicly.';
    } else if (error.response && error.response.status === 403) {
      errorMessage = 'Access denied to the sheet. Please make sure the sheet is shared publicly.';
    }

    res.status(500).json({
      success: false,
      message: errorMessage,
      error: error.message
    });
  }
});

// Debug endpoint to see raw CSV data
app.post('/api/debug-csv', async (req, res) => {
  try {
    const { sheetUrl } = req.body;
    const sheetIdMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
    if (!sheetIdMatch) {
      return res.status(400).json({ error: 'Invalid URL' });
    }

    const sheetId = sheetIdMatch[1];
    const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
    
    const csvResponse = await axios.get(csvUrl, {
      timeout: 30000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      }
    });

    const csvData = csvResponse.data;
    const lines = csvData.split('\n');
    
    res.json({
      success: true,
      totalLines: lines.length,
      first10Lines: lines.slice(0, 10),
      row7: lines[6] || 'Row 7 not found',
      row8: lines[7] || 'Row 8 not found',
      row9: lines[8] || 'Row 9 not found'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Helper function to parse Google Sheet CSV data
function parseGoogleSheetCSV(csvData, eventId) {
  try {
    console.log(`üìä [SHEET PARSER] Starting CSV parsing for event ${eventId}`);
    
    // Split CSV into rows
    const rows = csvData.split('\n').map(row => {
      // Simple CSV parser - handles basic quoted fields
      const cells = [];
      let currentCell = '';
      let inQuotes = false;
      
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        if (char === '"' && (i === 0 || row[i-1] === ',')) {
          inQuotes = true;
        } else if (char === '"' && inQuotes && (i === row.length - 1 || row[i+1] === ',')) {
          inQuotes = false;
        } else if (char === ',' && !inQuotes) {
          cells.push(currentCell.trim());
          currentCell = '';
        } else {
          currentCell += char;
        }
      }
      cells.push(currentCell.trim());
      return cells;
    });

    console.log(`üìä [SHEET PARSER] Parsed ${rows.length} rows`);

    // Get sheet title from first row if available
    let sheetTitle = 'Unknown Sheet';
    if (rows.length > 0 && rows[0].length > 0) {
      sheetTitle = rows[0][0] || 'Unknown Sheet';
    }

    // Find row 8 (index 7) which contains character names and classes  
    if (rows.length < 8) {
      throw new Error('Sheet does not have enough rows. Expected at least 8 rows.');
    }

    const characterRow = rows[7]; // Row 8 (0-indexed)
    console.log(`üìä [SHEET PARSER] Character row (row 8): ${characterRow.length} columns`);

    // Parse character names and their classes
    const characters = parseCharacterRow(characterRow);
    console.log(`üìä [SHEET PARSER] Found ${characters.length} characters`);

    // Parse ability data starting from row 10 (index 9)
    const abilityData = [];
    for (let rowIndex = 9; rowIndex < rows.length; rowIndex++) {
      const row = rows[rowIndex];
      if (row.length === 0 || row[0] === '') continue; // Skip empty rows

      // Skip rows that don't have any data for our characters
      let hasData = false;
      for (const char of characters) {
        if (char.columnIndex < row.length && row[char.columnIndex] && row[char.columnIndex].trim() !== '') {
          hasData = true;
          break;
        }
      }
      if (!hasData) continue;

      // Process each character's value for this ability
      characters.forEach(char => {
        if (char.columnIndex < row.length) {
          const value = row[char.columnIndex];
          if (value && value.trim() !== '') {
            // Get ability name specific to this character's class
            const characterAbilityName = getAbilityNameForCharacter(row, char, rowIndex + 1);
            if (characterAbilityName) {
              abilityData.push({
                character_name: char.name,
                character_class: char.class,
                ability_name: characterAbilityName,
                ability_value: value.trim(),
                row_number: rowIndex + 1,
                column_number: char.columnIndex + 1
              });
            }
          }
        }
      });
    }

    console.log(`üìä [SHEET PARSER] Parsed ${abilityData.length} ability entries`);

    return {
      success: true,
      data: abilityData,
      sheetTitle: sheetTitle
    };

  } catch (error) {
    console.error('‚ùå [SHEET PARSER] Error parsing CSV:', error);
    return {
      success: false,
      message: `Failed to parse sheet data: ${error.message}`
    };
  }
}

// Helper function to parse character row and identify classes
function parseCharacterRow(row) {
  const characters = [];
  const classLabels = ['Druids', 'Hunters', 'Mages', 'Priests', 'Rogues', 'Shamans', 'Paladins', 'Warlocks', 'Warriors'];
  
  let currentClass = null;
  let currentClassColumn = -1;

  for (let i = 0; i < row.length; i++) {
    const cell = row[i];
    
    if (classLabels.includes(cell)) {
      // Found a class label
      currentClass = cell.replace('s', ''); // Remove 's' to get singular form
      currentClassColumn = i;
      console.log(`üìä [SHEET PARSER] Found class ${currentClass} at column ${i + 1}`);
    } else if (currentClass && cell && cell.trim() !== '') {
      // Found a character name under current class
      characters.push({
        name: cell.trim(),
        class: currentClass,
        columnIndex: i,
        classColumnIndex: currentClassColumn
      });
      console.log(`üìä [SHEET PARSER] Found character ${cell.trim()} (${currentClass}) at column ${i + 1}`);
    }
  }

  return characters;
}

// Helper function to get ability name for a specific character
function getAbilityNameForCharacter(row, character, rowNumber) {
  // First, try to find ability name in this character's class column
  if (character.classColumnIndex >= 0 && character.classColumnIndex < row.length) {
    const abilityName = row[character.classColumnIndex];
    if (abilityName && abilityName.trim() !== '') {
      return abilityName.trim();
    }
  }

  // If no class-specific ability found, check column B (index 1) for general abilities
  if (row.length > 1 && row[1] && row[1].trim() !== '') {
    return row[1].trim();
  }

  return null;
}

// Helper function to store sheet data in database
async function storeSheetDataInDB(abilityData, eventId, sheetUrl, sheetTitle) {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');

    // Check if there are existing entries for this event ID
    const existingCheck = await client.query(`
      SELECT COUNT(*) as count FROM sheet_imports WHERE event_id = $1
    `, [eventId]);

    const hasExistingData = parseInt(existingCheck.rows[0].count) > 0;

    if (hasExistingData) {
      console.log(`üóëÔ∏è [SHEET DB] Found existing data for event ${eventId}, deleting old entries...`);
      
      // Delete existing player abilities for this event (cascade will handle this, but let's be explicit)
      await client.query(`
        DELETE FROM sheet_player_abilities WHERE event_id = $1
      `, [eventId]);
      
      // Delete existing sheet imports for this event
      await client.query(`
        DELETE FROM sheet_imports WHERE event_id = $1
      `, [eventId]);
      
      console.log(`‚úÖ [SHEET DB] Successfully deleted old data for event ${eventId}`);
    }

    // Insert new sheet import record
    const importResult = await client.query(`
      INSERT INTO sheet_imports (event_id, sheet_url, sheet_title)
      VALUES ($1, $2, $3)
      RETURNING id
    `, [eventId, sheetUrl, sheetTitle]);

    const sheetImportId = importResult.rows[0].id;

    // Insert new ability data
    let abilitiesCount = 0;
    const playerCounts = new Set();

    for (const ability of abilityData) {
      await client.query(`
        INSERT INTO sheet_player_abilities 
        (sheet_import_id, event_id, character_name, character_class, ability_name, ability_value, row_number, column_number)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      `, [
        sheetImportId,
        eventId,
        ability.character_name,
        ability.character_class,
        ability.ability_name,
        ability.ability_value,
        ability.row_number,
        ability.column_number
      ]);
      
      abilitiesCount++;
      playerCounts.add(ability.character_name);
    }

    await client.query('COMMIT');
    console.log(`üìä [SHEET DB] Stored ${abilitiesCount} abilities for ${playerCounts.size} players`);

    return {
      playerCount: playerCounts.size,
      abilitiesCount: abilitiesCount,
      wasReplacement: hasExistingData
    };

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Helper function to get stored sheet data
async function getStoredSheetData(eventId) {
  const result = await pool.query(`
    SELECT character_name, character_class, ability_name, ability_value, row_number, column_number
    FROM sheet_player_abilities 
    WHERE event_id = $1 
    ORDER BY character_name, ability_name
    LIMIT 5000
  `, [eventId]);

  return result.rows;
}

// Helper function to parse World Buffs CSV data
function parseWorldBuffsCSV(csvData, eventId, analysisType) {
  try {
    console.log(`üåç [WORLD BUFFS PARSER] Starting CSV parsing for event ${eventId}`);
    
    // Split CSV into rows
    const rows = csvData.split('\n').map(row => {
      // Simple CSV parser - handles basic quoted fields
      const cells = [];
      let currentCell = '';
      let inQuotes = false;
      
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        if (char === '"' && (i === 0 || row[i-1] === ',')) {
          inQuotes = true;
        } else if (char === '"' && inQuotes && (i === row.length - 1 || row[i+1] === ',')) {
          inQuotes = false;
        } else if (char === ',' && !inQuotes) {
          cells.push(currentCell.trim());
          currentCell = '';
        } else {
          currentCell += char;
        }
      }
      cells.push(currentCell.trim());
      return cells;
    });

    console.log(`üåç [WORLD BUFFS PARSER] Parsed ${rows.length} rows`);

    // Get sheet title from first row if available
    let sheetTitle = 'World Buffs Analysis';
    if (rows.length > 0 && rows[0].length > 0) {
      sheetTitle = rows[0][0] || 'World Buffs Analysis';
    }

    // Check if we have enough rows
    if (rows.length < 5) {
      throw new Error('Sheet does not have enough rows. Expected at least 5 rows.');
    }

    // Get buff names from row 4 (index 3) - columns E through L (indices 4-11)
    const buffRow = rows[3]; // Row 4 (0-indexed)
    const buffNames = [];
    const buffColumns = [4, 5, 6, 7, 8, 9, 10, 11]; // E, F, G, H, I, J, K, L
    
    buffColumns.forEach((colIndex, arrayIndex) => {
      if (colIndex < buffRow.length && buffRow[colIndex] && buffRow[colIndex].trim() !== '') {
        buffNames.push({
          name: buffRow[colIndex].trim(),
          columnIndex: colIndex
        });
      }
    });

    console.log(`üåç [WORLD BUFFS PARSER] Found ${buffNames.length} buff types:`, buffNames.map(b => b.name));

    // Parse player data starting from row 5 (index 4)
    const buffData = [];
    
    for (let rowIndex = 4; rowIndex < rows.length; rowIndex++) {
      const row = rows[rowIndex];
      if (row.length === 0) continue; // Skip empty rows
      
      // Get player name from column B (index 1)
      const playerName = row[1] ? row[1].trim() : '';
      if (!playerName || playerName === '') continue; // Skip rows without player names
      
      // Get amount and score summaries from columns C and D (indices 2, 3)
      const amountSummary = row[2] ? row[2].trim() : '';
      const scoreSummary = row[3] ? row[3].trim() : '';
      
      console.log(`üåç [WORLD BUFFS PARSER] Processing player: ${playerName}, Amount: ${amountSummary}, Score: ${scoreSummary}`);
      
      // Process each buff for this player
      let addedAnyBuff = false;
      buffNames.forEach(buff => {
        if (buff.columnIndex < row.length) {
          const buffValue = row[buff.columnIndex] ? row[buff.columnIndex].trim() : '';
          
          // Determine color status based on buff value content
          const colorStatus = determineBuffColorStatus(buffValue);
          
          if (buffValue !== '') {
            buffData.push({
              character_name: playerName,
              buff_name: buff.name,
              buff_value: buffValue,
              color_status: colorStatus.status,
              background_color: colorStatus.color,
              amount_summary: amountSummary,
              score_summary: scoreSummary,
              row_number: rowIndex + 1,
              column_number: buff.columnIndex + 1,
              analysis_type: analysisType
            });
            addedAnyBuff = true;
          }
        }
      });

      // If player has 0/required buffs (no individual buff cells), still persist a summary row
      // so downstream endpoints can compute deductions based on amount_summary.
      if (!addedAnyBuff && amountSummary) {
        buffData.push({
          character_name: playerName,
          buff_name: '__SUMMARY__',
          buff_value: '',
          color_status: null,
          background_color: null,
          amount_summary: amountSummary,
          score_summary: scoreSummary,
          row_number: rowIndex + 1,
          column_number: 0,
          analysis_type: analysisType
        });
      }
    }

    console.log(`üåç [WORLD BUFFS PARSER] Parsed ${buffData.length} buff entries`);

    return {
      success: true,
      data: buffData,
      sheetTitle: sheetTitle
    };

  } catch (error) {
    console.error('‚ùå [WORLD BUFFS PARSER] Error parsing CSV:', error);
    return {
      success: false,
      message: `Failed to parse World Buffs data: ${error.message}`
    };
  }
}

// Helper function for World Buffs data - simplified without color detection
function determineBuffColorStatus(buffValue) {
  // Just return the raw value without trying to detect colors from CSV
  // CSV exports don't contain background color information
  return { status: null, color: null };
}

// Parse Frost Resistance CSV data
function parseFrostResCSV(csvData, eventId, analysisType) {
  console.log('üìä [FROST RES PARSER] Starting to parse CSV data...');
  
  // Split CSV into rows with proper quoted field handling
  const rows = csvData.split('\n').map(row => {
    // Simple CSV parser - handles basic quoted fields
    const cells = [];
    let currentCell = '';
    let inQuotes = false;
    
    for (let i = 0; i < row.length; i++) {
      const char = row[i];
      if (char === '"' && (i === 0 || row[i-1] === ',')) {
        inQuotes = true;
      } else if (char === '"' && inQuotes && (i === row.length - 1 || row[i+1] === ',')) {
        inQuotes = false;
      } else if (char === ',' && !inQuotes) {
        cells.push(currentCell.trim());
        currentCell = '';
      } else {
        currentCell += char;
      }
    }
    cells.push(currentCell.trim());
    return cells;
  });
  
  const frostResData = [];
  
  // Process data starting from row 5 (index 4)
  for (let rowIndex = 4; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    if (!row || row.length < 3) continue;
    
    const playerName = row[1] ? row[1].trim() : ''; // Column B (index 1)
    const frostResValue = row[2] ? row[2].trim() : ''; // Column C (index 2)
    
    if (playerName !== '' && frostResValue !== '') {
      frostResData.push({
        character_name: playerName,
        frost_resistance: frostResValue,
        row_number: rowIndex + 1,
        analysis_type: analysisType
      });
      
      console.log(`üìä [FROST RES PARSER] Row ${rowIndex + 1}: ${playerName} = ${frostResValue} FR`);
    }
  }
  
  console.log(`üìä [FROST RES PARSER] Parsed ${frostResData.length} frost resistance entries`);
  return frostResData;
}

// Helper function to store World Buffs data in database
async function storeWorldBuffsDataInDB(buffData, eventId, sheetUrl, sheetTitle, analysisType) {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');

    // Check if there are existing entries for this event ID and analysis type
    const existingCheck = await client.query(`
      SELECT COUNT(*) as count FROM sheet_imports 
      WHERE event_id = $1 AND sheet_url = $2
    `, [eventId, sheetUrl]);

    const hasExistingData = parseInt(existingCheck.rows[0].count) > 0;

    if (hasExistingData) {
      console.log(`üóëÔ∏è [WORLD BUFFS DB] Found existing data for event ${eventId}, deleting old entries...`);
      
      // Delete existing buffs data for this event and analysis type
      await client.query(`
        DELETE FROM sheet_players_buffs 
        WHERE event_id = $1 AND analysis_type = $2
      `, [eventId, analysisType]);
      
      // Delete existing sheet imports for this event and URL
      await client.query(`
        DELETE FROM sheet_imports WHERE event_id = $1 AND sheet_url = $2
      `, [eventId, sheetUrl]);
      
      console.log(`‚úÖ [WORLD BUFFS DB] Successfully deleted old data for event ${eventId}`);
    }

    // Insert new sheet import record
    const importResult = await client.query(`
      INSERT INTO sheet_imports (event_id, sheet_url, sheet_title)
      VALUES ($1, $2, $3)
      RETURNING id
    `, [eventId, sheetUrl, sheetTitle]);

    const sheetImportId = importResult.rows[0].id;

    // Insert new buff data
    let buffsCount = 0;
    const playerCounts = new Set();

    for (const buff of buffData) {
      await client.query(`
        INSERT INTO sheet_players_buffs 
        (sheet_import_id, event_id, character_name, buff_name, buff_value, color_status, background_color, amount_summary, score_summary, row_number, column_number, analysis_type)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      `, [
        sheetImportId,
        eventId,
        buff.character_name,
        buff.buff_name,
        buff.buff_value,
        buff.color_status,
        buff.background_color,
        buff.amount_summary,
        buff.score_summary,
        buff.row_number,
        buff.column_number,
        buff.analysis_type
      ]);
      
      buffsCount++;
      playerCounts.add(buff.character_name);
    }

    await client.query('COMMIT');
    console.log(`üåç [WORLD BUFFS DB] Stored ${buffsCount} buff entries for ${playerCounts.size} players`);

    return {
      playerCount: playerCounts.size,
      buffsCount: buffsCount,
      wasReplacement: hasExistingData
    };

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Helper function to store Frost Resistance data in database
async function storeFrostResDataInDB(frostResData, eventId, sheetUrl, sheetTitle, analysisType) {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');

    // Check if there are existing entries for this event ID and analysis type
    const existingCheck = await client.query(`
      SELECT COUNT(*) as count FROM sheet_imports 
      WHERE event_id = $1 AND sheet_url = $2
    `, [eventId, sheetUrl]);

    const hasExistingData = parseInt(existingCheck.rows[0].count) > 0;

    if (hasExistingData) {
      console.log('üìä [FROST RES STORE] Found existing data, replacing...');
      
      // Delete existing frost resistance data for this event and sheet
      await client.query(`
        DELETE FROM sheet_players_frostres 
        WHERE event_id = $1 AND sheet_import_id IN (
          SELECT id FROM sheet_imports WHERE event_id = $1 AND sheet_url = $2
        )
      `, [eventId, sheetUrl]);
      
      // Update existing sheet_imports record
      const updateImport = await client.query(`
        UPDATE sheet_imports 
        SET imported_at = CURRENT_TIMESTAMP, sheet_title = $3
        WHERE event_id = $1 AND sheet_url = $2
        RETURNING id
      `, [eventId, sheetUrl, sheetTitle]);
      
      var sheetImportId = updateImport.rows[0].id;
    } else {
      console.log('üìä [FROST RES STORE] Creating new import record...');
      
      // Create new sheet_imports record
      const newImport = await client.query(`
        INSERT INTO sheet_imports (event_id, sheet_url, sheet_title, imported_at)
        VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
        RETURNING id
      `, [eventId, sheetUrl, sheetTitle]);
      
      var sheetImportId = newImport.rows[0].id;
    }

    // Insert frost resistance data
    if (frostResData.length > 0) {
      const insertQuery = `
        INSERT INTO sheet_players_frostres 
        (sheet_import_id, event_id, character_name, frost_resistance, row_number, analysis_type)
        VALUES ($1, $2, $3, $4, $5, $6)
      `;

      for (const frostRes of frostResData) {
        await client.query(insertQuery, [
          sheetImportId,
          eventId,
          frostRes.character_name,
          frostRes.frost_resistance,
          frostRes.row_number,
          frostRes.analysis_type
        ]);
      }
    }

    await client.query('COMMIT');
    
    console.log(`‚úÖ [FROST RES STORE] Successfully stored ${frostResData.length} frost resistance entries`);
    return {
      success: true,
      playerCount: frostResData.length,
      sheetImportId: sheetImportId
    };

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå [FROST RES STORE] Error storing data:', error);
    throw error;
  } finally {
    client.release();
  }
}

// Debug endpoint to check database data
app.get('/api/debug-db/:eventId', async (req, res) => {
  try {
    const { eventId } = req.params;
    
    // Check sheet_imports table
    const importsResult = await pool.query(`
      SELECT id, event_id, sheet_url, sheet_title, imported_at 
      FROM sheet_imports 
      WHERE event_id = $1 
      ORDER BY imported_at DESC
    `, [eventId]);
    
    // Check sheet_player_abilities table - get summary
    const abilitiesCountResult = await pool.query(`
      SELECT 
        character_name, 
        character_class, 
        COUNT(*) as ability_count
      FROM sheet_player_abilities 
      WHERE event_id = $1 
      GROUP BY character_name, character_class 
      ORDER BY character_name
    `, [eventId]);
    
    // Get sample abilities for Ariela to verify the parsing fix
    const arielaSampleResult = await pool.query(`
      SELECT 
        character_name, 
        character_class, 
        ability_name, 
        ability_value, 
        row_number, 
        column_number
      FROM sheet_player_abilities 
      WHERE event_id = $1 AND character_name = 'Ariela'
      ORDER BY ability_name
      LIMIT 10
    `, [eventId]);
    
    // Get total counts
    const totalResult = await pool.query(`
      SELECT 
        COUNT(DISTINCT character_name) as total_players,
        COUNT(*) as total_abilities
      FROM sheet_player_abilities 
      WHERE event_id = $1
    `, [eventId]);
    
    res.json({
      success: true,
      eventId,
      imports: importsResult.rows,
      playerCounts: abilitiesCountResult.rows,
      arielaSample: arielaSampleResult.rows,
      totals: totalResult.rows[0]
    });
    
  } catch (error) {
    console.error('Database debug error:', error);
    res.status(500).json({
      success: false,
      message: 'Database query failed',
      error: error.message
    });
  }
});

// Update tracking status for an event
app.post('/api/rpb-tracking/:eventId', async (req, res) => {
  try {
    const { eventId } = req.params;
    const { logUrl, status, archiveUrl, archiveName, analysisType = 'rpb' } = req.body;
    
    console.log(`üìä [TRACKING] Updating ${analysisType} status for event ${eventId}: ${status}`);
    
    // First, try to insert a new record
    try {
      const insertResult = await pool.query(
        `INSERT INTO rpb_tracking (event_id, log_url, analysis_type, rpb_status, rpb_completed_at, archive_url, archive_name)
         VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
        [
          eventId, 
          logUrl, 
          analysisType,
          status, 
          status === 'completed' ? new Date() : null,
          archiveUrl || null,
          archiveName || null
        ]
      );
      
      console.log(`‚úÖ [TRACKING] Created new ${analysisType} tracking for event ${eventId}`);
      return res.json({
        success: true,
        tracking: insertResult.rows[0]
      });
      
    } catch (insertError) {
      // If insert fails due to unique constraint, update instead
      if (insertError.code === '23505') { // unique_violation
        console.log(`üìä [TRACKING] Record exists, updating ${analysisType} tracking for event ${eventId}`);
        
        const updateResult = await pool.query(
          `UPDATE rpb_tracking 
           SET rpb_status = $4, 
               rpb_completed_at = $5,
               archive_url = COALESCE($6, archive_url),
               archive_name = COALESCE($7, archive_name),
               updated_at = CURRENT_TIMESTAMP
           WHERE event_id = $1 AND log_url = $2 AND analysis_type = $3
           RETURNING *`,
          [
            eventId, 
            logUrl, 
            analysisType,
            status, 
            status === 'completed' ? new Date() : null,
            archiveUrl,
            archiveName
          ]
        );
        
        console.log(`‚úÖ [TRACKING] Updated ${analysisType} tracking for event ${eventId}`);
        return res.json({
          success: true,
          tracking: updateResult.rows[0]
        });
      } else {
        throw insertError;
      }
    }
    
  } catch (error) {
    console.error(`‚ùå [TRACKING] Error updating ${req.body.analysisType || 'rpb'} status:`, error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ====================================
// CHANNEL FILTER API ENDPOINTS
// ====================================

// Get channel filter settings for admin
app.get('/api/admin/channel-filters', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Unauthorized' });
  }

  // Check if user has management role
  const hasRole = await hasManagementRoleById(req.user.id);
  if (!hasRole) {
    return res.status(403).json({ success: false, message: 'Management role required' });
  }

  try {
    // Ensure channel_filters table exists and has expected columns
    await pool.query(`
      CREATE TABLE IF NOT EXISTS channel_filters (
        channel_id TEXT PRIMARY KEY,
        channel_name TEXT,
        is_visible BOOLEAN DEFAULT true,
        is_nax BOOLEAN DEFAULT false,
        webhook_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await pool.query(`ALTER TABLE channel_filters ADD COLUMN IF NOT EXISTS webhook_url TEXT`);
    await pool.query(`ALTER TABLE channel_filters ADD COLUMN IF NOT EXISTS is_nax BOOLEAN DEFAULT false`);

    // Get both upcoming and completed events to find all channels with raids
    const [upcomingEventsResponse, historicEventsResponse] = await Promise.all([
      fetchEventsFromAPI().then(events => enrichEventsWithDiscordChannelNames(events)),
      (getCachedHistoricEvents() || fetchHistoricEventsFromAPI().then(events => enrichHistoricEventsWithDiscordChannelNames(events)))
    ]);
    
    // Filter to upcoming events only for upcoming
    const today = new Date();
    const upcomingEvents = upcomingEventsResponse.filter(event => {
      if (!event.startTime) return false;
      const eventStartDate = new Date(parseInt(event.startTime) * 1000);
      return eventStartDate >= today;
    });

    // Completed events are already filtered in their function
    const historicEvents = historicEventsResponse || [];

    // Extract unique channels from BOTH upcoming and completed events
    const channelMap = new Map();
    
    // Process upcoming events
    upcomingEvents.forEach(event => {
      const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
      if (channelId) {
        const channelName = event.channelName || `Channel ${channelId}`;
        if (channelMap.has(channelId)) {
          channelMap.get(channelId).upcoming_count++;
        } else {
          channelMap.set(channelId, {
            channel_id: channelId,
            channel_name: channelName,
            upcoming_count: 1,
            historic_count: 0,
            is_visible: true // Default to visible
          });
        }
      }
    });
    
    // Process completed events
    historicEvents.forEach(event => {
      const channelId = event.channelId || event.channelID || event.channel_id || event.discordChannelId;
      if (channelId) {
        const channelName = event.channelName || `Channel ${channelId}`;
        if (channelMap.has(channelId)) {
          channelMap.get(channelId).historic_count++;
        } else {
          channelMap.set(channelId, {
            channel_id: channelId,
            channel_name: channelName,
            upcoming_count: 0,
            historic_count: 1,
            is_visible: true // Default to visible
          });
        }
      }
    });

    console.log(`üîç Channel loading debug: Found ${upcomingEvents.length} upcoming and ${historicEvents.length} completed events`);
    console.log(`üìä Extracted ${channelMap.size} unique channels from both upcoming and completed events`);

    // Get existing filter settings from database
    const filterResult = await pool.query('SELECT channel_id, is_visible, is_nax, webhook_url, channel_name FROM channel_filters');
    const existingFilters = new Map();
    filterResult.rows.forEach(row => {
      existingFilters.set(row.channel_id, { is_visible: row.is_visible, is_nax: row.is_nax, webhook_url: row.webhook_url || null });
    });

    // Merge current channels with existing filter settings
    const channels = Array.from(channelMap.values()).map(channel => {
      const existing = existingFilters.get(channel.channel_id);
      return {
        ...channel,
        channel_name: (existing && existing.channel_name) ? existing.channel_name : channel.channel_name,
        raid_count: (channel.upcoming_count || 0) + (channel.historic_count || 0), // Total count
        is_visible: existing ? existing.is_visible : true, // Default to visible for new channels
        is_nax: existing ? !!existing.is_nax : false,
        webhook_url: existing ? existing.webhook_url : null
      };
    });

    // Sort by channel name
    channels.sort((a, b) => (a.channel_name || '').localeCompare(b.channel_name || ''));

    // Diagnostics: counts of DB names vs fallbacks for transparency
    const diag = { total: channels.length, withName: channels.filter(c=>c.channel_name && c.channel_name.trim()).length };
    res.json({
      success: true,
      channels: channels,
      diagnostics: diag
    });

  } catch (error) {
    console.error('Error fetching channel filters:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching channel filter data'
    });
  }
});

// Save channel filter settings
app.post('/api/admin/channel-filters', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Unauthorized' });
  }

  // Check if user has management role
  const hasRole = await hasManagementRoleById(req.user.id);
  if (!hasRole) {
    return res.status(403).json({ success: false, message: 'Management role required' });
  }

  const { filters } = req.body;

  if (!Array.isArray(filters)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid filters data - expected array'
    });
  }

  try {
    // Create channel_filters table if it doesn't exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS channel_filters (
        channel_id TEXT PRIMARY KEY,
        channel_name TEXT,
        is_visible BOOLEAN DEFAULT true,
        is_nax BOOLEAN DEFAULT false,
        webhook_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await pool.query(`ALTER TABLE channel_filters ADD COLUMN IF NOT EXISTS is_nax BOOLEAN DEFAULT false`);
    await pool.query(`ALTER TABLE channel_filters ADD COLUMN IF NOT EXISTS webhook_url TEXT`);

    // Clear events caches so changes take effect immediately (upcoming + historic variants)
    try {
      await pool.query('DELETE FROM events_cache WHERE cache_key = ANY($1)', [[EVENTS_CACHE_KEY, HISTORIC_EVENTS_CACHE_KEY, HISTORIC_24M_EVENTS_CACHE_KEY]]);
      console.log('üóëÔ∏è Cleared upcoming and historic events caches due to channel filter update');
    } catch (_) {
      // No-op; cache table may not exist yet
    }

    // Update each filter setting
    for (const filter of filters) {
      const { channel_id, is_visible, is_nax, webhook_url } = filter;
      
      if (!channel_id || typeof is_visible !== 'boolean') {
        continue; // Skip invalid entries
      }

      await pool.query(`
        INSERT INTO channel_filters (channel_id, is_visible, is_nax, webhook_url, updated_at)
        VALUES ($1, $2, COALESCE($3, FALSE), $4, CURRENT_TIMESTAMP)
        ON CONFLICT (channel_id)
        DO UPDATE SET 
          is_visible = EXCLUDED.is_visible,
          is_nax = EXCLUDED.is_nax,
          webhook_url = EXCLUDED.webhook_url,
          updated_at = CURRENT_TIMESTAMP
      `, [channel_id, is_visible, is_nax, webhook_url || null]);
    }

    console.log(`üì° Updated channel filters for ${filters.length} channels`);

    res.json({
      success: true,
      message: `Successfully updated ${filters.length} channel filter settings`
    });

  } catch (error) {
    console.error('Error saving channel filters:', error);
    res.status(500).json({
      success: false,
      message: 'Error saving channel filter settings'
    });
  }
});

// Helper function to fetch channel info from Discord API
async function fetchDiscordChannelInfo(channelId) {
  const botToken = process.env.DISCORD_BOT_TOKEN;
  if (!botToken) {
    throw new Error('DISCORD_BOT_TOKEN not configured');
  }

  try {
    const response = await axios.get(`https://discord.com/api/v10/channels/${channelId}`, {
      headers: {
        'Authorization': `Bot ${botToken}`,
        'User-Agent': 'ClassicWoWManagerApp/1.0.0 (Node.js)'
      },
      timeout: 10000
    });

    return {
      id: response.data.id,
      name: response.data.name,
      type: response.data.type
    };
  } catch (error) {
    if (error.response?.status === 404) {
      console.log(`Channel ${channelId} not found (deleted or no access)`);
      return null;
    }
    throw error;
  }
}

// Admin: Fetch channel names from Discord API directly
app.post('/api/admin/channel-names/fetch-from-discord', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Unauthorized' });
  }

  const isMgmt = await hasManagementRoleById(req.user.id);
  if (!isMgmt) {
    return res.status(403).json({ success: false, message: 'Management role required' });
  }

  const botToken = process.env.DISCORD_BOT_TOKEN;
  if (!botToken) {
    return res.status(500).json({ 
      success: false, 
      message: 'Discord bot token not configured. Please set DISCORD_BOT_TOKEN in environment variables.' 
    });
  }

  let client;
  try {
    client = await pool.connect();

    // Ensure table exists
    await client.query(`
      CREATE TABLE IF NOT EXISTS channel_filters (
        channel_id TEXT PRIMARY KEY,
        channel_name TEXT,
        is_visible BOOLEAN DEFAULT true,
        is_nax BOOLEAN DEFAULT false,
        webhook_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Get all unique channel IDs from channel_filters table
    const channelResult = await client.query(`
      SELECT DISTINCT channel_id FROM channel_filters WHERE channel_id IS NOT NULL
    `);

    let updated = 0;
    let failed = 0;
    let notFound = 0;

    console.log(`üîÑ Fetching channel names from Discord API for ${channelResult.rows.length} channels...`);

    // Fetch channel info from Discord for each channel ID
    for (const row of channelResult.rows) {
      const channelId = row.channel_id;
      
      try {
        // Add a small delay to avoid rate limiting (50 requests per second limit)
        await new Promise(resolve => setTimeout(resolve, 25));
        
        const channelInfo = await fetchDiscordChannelInfo(channelId);
        
        if (channelInfo && channelInfo.name) {
          // Update the channel name in database
          await client.query(`
            UPDATE channel_filters 
            SET channel_name = $1, updated_at = CURRENT_TIMESTAMP 
            WHERE channel_id = $2
          `, [channelInfo.name, channelId]);
          
          console.log(`‚úÖ Updated channel ${channelId} -> "${channelInfo.name}"`);
          updated++;
        } else {
          notFound++;
          console.log(`‚ö†Ô∏è Channel ${channelId} not found or no access`);
        }
      } catch (error) {
        failed++;
        console.error(`‚ùå Failed to fetch channel ${channelId}:`, error.message);
      }
    }

    // Clear all related caches so UI reflects updated names
    try {
      await client.query('DELETE FROM events_cache WHERE cache_key = ANY($1)', [
        [EVENTS_CACHE_KEY, HISTORIC_EVENTS_CACHE_KEY, HISTORIC_24M_EVENTS_CACHE_KEY]
      ]);
    } catch (_) {}

    console.log(`‚ú® Discord channel refresh complete: ${updated} updated, ${notFound} not found, ${failed} failed`);

    res.json({ 
      success: true, 
      updated,
      notFound,
      failed,
      total: channelResult.rows.length
    });
  } catch (error) {
    console.error('Error fetching channel names from Discord:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error fetching channel names from Discord API' 
    });
  } finally {
    if (client) client.release();
  }
});

// Admin: Refresh channel names by scanning stored events and upserting into channel_filters
app.post('/api/admin/channel-names/refresh', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Unauthorized' });
  }

  const isMgmt = await hasManagementRoleById(req.user.id);
  if (!isMgmt) {
    return res.status(403).json({ success: false, message: 'Management role required' });
  }

  let client;
  try {
    client = await pool.connect();

    // Ensure table exists
    await client.query(`
      CREATE TABLE IF NOT EXISTS channel_filters (
        channel_id TEXT PRIMARY KEY,
        channel_name TEXT,
        is_visible BOOLEAN DEFAULT true,
        is_nax BOOLEAN DEFAULT false,
        webhook_url TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    let upserts = 0;

    // 1) Gather channel_id -> channel_name from cached single-event table (if present)
    try {
      const rows = await client.query(`
        SELECT DISTINCT 
          (event_data->>'channelId') AS channel_id,
          (event_data->>'channelName') AS channel_name
        FROM raid_helper_events_cache
        WHERE (event_data->>'channelId') IS NOT NULL AND (event_data->>'channelName') IS NOT NULL
      `);
      for (const r of rows.rows) {
        const channelId = (r.channel_id || '').trim();
        const channelName = (r.channel_name || '').trim();
        if (!channelId || !channelName) continue;
        await client.query(`
          INSERT INTO channel_filters (channel_id, channel_name, is_visible, updated_at)
          VALUES ($1, $2, TRUE, CURRENT_TIMESTAMP)
          ON CONFLICT (channel_id) DO UPDATE SET channel_name = EXCLUDED.channel_name, updated_at = CURRENT_TIMESTAMP
        `, [channelId, channelName]);
        upserts++;
      }
    } catch (_) {}

    // 2) Also ingest from cached arrays in events_cache (upcoming + historic)
    try {
      const cacheRows = await client.query(`
        SELECT events_data FROM events_cache WHERE cache_key = ANY($1)
      `, [[EVENTS_CACHE_KEY, HISTORIC_EVENTS_CACHE_KEY, HISTORIC_24M_EVENTS_CACHE_KEY]]);
      for (const row of cacheRows.rows) {
        const data = row.events_data;
        const events = Array.isArray(data) ? data : (typeof data === 'string' ? JSON.parse(data) : []);
        if (!Array.isArray(events)) continue;
        for (const ev of events) {
          const channelId = (ev.channelId || ev.channelID || ev.channel_id || ev.discordChannelId || '').toString().trim();
          const channelName = (ev.channelName || '').toString().trim();
          if (!channelId || !channelName) continue;
          // Ignore numeric-only or obvious ID echoes
          if (/^\d+$/.test(channelName) || channelName === channelId) continue;
          await client.query(`
            INSERT INTO channel_filters (channel_id, channel_name, is_visible, updated_at)
            VALUES ($1, $2, TRUE, CURRENT_TIMESTAMP)
            ON CONFLICT (channel_id) DO UPDATE SET channel_name = EXCLUDED.channel_name, updated_at = CURRENT_TIMESTAMP
          `, [channelId, channelName]);
          upserts++;
        }
      }
    } catch (_) {}

    // Clear all related caches so UI reflects updated names (upcoming + historic variants)
    try {
      await client.query('DELETE FROM events_cache WHERE cache_key = ANY($1)', [[EVENTS_CACHE_KEY, HISTORIC_EVENTS_CACHE_KEY, HISTORIC_24M_EVENTS_CACHE_KEY]]);
    } catch (_) {}

    res.json({ success: true, upserts });
  } catch (error) {
    console.error('Error refreshing channel names:', error);
    res.status(500).json({ success: false, message: 'Error refreshing channel names' });
  } finally {
    if (client) client.release();
  }
});

// Function to get channel filter settings (for internal use)
async function getChannelFilterSettings() {
  try {
    const result = await pool.query('SELECT channel_id, is_visible FROM channel_filters');
    const filters = new Map();
    result.rows.forEach(row => {
      filters.set(row.channel_id, row.is_visible);
    });
    return filters;
  } catch (error) {
    console.error('Error fetching channel filters:', error);
    return new Map(); // Return empty map as fallback
  }
}

// ====================================
// LOOT MANAGEMENT API ENDPOINTS
// ====================================

// Get loot items for an event
app.get('/api/loot/:eventId', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Unauthorized' });
  }

  const { eventId } = req.params;
  let client;

  try {
    client = await pool.connect();
    
    // Check if loot_items table exists, if not return empty array
    const tableCheckResult = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'loot_items'
      );
    `);
    
    if (!tableCheckResult.rows[0].exists) {
      console.log('[LOOT] loot_items table does not exist yet, returning empty array');
      return res.json({
        success: true,
        items: []
      });
    }
    
    const result = await client.query(`
      SELECT item_name, player_name, gold_amount, wowhead_link, icon_link, created_at
      FROM loot_items 
      WHERE event_id = $1 
      ORDER BY created_at DESC, item_name ASC
    `, [eventId]);

    res.json({
      success: true,
      items: result.rows
    });
  } catch (error) {
    console.error('Error fetching loot items:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching loot items'
    });
  } finally {
    if (client) client.release();
  }
});

// Import loot items from Gargul string
app.post('/api/loot/import', async (req, res) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ success: false, message: 'Unauthorized' });
  }

  // Check if user has management role
  const hasRole = await hasManagementRoleById(req.user.id);
  if (!hasRole) {
    return res.status(403).json({ success: false, message: 'Management role required' });
  }

  const { eventId, items, expandExisting } = req.body;

  if (!eventId || !items || !Array.isArray(items)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid request data'
    });
  }

  let client;

  try {
    client = await pool.connect();
    
    // Start transaction
    await client.query('BEGIN');

    // Create loot_items table if it doesn't exist
    await client.query(`
      CREATE TABLE IF NOT EXISTS loot_items (
        id SERIAL PRIMARY KEY,
        event_id TEXT NOT NULL,
        item_name TEXT NOT NULL,
        player_name TEXT NOT NULL,
        gold_amount INTEGER DEFAULT 0,
        wowhead_link TEXT,
        icon_link TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create index if it doesn't exist
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_loot_items_event_id ON loot_items (event_id)
    `);

    // If not expanding existing list, delete current items for this event
    if (!expandExisting) {
      await client.query('DELETE FROM loot_items WHERE event_id = $1', [eventId]);
      console.log(`[LOOT] Cleared existing items for event ${eventId}`);
    }

    // Insert new items
    let insertedCount = 0;
    for (const item of items) {
      await client.query(`
        INSERT INTO loot_items (event_id, item_name, player_name, gold_amount, wowhead_link, icon_link)
        VALUES ($1, $2, $3, $4, $5, $6)
      `, [
        eventId,
        item.item_name,
        item.player_name,
        item.gold_amount || 0,
        item.wowhead_link,
        item.icon_link
      ]);
      insertedCount++;
    }

    // Commit transaction
    await client.query('COMMIT');

    console.log(`[LOOT] Successfully imported ${insertedCount} items for event ${eventId}`);

    try { broadcastUpdate('loot', eventId, { type: 'loot_changed', byUserId: req.user?.id || null, count: insertedCount }); } catch {}
    res.json({
      success: true,
      message: `Successfully imported ${insertedCount} items`,
      itemsImported: insertedCount
    });
  } catch (error) {
    // Rollback transaction on error
    if (client) {
      try {
        await client.query('ROLLBACK');
      } catch (rollbackError) {
        console.error('Error rolling back transaction:', rollbackError);
      }
    }
    
    console.error('Error importing loot items:', error);
    res.status(500).json({
      success: false,
      message: 'Error importing loot items'
    });
  } finally {
    if (client) client.release();
  }
});

// Get raid statistics for dashboard including RPB archive URL and WarcraftLogs data
app.get('/api/raid-stats/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    console.log(`üìä [RAID STATS] Fetching raid statistics for event: ${eventId}`);
    
    let client;
    try {
        client = await pool.connect();
        
        // Get RPB archive information (filter strictly to RPB analysis type)
        const rpbResult = await client.query(`
            SELECT archive_url, archive_name, rpb_completed_at
            FROM rpb_tracking 
            WHERE event_id = $1 AND archive_url IS NOT NULL AND analysis_type = 'rpb'
            ORDER BY created_at DESC 
            LIMIT 1
        `, [eventId]);
        
        // Get log data to find the latest log_id for WarcraftLogs API call
        const logResult = await client.query(`
            SELECT log_id 
            FROM log_data 
            WHERE event_id = $1 
            ORDER BY created_at DESC 
            LIMIT 1
        `, [eventId]);
        
        let rpbData = null;
        let raidStats = {
            totalTime: null,
            activeFightTime: null,
            bossesKilled: 0,
            lastBoss: null,
            firstMob: null,
            logUrl: null
        };
        
        // Process RPB data if available
        if (rpbResult.rows.length > 0) {
            const rpb = rpbResult.rows[0];
            rpbData = {
                archiveUrl: rpb.archive_url,
                archiveName: rpb.archive_name,
                completedAt: rpb.rpb_completed_at
            };
        }
        
                // Fetch WarcraftLogs data if we have a log_id
        if (logResult.rows.length > 0) {
            const logId = logResult.rows[0].log_id;
            console.log(`üìñ [RAID STATS] Fetching WarcraftLogs data for log: ${logId}`);
            
            // Set log URL for the WoW Logs widget
            raidStats.logUrl = `https://vanilla.warcraftlogs.com/reports/${logId}`;
            
            try {
                // Use WarcraftLogs API to get raid statistics - use the same key as frontend
                const wclApiKey = process.env.WCL_API_KEY || 'e5c41ab0436b3a44c0e9c2fbd6cf016d';
                if (wclApiKey) {
                    // First, get fights data to determine time range (same as frontend)
                    const fightsUrl = `https://vanilla.warcraftlogs.com:443/v1/report/fights/${logId}?translate=true&api_key=${wclApiKey}`;
                    console.log(`ü•ä [RAID STATS] Getting fights data: ${fightsUrl}`);
                    
                    const fightsResponse = await fetch(fightsUrl);
                    if (fightsResponse.ok) {
                        const fightsData = await fightsResponse.json();
                        console.log(`‚öîÔ∏è [RAID STATS] Fights count: ${fightsData.fights?.length || 0}`);
                        
                        // Get time range from fights (same logic as frontend)
                        let logStartTime = 0;
                        let logEndTime = 0;
                        if (fightsData.fights && fightsData.fights.length > 0) {
                            logStartTime = fightsData.fights[0].start_time;
                            logEndTime = fightsData.fights[fightsData.fights.length - 1].end_time;
                        }
                        console.log(`‚è±Ô∏è [RAID STATS] Time range: ${logStartTime} - ${logEndTime}`);
                        
                        // Calculate actual raid duration (including downtime)
                        const actualRaidDuration = logEndTime - logStartTime;
                        const actualRaidMinutes = Math.round(actualRaidDuration / 60000);
                        console.log(`üïí [RAID STATS] Actual raid duration: ${actualRaidMinutes} minutes`);
                        
                        // Store the actual duration
                        raidStats.totalTime = actualRaidMinutes;
                        
                        // Save duration to database for use on front page
                        try {
                            await client.query(`
                                INSERT INTO raid_durations (event_id, duration_minutes, updated_at) 
                                VALUES ($1, $2, NOW()) 
                                ON CONFLICT (event_id) 
                                DO UPDATE SET duration_minutes = $2, updated_at = NOW()
                            `, [eventId, actualRaidMinutes]);
                            console.log(`üíæ [RAID STATS] Saved duration ${actualRaidMinutes}min for event ${eventId}`);
                        } catch (saveError) {
                            console.warn(`‚ö†Ô∏è [RAID STATS] Failed to save duration for event ${eventId}:`, saveError.message);
                        }
                        
                        // Find the last boss from fights data
                        const bossKills = fightsData.fights.filter(fight => fight.boss > 0 && fight.kill === true);
                        if (bossKills.length > 0) {
                            const lastBossFight = bossKills[bossKills.length - 1];
                            raidStats.lastBoss = lastBossFight.name;
                            raidStats.bossesKilled = bossKills.length;
                            console.log(`üëë [RAID STATS] Last boss from fights: ${lastBossFight.name}, Total bosses killed: ${bossKills.length}`);
                        }
                        
                        // Now get damage data with time range
                        const wclUrl = `https://vanilla.warcraftlogs.com:443/v1/report/tables/damage-done/${logId}?start=${logStartTime}&end=${logEndTime}&translate=true&api_key=${wclApiKey}`;
                        console.log(`üîó [RAID STATS] WCL Damage URL: ${wclUrl}`);
                        
                        const wclResponse = await fetch(wclUrl);
                        console.log(`üì° [RAID STATS] WCL Response status: ${wclResponse.status}`);
                        
                        if (wclResponse.ok) {
                            const wclData = await wclResponse.json();
                            console.log(`üìä [RAID STATS] WCL Data keys: ${Object.keys(wclData)}`);
                            console.log(`üìä [RAID STATS] TotalTime: ${wclData.totalTime}, Entries count: ${wclData.entries?.length || 0}`);
                            
                            // Store active fight time for display
                            if (wclData.totalTime) {
                                raidStats.activeFightTime = Math.round(wclData.totalTime / 60000); // Convert ms to minutes
                            }
                            
                            // Only update boss counts if we didn't get them from fights data
                            if (wclData.entries && raidStats.bossesKilled === 0) {
                                const bosses = wclData.entries.filter(entry => 
                                    entry.targets && entry.targets.some(target => target.type === "Boss")
                                );
                                
                                if (bosses.length > 0) {
                                    // Count unique boss targets as fallback
                                    const uniqueBosses = new Set();
                                    bosses.forEach(boss => {
                                        if (boss.targets) {
                                            boss.targets.forEach(target => {
                                                if (target.type === "Boss") {
                                                    uniqueBosses.add(target.name);
                                                }
                                            });
                                        }
                                    });
                                    
                                    raidStats.bossesKilled = uniqueBosses.size;
                                    
                                    // Find the last boss as fallback
                                    const bossArray = Array.from(uniqueBosses);
                                    if (bossArray.length > 0 && !raidStats.lastBoss) {
                                        raidStats.lastBoss = bossArray[bossArray.length - 1];
                                    }
                                }
                            }
                            
                            console.log(`‚úÖ [RAID STATS] WarcraftLogs data processed: ${raidStats.totalTime}min, ${raidStats.bossesKilled} bosses`);
                        } else {
                            const errorText = await wclResponse.text();
                            console.warn(`‚ö†Ô∏è [RAID STATS] WarcraftLogs damage API error: ${wclResponse.status} - ${errorText}`);
                        }
                    } else {
                        const errorText = await fightsResponse.text();
                        console.warn(`‚ö†Ô∏è [RAID STATS] WarcraftLogs fights API error: ${fightsResponse.status} - ${errorText}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è [RAID STATS] No WCL_API_KEY found, using fallback`);
                }
            } catch (wclError) {
                console.error('‚ùå [RAID STATS] Error fetching WarcraftLogs data:', wclError);
            }
        }
        
        res.json({
            success: true,
            data: {
                rpb: rpbData,
                stats: raidStats
            }
        });
        
    } catch (error) {
        console.error('‚ùå [RAID STATS] Error fetching raid statistics:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching raid statistics',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Get saved raid duration (from WarcraftLogs calculation)
app.get('/api/event-duration/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }
    
    try {
        console.log(`‚è±Ô∏è [EVENT DURATION] Fetching saved duration for event: ${eventId}`);
        
        const result = await pool.query(
            'SELECT duration_minutes FROM raid_durations WHERE event_id = $1',
            [eventId]
        );
        
        if (result.rows.length === 0) {
            console.log(`‚ùå [EVENT DURATION] No saved duration found for event: ${eventId}`);
            return res.json({ success: false, error: 'Duration not calculated yet' });
        }
        
        const durationMinutes = result.rows[0].duration_minutes;
        console.log(`‚è±Ô∏è [EVENT DURATION] Found saved duration for event ${eventId}: ${durationMinutes} minutes`);
        
        return res.json({
            success: true,
            duration: durationMinutes
        });
        
    } catch (error) {
        console.error(`‚ùå [EVENT DURATION] Error for event ${eventId}:`, error.message);
        return res.json({ success: false, error: 'Database error' });
    }
});

// Get total gold pot for an event (sum of all gold amounts)
app.get('/api/event-goldpot/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }
    
    try {
        console.log(`üí∞ [EVENT GOLDPOT] Fetching gold pot for event: ${eventId}`);
        
        const result = await pool.query(
            'SELECT COALESCE(SUM(gold_amount), 0) as total_gold FROM loot_items WHERE event_id = $1',
            [eventId]
        );
        
        const totalGold = result.rows[0].total_gold;
        console.log(`üí∞ [EVENT GOLDPOT] Gold pot for event ${eventId}: ${totalGold} gold`);
        
        return res.json({
            success: true,
            goldPot: parseInt(totalGold) || 0
        });
        
    } catch (error) {
        console.error(`‚ùå [EVENT GOLDPOT] Error for event ${eventId}:`, error.message);
        return res.json({ success: false, error: 'Database error' });
    }
});

// Get biggest item for an event (item with highest gold amount)
app.get('/api/event-biggestitem/:eventId', async (req, res) => {
    const { eventId } = req.params;
    
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }
    
    try {
        console.log(`üíé [EVENT BIGGESTITEM] Fetching biggest item for event: ${eventId}`);
        
        const result = await pool.query(
            'SELECT item_name, gold_amount, icon_link FROM loot_items WHERE event_id = $1 ORDER BY gold_amount DESC LIMIT 1',
            [eventId]
        );
        
        if (result.rows.length === 0) {
            console.log(`‚ùå [EVENT BIGGESTITEM] No items found for event: ${eventId}`);
            return res.json({ success: false, error: 'No items found' });
        }
        
        const biggestItem = result.rows[0];
        console.log(`üíé [EVENT BIGGESTITEM] Biggest item for event ${eventId}: ${biggestItem.item_name} (${biggestItem.gold_amount} gold)`);
        
        return res.json({
            success: true,
            itemName: biggestItem.item_name,
            goldAmount: biggestItem.gold_amount,
            iconLink: biggestItem.icon_link
        });
        
    } catch (error) {
        console.error(`‚ùå [EVENT BIGGESTITEM] Error for event ${eventId}:`, error.message);
        return res.json({ success: false, error: 'Database error' });
    }
});

// Big Buyer Bonus: top 3 spenders (loot_items sum per player) for an event
app.get('/api/big-buyer/:eventId', async (req, res) => {
    const { eventId } = req.params;
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Authentication required' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure loot_items exists; if not, return empty
        const tableCheck = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'loot_items'
            ) AS exists;
        `);
        if (!tableCheck.rows[0].exists) {
            return res.json({ success: true, data: [] });
        }

        // Sum spend per player for event, join to log_data to get class/discord when possible
        let result = await client.query(`
            WITH spend AS (
                SELECT 
                    li.player_name AS character_name,
                    SUM(COALESCE(li.gold_amount,0))::bigint AS spent_gold
                FROM loot_items li
                WHERE li.event_id = $1
                GROUP BY li.player_name
            ), ranked AS (
                SELECT s.character_name,
                       s.spent_gold,
                       -- join any matching log_data row to get class and discord id
                       COALESCE(ld.character_class, 'Unknown') AS character_class,
                       ld.discord_id
                FROM spend s
                LEFT JOIN LATERAL (
                    SELECT ld.character_class, ld.discord_id
                    FROM log_data ld
                    WHERE ld.event_id = $1 AND LOWER(ld.character_name) = LOWER(s.character_name)
                    LIMIT 1
                ) ld ON TRUE
            )
            SELECT *
            FROM ranked
            WHERE spent_gold >= 25000
            ORDER BY spent_gold DESC, LOWER(character_name) ASC
            LIMIT 3;
        `, [eventId]);

        // Fallback: if none meet threshold, return top 3 spenders with their amounts (points may be 0)
        if (!result.rows || result.rows.length === 0) {
            result = await client.query(`
                WITH spend AS (
                    SELECT 
                        li.player_name AS character_name,
                        SUM(COALESCE(li.gold_amount,0))::bigint AS spent_gold
                    FROM loot_items li
                    WHERE li.event_id = $1
                    GROUP BY li.player_name
                ), ranked AS (
                    SELECT s.character_name,
                           s.spent_gold,
                           COALESCE(ld.character_class, 'Unknown') AS character_class,
                           ld.discord_id
                    FROM spend s
                    LEFT JOIN LATERAL (
                        SELECT ld.character_class, ld.discord_id
                        FROM log_data ld
                        WHERE ld.event_id = $1 AND LOWER(ld.character_name) = LOWER(s.character_name)
                        LIMIT 1
                    ) ld ON TRUE
                )
                SELECT *
                FROM ranked
                ORDER BY spent_gold DESC, LOWER(character_name) ASC
                LIMIT 3;
            `, [eventId]);
        }

        // Compute points tier
        const tierPoints = (g) => {
            const n = Number(g) || 0;
            if (n >= 100000) return 20;
            if (n >= 75000) return 15;
            if (n >= 50000) return 10;
            if (n >= 25000) return 5;
            return 0;
        };

        const data = (result.rows || []).map(r => ({
            character_name: r.character_name,
            character_class: r.character_class || 'Unknown',
            discord_id: r.discord_id || null,
            spent_gold: Number(r.spent_gold) || 0,
            points: tierPoints(r.spent_gold)
        }));

        return res.json({ success: true, data });
    } catch (e) {
        console.error('‚ùå [BIG BUYER] Error:', e);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    } finally {
        if (client) client.release();
    }
});

// Get top 10 most expensive items across all events for Items Hall of Fame
app.get('/api/items-hall-of-fame', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }
    
    try {
        console.log(`üèÜ [ITEMS HALL OF FAME] Fetching top 10 most expensive items`);
        
        // Check if loot_items table exists, if not return empty array
        const tableExists = await pool.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'loot_items'
            );
        `);
        
        if (!tableExists.rows[0].exists) {
            console.log('[ITEMS HALL OF FAME] loot_items table does not exist yet, returning empty array');
            return res.json({
                success: true,
                items: []
            });
        }
        
        const result = await pool.query(`
            WITH ranked AS (
                SELECT 
                    li.item_name,
                    li.player_name,
                    li.gold_amount,
                    li.icon_link,
                    li.event_id,
                    ec.event_data->>'channelName' AS channel_name,
                    (ec.event_data->>'startTime')::bigint AS start_time,
                    ROW_NUMBER() OVER (PARTITION BY LOWER(li.item_name) ORDER BY li.gold_amount DESC) AS rn
                FROM loot_items li
                LEFT JOIN raid_helper_events_cache ec ON li.event_id = ec.event_id
                WHERE li.gold_amount > 0
            )
            SELECT 
                item_name,
                player_name,
                gold_amount,
                icon_link,
                event_id,
                channel_name,
                start_time
            FROM ranked
            WHERE rn = 1
            ORDER BY gold_amount DESC
            LIMIT 10
        `);
        
        const hallOfFameItems = result.rows.map(item => ({
            itemName: item.item_name,
            playerName: item.player_name,
            goldAmount: item.gold_amount,
            iconLink: item.icon_link,
            eventId: item.event_id,
            channelName: item.channel_name,
            startTime: item.start_time
        }));
        
        console.log(`üèÜ [ITEMS HALL OF FAME] Found ${hallOfFameItems.length} items for hall of fame`);
        
        return res.json({
            success: true,
            items: hallOfFameItems
        });
        
    } catch (error) {
        console.error(`‚ùå [ITEMS HALL OF FAME] Error fetching hall of fame items:`, error);
        return res.status(500).json({ success: false, error: 'Internal server error' });
    }
});

// Get full items log (all sold items) for the Item Log page
app.get('/api/items-log', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }

    try {
        // Check if loot_items table exists
        const tableExists = await pool.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'loot_items'
            );
        `);

        if (!tableExists.rows[0].exists) {
            return res.json({ success: true, items: [] });
        }

        const result = await pool.query(`
            SELECT 
                li.item_name,
                li.player_name,
                li.gold_amount,
                li.wowhead_link,
                li.icon_link,
                li.event_id,
                ec.event_data->>'channelName' AS channel_name,
                (ec.event_data->>'startTime')::bigint AS start_time
            FROM loot_items li
            LEFT JOIN raid_helper_events_cache ec ON li.event_id = ec.event_id
            WHERE li.gold_amount > 0
            ORDER BY start_time DESC, li.gold_amount DESC
            LIMIT 3000
        `);

        const items = result.rows.map(item => ({
            itemName: item.item_name,
            playerName: item.player_name,
            goldAmount: item.gold_amount,
            wowheadLink: item.wowhead_link,
            iconLink: item.icon_link,
            eventId: item.event_id,
            channelName: item.channel_name,
            startTime: item.start_time
        }));

        return res.json({ success: true, items });
    } catch (error) {
        console.error('‚ùå [ITEMS LOG] Error:', error);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    }
});

// Price history for top 15 most expensive items: returns time series per item across events
app.get('/api/stats/top-item-price-history', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure loot_items exists
        const tableExists = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'loot_items'
            ) AS exists;
        `);
        if (!tableExists.rows[0].exists) {
            return res.json({ success: true, items: [] });
        }

        // Determine the 15 most expensive distinct items (by their highest sale price)
        const topItems = await client.query(`
            WITH ranked AS (
                SELECT 
                    LOWER(li.item_name) AS item_key,
                    li.item_name,
                    MAX(li.gold_amount) AS max_price
                FROM loot_items li
                WHERE li.gold_amount > 0
                GROUP BY LOWER(li.item_name), li.item_name
            )
            SELECT item_key, item_name, max_price
            FROM ranked
            ORDER BY max_price DESC
            LIMIT 15;
        `);

        if (topItems.rows.length === 0) {
            return res.json({ success: true, items: [] });
        }

        const itemKeys = topItems.rows.map(r => r.item_key);

        // Fetch full price history for these items, join to event cache for time and channel
        const history = await client.query(
            `SELECT 
                LOWER(li.item_name) AS item_key,
                li.item_name,
                li.gold_amount,
                li.icon_link,
                li.wowhead_link,
                li.player_name,
                li.event_id,
                (ec.event_data->>'channelName') AS channel_name,
                (ec.event_data->>'startTime')::bigint AS start_time
            FROM loot_items li
            LEFT JOIN raid_helper_events_cache ec ON ec.event_id = li.event_id
            WHERE LOWER(li.item_name) = ANY($1)
              AND li.gold_amount > 0
            ORDER BY start_time ASC, li.gold_amount ASC`,
            [itemKeys]
        );

        // Group by item_key and shape series
        const byItem = new Map();
        for (const row of history.rows) {
            const key = row.item_key;
            if (!byItem.has(key)) {
                const meta = topItems.rows.find(r => r.item_key === key) || {};
                byItem.set(key, {
                    itemKey: key,
                    itemName: row.item_name || meta.item_name || key,
                    iconLink: row.icon_link || null,
                    wowheadLink: row.wowhead_link || null,
                    maxPrice: meta.max_price || 0,
                    points: []
                });
            }
            const bucket = byItem.get(key);
            if (row.start_time) {
                bucket.points.push({
                    x: Number(row.start_time) * 1000,
                    y: Number(row.gold_amount) || 0,
                    eventId: row.event_id,
                    channelName: row.channel_name || null,
                    playerName: row.player_name || null
                });
            }
        }

        const items = Array.from(byItem.values())
            .sort((a, b) => (b.maxPrice || 0) - (a.maxPrice || 0));

        return res.json({ success: true, items });
    } catch (e) {
        console.error('‚ùå [/api/stats/top-item-price-history] Error:', e);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    } finally {
        if (client) client.release();
    }
});

// Gold pot sizes over time for specified raid channels
app.get('/api/stats/goldpot-history', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure loot_items exists
        const tableExists = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'loot_items'
            ) AS exists;
        `);
        if (!tableExists.rows[0].exists) {
            return res.json({ success: true, series: [] });
        }

        const channels = ['üìÖsunday-aqbwl', 'üìÖthursday-nax', 'üìÖfriday-nax'];

        const pots = await client.query(`
            WITH pots AS (
                SELECT li.event_id, SUM(COALESCE(li.gold_amount,0))::bigint AS total_gold
                FROM loot_items li
                GROUP BY li.event_id
            )
            SELECT 
                p.event_id,
                p.total_gold,
                (ec.event_data->>'channelName') AS channel_name,
                (ec.event_data->>'startTime')::bigint AS start_time
            FROM pots p
            LEFT JOIN raid_helper_events_cache ec ON ec.event_id = p.event_id
            WHERE (ec.event_data->>'channelName') = ANY($1)
            ORDER BY start_time ASC
        `, [channels]);

        const byChannel = new Map();
        for (const row of pots.rows) {
            const ch = row.channel_name || 'unknown';
            if (!byChannel.has(ch)) byChannel.set(ch, []);
            if (row.start_time) {
                byChannel.get(ch).push({
                    x: Number(row.start_time) * 1000,
                    y: Number(row.total_gold) || 0,
                    eventId: row.event_id
                });
            }
        }

        const series = channels.map(name => ({
            name,
            points: (byChannel.get(name) || []).sort((a,b)=>a.x-b.x)
        }));

        return res.json({ success: true, series });
    } catch (e) {
        console.error('‚ùå [/api/stats/goldpot-history] Error:', e);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    } finally {
        if (client) client.release();
    }
});

// Average per-player gold pot share by class across raids
app.get('/api/stats/avg-goldpot-by-class', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure required tables exist
        const [lootExists, logExists] = await Promise.all([
            client.query(`SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema='public' AND table_name='loot_items') AS exists;`),
            client.query(`SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema='public' AND table_name='log_data') AS exists;`)
        ]);
        if (!lootExists.rows[0].exists || !logExists.rows[0].exists) {
            return res.json({ success: true, averages: {} });
        }

        const q = await client.query(`
            WITH pots AS (
                SELECT li.event_id, SUM(COALESCE(li.gold_amount,0))::bigint AS total_gold
                FROM loot_items li
                GROUP BY li.event_id
            ), participants AS (
                SELECT ld.event_id, LOWER(ld.character_class) AS class_lower, COUNT(DISTINCT ld.discord_id) AS class_players
                FROM log_data ld
                WHERE ld.discord_id IS NOT NULL AND ld.character_class IS NOT NULL AND ld.character_class <> ''
                GROUP BY ld.event_id, LOWER(ld.character_class)
            ), totals AS (
                SELECT event_id, SUM(class_players) AS total_players
                FROM participants
                GROUP BY event_id
            ), per_event AS (
                SELECT p.event_id, p.class_lower, pots.total_gold, t.total_players
                FROM participants p
                JOIN pots ON pots.event_id = p.event_id
                JOIN totals t ON t.event_id = p.event_id
                WHERE t.total_players > 0 AND pots.total_gold > 0
            ), shares AS (
                SELECT class_lower, (total_gold::numeric / total_players) AS per_player_share
                FROM per_event
            )
            SELECT class_lower, ROUND(AVG(per_player_share))::bigint AS avg_share
            FROM shares
            GROUP BY class_lower
        `);

        const averages = {};
        for (const row of q.rows) {
            averages[row.class_lower] = Number(row.avg_share) || 0;
        }

        return res.json({ success: true, averages });
    } catch (e) {
        console.error('‚ùå [/api/stats/avg-goldpot-by-class] Error:', e);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    } finally {
        if (client) client.release();
    }
});

// Tier 3 token average prices per class, with per-token sales
app.get('/api/stats/t3-token-averages', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure loot_items exists
        const tableExists = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'loot_items'
            ) AS exists;
        `);
        if (!tableExists.rows[0].exists) {
            return res.json({ success: true, classes: [] });
        }

        // Canonical Tier 3 token lists per class-group
        const groupCloth = [
            'Desecrated Headpiece','Desecrated Spaulders','Desecrated Robe','Desecrated Gloves',
            'Desecrated Bracers','Desecrated Belt','Desecrated Leggings','Desecrated Sandals'
        ];
        const groupLeatherMail = [
            'Desecrated Circlet','Desecrated Shoulderpads','Desecrated Tunic','Desecrated Handguards',
            'Desecrated Bindings','Desecrated Girdle','Desecrated Legguards','Desecrated Boots'
        ];
        const groupPlate = [
            'Desecrated Helmet','Desecrated Pauldrons','Desecrated Breastplate','Desecrated Gauntlets',
            'Desecrated Wristguards','Desecrated Waistguard','Desecrated Legplates','Desecrated Sabatons'
        ];

        const tokenUniverse = [...groupCloth, ...groupLeatherMail, ...groupPlate].map(s => s.toLowerCase());

        // Aggregate average sale price per token
        const agg = await client.query(
            `SELECT 
                LOWER(li.item_name) AS item_key,
                MIN(li.item_name) AS item_name,
                ROUND(AVG(li.gold_amount))::bigint AS avg_price,
                COUNT(*)::bigint AS sale_count,
                MAX(li.icon_link) AS icon_link,
                MAX(li.wowhead_link) AS wowhead_link
            FROM loot_items li
            WHERE li.gold_amount > 0
              AND LOWER(li.item_name) = ANY($1)
            GROUP BY LOWER(li.item_name)`,
            [tokenUniverse]
        );

        const byToken = new Map();
        for (const row of agg.rows) {
            byToken.set(row.item_key, {
                name: row.item_name,
                avgPrice: Number(row.avg_price) || 0,
                count: Number(row.sale_count) || 0,
                iconLink: row.icon_link || null,
                wowheadLink: row.wowhead_link || null
            });
        }

        // Fetch individual sale prices per token (ordered ascending for consistent grouping)
        const salesRes = await client.query(
            `SELECT LOWER(li.item_name) AS item_key, li.gold_amount
             FROM loot_items li
             WHERE li.gold_amount > 0
               AND LOWER(li.item_name) = ANY($1)
             ORDER BY li.gold_amount ASC`,
            [tokenUniverse]
        );
        const byTokenSales = new Map();
        for (const row of salesRes.rows) {
            const key = row.item_key;
            if (!byTokenSales.has(key)) byTokenSales.set(key, []);
            byTokenSales.get(key).push(Number(row.gold_amount) || 0);
        }

        const classes = [
            { key: 'warrior', name: 'Warrior', tokens: groupPlate },
            { key: 'paladin', name: 'Paladin', tokens: groupPlate },
            { key: 'shaman', name: 'Shaman', tokens: groupPlate },
            { key: 'rogue', name: 'Rogue', tokens: groupLeatherMail },
            { key: 'hunter', name: 'Hunter', tokens: groupLeatherMail },
            { key: 'druid', name: 'Druid', tokens: groupLeatherMail },
            { key: 'mage', name: 'Mage', tokens: groupCloth },
            { key: 'priest', name: 'Priest', tokens: groupCloth },
            { key: 'warlock', name: 'Warlock', tokens: groupCloth }
        ];

        // Build result per class; omit classes with zero data entirely to keep UI concise
        const result = [];
        for (const cls of classes) {
            const items = [];
            for (const token of cls.tokens) {
                const t = byToken.get(token.toLowerCase());
                if (t && t.count > 0) {
                    items.push({
                        tokenName: token,
                        avgPrice: t.avgPrice,
                        count: t.count,
                        iconLink: t.iconLink,
                        wowheadLink: t.wowheadLink,
                        sales: byTokenSales.get(token.toLowerCase()) || []
                    });
                }
            }
            if (items.length > 0) {
                result.push({ class: cls.key, displayName: cls.name, items });
            }
        }

        // Also provide a flat token list for flexible grouping on frontend
        const tokens = [];
        const uniqueTokens = new Set([...groupCloth, ...groupLeatherMail, ...groupPlate].map(n => n.toLowerCase()));
        for (const key of uniqueTokens) {
            const t = byToken.get(key);
            if (t) {
                tokens.push({
                    tokenName: t.name,
                    avgPrice: t.avgPrice,
                    count: t.count,
                    iconLink: t.iconLink,
                    wowheadLink: t.wowheadLink,
                    sales: byTokenSales.get(key) || []
                });
            }
        }

        return res.json({ success: true, classes: result, tokens });
    } catch (e) {
        console.error('‚ùå [/api/stats/t3-token-averages] Error:', e);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    } finally {
        if (client) client.release();
    }
});

// Class & race distribution for all raid participants (distinct players across all raids)
app.get('/api/stats/raid-class-race', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ message: 'Unauthorized. Please sign in with Discord.' });
    }

    let client;
    try {
        client = await pool.connect();

        // Ensure log_data exists
        const logExists = await client.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name = 'log_data'
            ) AS exists;
        `);
        if (!logExists.rows[0].exists) {
            return res.json({ success: true, classCounts: {}, raceCounts: {}, total: 0 });
        }

        // Build distinct participant identities and join to guildies to retrieve race when available
        const result = await client.query(`
            WITH idents AS (
                SELECT DISTINCT
                    COALESCE(NULLIF(ld.discord_id, ''), 'name|' || LOWER(ld.character_name) || '|' || LOWER(ld.character_class)) AS ident_key,
                    LOWER(ld.character_class) AS class_lower,
                    NULLIF(ld.discord_id, '') AS discord_id,
                    LOWER(ld.character_name) AS name_lower
                FROM log_data ld
                WHERE (ld.character_name IS NOT NULL AND ld.character_name <> '')
            ), joined AS (
                SELECT 
                    i.ident_key,
                    i.class_lower,
                    COALESCE(NULLIF(LOWER(g1.race), ''), NULLIF(LOWER(g2.race), ''), 'unknown') AS race_lower
                FROM idents i
                LEFT JOIN guildies g1 ON g1.discord_id = i.discord_id
                LEFT JOIN guildies g2 ON (
                    (i.discord_id IS NULL OR i.discord_id = '')
                    AND LOWER(g2.character_name) = i.name_lower
                    AND LOWER(g2.class) = i.class_lower
                )
            )
            SELECT 
                (SELECT json_object_agg(class_lower, cnt) FROM (
                    SELECT class_lower, COUNT(*) AS cnt FROM joined GROUP BY class_lower
                ) s1) AS class_counts,
                (SELECT json_object_agg(race_lower, cnt) FROM (
                    SELECT race_lower, COUNT(*) AS cnt FROM joined GROUP BY race_lower
                ) s2) AS race_counts,
                (SELECT COUNT(*) FROM joined) AS total
        `);

        const row = result.rows[0] || {};
        const classes = row.class_counts || {};
        const races = row.race_counts || {};
        const total = Number(row.total) || 0;

        return res.json({ success: true, classCounts: classes, raceCounts: races, total });
    } catch (e) {
        console.error('‚ùå [/api/stats/raid-class-race] Error:', e);
        return res.status(500).json({ success: false, message: 'Internal server error' });
    } finally {
        if (client) client.release();
    }
});

// ===========================
// ATTENDANCE TRACKING API
// ===========================

// Helper function to calculate ISO week number (Monday = start of week)
function getISOWeek(date) {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    // Thursday in current week decides the year
    d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
    // January 4 is always in week 1
    const week1 = new Date(d.getFullYear(), 0, 4);
    // Adjust to Thursday in week 1 and count weeks from there
    return 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
}

// Helper function to get week year (can be different from calendar year)
function getWeekYear(date) {
    const d = new Date(date);
    d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
    return d.getFullYear();
}

// Helper function to get the first Monday of January for a given year
function getFirstMondayOfJanuary(year) {
    const firstDay = new Date(year, 0, 1); // January 1st
    const dayOfWeek = firstDay.getDay(); // 0 = Sunday, 1 = Monday, etc.
    
    // If January 1st is Monday (1), use it; otherwise find next Monday
    const daysToAdd = dayOfWeek === 0 ? 1 : dayOfWeek === 1 ? 0 : 8 - dayOfWeek;
    const firstMonday = new Date(year, 0, 1 + daysToAdd);
    return firstMonday;
}

// Helper function to get week number based on first Monday of January
function getCustomWeekNumber(date) {
    const d = new Date(date);
    const year = d.getFullYear();
    const firstMonday = getFirstMondayOfJanuary(year);
    
    // If date is before first Monday, it belongs to previous year
    if (d < firstMonday) {
        const prevYearFirstMonday = getFirstMondayOfJanuary(year - 1);
        const weeksDiff = Math.floor((d - prevYearFirstMonday) / (7 * 24 * 60 * 60 * 1000));
        return {
            weekYear: year - 1,
            weekNumber: weeksDiff + 1
        };
    }
    
    // Calculate weeks from first Monday of this year
    const weeksDiff = Math.floor((d - firstMonday) / (7 * 24 * 60 * 60 * 1000));
    return {
        weekYear: year,
        weekNumber: weeksDiff + 1
    };
}

// Helper function to calculate player streak from attendance cache
async function calculatePlayerStreak(client, discordId, currentWeek) {
    try {
        // Get the last 15 weeks of data for this player
        const weeks = [];
        const now = new Date();
        for (let i = 14; i >= 0; i--) {
            const weekDate = new Date(now);
            weekDate.setDate(weekDate.getDate() - (i * 7));
            const weekInfo = getCustomWeekNumber(weekDate);
            weeks.push(weekInfo);
        }
        
        // Get attendance data for this player, respecting channel filters
        const attendanceResult = await client.query(`
            SELECT DISTINCT ac.week_year, ac.week_number
            FROM attendance_cache ac
            LEFT JOIN attendance_channel_filters acf ON ac.channel_id = acf.channel_id
            WHERE ac.discord_id = $1
            AND (ac.week_year, ac.week_number) IN (${weeks.map((_, i) => `($${i * 2 + 2}, $${i * 2 + 3})`).join(', ')})
            AND (acf.is_included IS NULL OR acf.is_included = true)
            ORDER BY ac.week_year DESC, ac.week_number DESC
        `, [discordId, ...weeks.flatMap(w => [w.weekYear, w.weekNumber])]);
        
        const attendedWeeks = new Set(
            attendanceResult.rows.map(row => `${row.week_year}-${row.week_number}`)
        );
        
        // Sort weeks in reverse chronological order (most recent first)
        const sortedWeeks = [...weeks].sort((a, b) => {
            if (a.weekYear !== b.weekYear) {
                return b.weekYear - a.weekYear;
            }
            return b.weekNumber - a.weekNumber;
        });
        
        // Calculate consecutive attendance streak from most recent week backwards
        let streak = 0;
        for (const week of sortedWeeks) {
            const weekKey = `${week.weekYear}-${week.weekNumber}`;
            if (attendedWeeks.has(weekKey)) {
                streak++;
            } else {
                break; // Streak broken
            }
        }
        
        return streak;
        
    } catch (error) {
        console.error('‚ùå Error calculating player streak:', error);
        return 0;
    }
}

// Helper function to update player_streak for all characters of a given player
async function updatePlayerStreakForAllCharacters(client, discordId, currentWeek) {
    try {
        // Calculate the current streak for this player
        const streak = await calculatePlayerStreak(client, discordId, currentWeek);
        
        // Update all characters for this player with the calculated streak
        await client.query(`
            UPDATE attendance_cache 
            SET player_streak = $1 
            WHERE discord_id = $2
        `, [streak, discordId]);
        
        console.log(`‚úÖ Updated streak (${streak}) for all characters of player ${discordId}`);
        return streak;
        
    } catch (error) {
        console.error('‚ùå Error updating player streak for all characters:', error);
        return 0;
    }
}

// Get attendance data for display
app.get('/api/attendance', async (req, res) => {
    let client;
    try {
        client = await pool.connect();

        // Current week and last 15-week window
        const now = new Date();
        const currentWeekInfo = getCustomWeekNumber(now);
        const weeks = [];
        for (let i = 14; i >= 0; i--) {
            const d = new Date(now);
            d.setDate(d.getDate() - (i * 7));
            weeks.push(getCustomWeekNumber(d));
        }
        const allowedWeekKeys = new Set(weeks.map(w => `${w.weekYear}-${w.weekNumber}`));

        // Channel filters map
        const filtersResult = await client.query(`SELECT channel_id, is_included FROM attendance_channel_filters`);
        const channelFilterMap = new Map(filtersResult.rows.map(r => [String(r.channel_id), r.is_included]));

        // Build resolvers from log_data itself (guild-agnostic)
        const ldResolver = await client.query(`
            SELECT DISTINCT LOWER(character_name) AS name_lower,
                            LOWER(character_class) AS class_lower,
                            discord_id
            FROM log_data
            WHERE discord_id IS NOT NULL
        `);
        const nameClassToDiscord = new Map(ldResolver.rows.map(r => [`${r.name_lower}|${r.class_lower}`, String(r.discord_id)]));

        // Players table fallback: use only when unique mapping by (name,class)
        const playersResolver = await client.query(`
            SELECT LOWER(character_name) AS name_lower,
                   LOWER(class) AS class_lower,
                   discord_id
            FROM players
            WHERE discord_id IS NOT NULL
        `);
        const playersNameClassToDiscord = new Map(); // key -> discord_id or '__MULTI__'
        playersResolver.rows.forEach(r => {
            const key = `${r.name_lower}|${r.class_lower}`;
            const did = String(r.discord_id);
            if (!playersNameClassToDiscord.has(key)) {
                playersNameClassToDiscord.set(key, did);
            } else {
                const existing = playersNameClassToDiscord.get(key);
                if (existing !== did) playersNameClassToDiscord.set(key, '__MULTI__');
            }
        });

        // Pull local log data joined with local event cache (no external calls)
        const dataResult = await client.query(`
            SELECT 
                ld.event_id,
                ld.discord_id,
                ld.character_name,
                ld.character_class,
                (ec.event_data->>'channelId') as channel_id,
                (ec.event_data->>'channelName') as channel_name,
                (ec.event_data->>'date') as event_date
            FROM log_data ld
            LEFT JOIN raid_helper_events_cache ec ON ec.event_id = ld.event_id
            WHERE ld.event_id IS NOT NULL
        `);

        // Build attendance in-memory for the last 15 weeks window
        const attendanceByPlayer = {}; // discord_id -> { weekKey: [events] }
        const weekStats = {}; // weekKey -> { players:Set, characters:Set }

        const parseEventDate = (dateStr) => {
            if (!dateStr) return null; // expected format: d-m-yyyy
            const parts = String(dateStr).split('-');
            if (parts.length !== 3) return null;
            const day = parseInt(parts[0]);
            const month = parseInt(parts[1]) - 1;
            const year = parseInt(parts[2]);
            if (isNaN(day) || isNaN(month) || isNaN(year)) return null;
            return new Date(year, month, day);
        };

        for (const row of dataResult.rows) {
            // Resolve discord_id if missing using guildies name+class
            let did = row.discord_id ? String(row.discord_id) : null;
            let inferredFromPlayers = false;
            if (!did) {
                const key = `${String(row.character_name||'').toLowerCase()}|${String(row.character_class||'').toLowerCase()}`;
                did = nameClassToDiscord.get(key) || null;
                if (!did) {
                    const pDid = playersNameClassToDiscord.get(key);
                    if (pDid && pDid !== '__MULTI__') {
                        did = pDid;
                        inferredFromPlayers = true;
                    }
                }
            }
            if (!did) continue; // cannot attribute attendance without a user

            // Parse event date and map to our 15-week window
            const eventDate = parseEventDate(row.event_date);
            if (!eventDate) continue;
            const wk = getCustomWeekNumber(eventDate);
            const wkKey = `${wk.weekYear}-${wk.weekNumber}`;
            if (!allowedWeekKeys.has(wkKey)) continue;

            // Channel filter
            const chId = row.channel_id ? String(row.channel_id) : null;
            if (chId && channelFilterMap.has(chId)) {
                const inc = channelFilterMap.get(chId);
                if (inc === false) continue;
            }

            // Clean channel name
            let channelDisplayName = '#unknown-channel';
            if (row.channel_name && row.channel_name.trim() && row.channel_name !== row.channel_id && !String(row.channel_name).match(/^\d+$/)) {
                channelDisplayName = String(row.channel_name).replace(/^üìÖ/, '').trim();
            } else if (chId) {
                channelDisplayName = `channel-${chId.slice(-4)}`;
            }

            if (!attendanceByPlayer[did]) attendanceByPlayer[did] = {};
            if (!attendanceByPlayer[did][wkKey]) attendanceByPlayer[did][wkKey] = [];
            attendanceByPlayer[did][wkKey].push({
                eventId: row.event_id,
                channelName: channelDisplayName,
                characterName: row.character_name,
                characterClass: row.character_class,
                inferredFromPlayers: inferredFromPlayers === true
            });

            if (!weekStats[wkKey]) weekStats[wkKey] = { players: new Set(), characters: new Set() };
            weekStats[wkKey].players.add(did);
            if (row.character_name) weekStats[wkKey].characters.add(`${did}-${row.character_name}`);
        }

        // Derive players list with streaks from in-memory attendance
        const computeStreak = (did) => {
            let streak = 0;
            // Walk from current week backwards across our 15 weeks
            for (let i = weeks.length - 1; i >= 0; i--) {
                const wkKey = `${weeks[i].weekYear}-${weeks[i].weekNumber}`;
                const has = attendanceByPlayer[did] && attendanceByPlayer[did][wkKey] && attendanceByPlayer[did][wkKey].length > 0;
                if (has) streak++; else break;
            }
            return streak;
        };

        const players = Object.keys(attendanceByPlayer).map(did => ({
            discord_id: did,
            discord_username: `user-${String(did).slice(-4)}`,
            player_streak: computeStreak(did)
        }));

        // Convert sets to counts for week stats
        const enrichedWeeks = weeks.map(week => {
            const wkKey = `${week.weekYear}-${week.weekNumber}`;
            const stats = weekStats[wkKey];
            return {
                ...week,
                playerCount: stats ? stats.players.size : 0,
                characterCount: stats ? stats.characters.size : 0
            };
        });

        return res.json({
            success: true,
            data: {
                weeks: enrichedWeeks,
                players,
                attendance: attendanceByPlayer,
                currentWeek: currentWeekInfo
            }
        });
    } catch (error) {
        console.error('‚ùå [ATTENDANCE] Error fetching attendance data (local mode):', error);
        return res.status(500).json({ success: false, message: 'Error fetching attendance data', error: error.message });
    } finally {
        if (client) client.release();
    }
});

// Clear cache and rebuild attendance data
app.post('/api/attendance/rebuild', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        console.log('üîÑ [ATTENDANCE] Starting cache rebuild...');
        
        // Clear existing cache
        await client.query('DELETE FROM attendance_cache');
        console.log('‚úÖ [ATTENDANCE] Cleared existing cache');
        
        // Get all log_data entries with event_id; include rows missing discord_id so we can resolve via guildies
        const logDataResult = await client.query(`
            SELECT DISTINCT event_id, discord_id, character_name, character_class
            FROM log_data
            WHERE event_id IS NOT NULL
            ORDER BY event_id
        `);
        
        console.log(`üìä [ATTENDANCE] Found ${logDataResult.rows.length} unique attendance records`);
        
        let processedEvents = 0;
        let skippedEvents = 0;
        let rateLimitDelay = 1000; // Start with 1 second delay
        
        // Process each unique event
        const uniqueEvents = [...new Set(logDataResult.rows.map(row => row.event_id))];
        
        for (const eventId of uniqueEvents) {
            try {
                console.log(`üîç [ATTENDANCE] Processing event ${eventId}...`);
                
                // Fetch event data from Raid Helper API with retry logic
                let eventData = null;
                let attempts = 0;
                const maxAttempts = 3;
                
                while (attempts < maxAttempts && !eventData) {
                    try {
                        const response = await fetch(`https://raid-helper.dev/api/v2/events/${eventId}`);
                        
                        if (response.status === 429) {
                            // Rate limited - increase delay and retry
                            rateLimitDelay = Math.min(rateLimitDelay * 2, 10000); // Max 10 seconds
                            console.warn(`‚ö†Ô∏è [ATTENDANCE] Rate limited for event ${eventId}, waiting ${rateLimitDelay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, rateLimitDelay));
                            attempts++;
                            continue;
                        }
                        
                        if (!response.ok) {
                            console.warn(`‚ö†Ô∏è [ATTENDANCE] API error for event ${eventId}: ${response.status}`);
                            break;
                        }
                        
                        eventData = await response.json();
                        // Reset delay on success
                        rateLimitDelay = Math.max(rateLimitDelay / 2, 1000);
                        
                    } catch (apiError) {
                        console.error(`‚ùå [ATTENDANCE] API error for event ${eventId}:`, apiError.message);
                        attempts++;
                        if (attempts < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                }
                
                if (!eventData || !eventData.date || !eventData.channelId) {
                    console.warn(`‚ö†Ô∏è [ATTENDANCE] Skipping event ${eventId} - incomplete data`);
                    skippedEvents++;
                    continue;
                }
                
                // Parse date (format: "4-7-2025" = day-month-year)
                const dateParts = eventData.date.split('-');
                if (dateParts.length !== 3) {
                    console.warn(`‚ö†Ô∏è [ATTENDANCE] Invalid date format for event ${eventId}: ${eventData.date}`);
                    skippedEvents++;
                    continue;
                }
                
                const eventDate = new Date(
                    parseInt(dateParts[2]), // year
                    parseInt(dateParts[1]) - 1, // month (0-based)
                    parseInt(dateParts[0]) // day
                );
                
                // Calculate week info
                const weekInfo = getCustomWeekNumber(eventDate);
                
                // Clean up channel name for display
                let channelDisplayName = '#unknown-channel';
                if (eventData.channelName && 
                    eventData.channelName.trim() && 
                    eventData.channelName !== eventData.channelId &&
                    !eventData.channelName.match(/^\d+$/)) {
                    channelDisplayName = eventData.channelName.replace(/^üìÖ/, '').trim();
                } else if (eventData.channelId) {
                    channelDisplayName = `channel-${eventData.channelId.slice(-4)}`;
                }
                
                // Get all players for this event
                const eventPlayers = logDataResult.rows.filter(row => row.event_id === eventId);

                // Build a guildies lookup to resolve missing discord_id by name+class
                const guildiesRes = await client.query(`
                    SELECT LOWER(character_name) as name_lower, LOWER(character_class) as class_lower, discord_id
                    FROM guildies
                    WHERE discord_id IS NOT NULL
                `);
                const guildiesMap = new Map(guildiesRes.rows.map(r => [`${r.name_lower}|${r.class_lower}`, r.discord_id]));
                
                // Get discord usernames for these players
                const resolvedPlayers = eventPlayers.map(p => {
                    if (p.discord_id) return p;
                    const key = `${String(p.character_name||'').toLowerCase()}|${String(p.character_class||'').toLowerCase()}`;
                    const did = guildiesMap.get(key) || null;
                    return { ...p, discord_id: did };
                });

                const discordIds = [...new Set(resolvedPlayers.filter(p=>p.discord_id).map(p => p.discord_id))];
                const usernameResult = await client.query(`
                    SELECT DISTINCT discord_id, character_name as username
                    FROM guildies
                    WHERE discord_id = ANY($1) AND character_name IS NOT NULL
                    LIMIT 1
                `, [discordIds]);
                
                const usernameMap = {};
                usernameResult.rows.forEach(row => {
                    usernameMap[row.discord_id] = row.username;
                });
                
                // Insert attendance records
                const processedPlayers = new Set();
                for (const player of resolvedPlayers) {
                    if (!player.discord_id) continue; // skip if still unresolved
                    const username = usernameMap[player.discord_id] || `user-${player.discord_id.slice(-4)}`;
                    
                    await client.query(`
                        INSERT INTO attendance_cache (
                            discord_id, discord_username, week_year, week_number,
                            event_id, event_date, channel_id, channel_name,
                            character_name, character_class, player_streak
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                        ON CONFLICT (discord_id, week_year, week_number, event_id) 
                        DO UPDATE SET
                            discord_username = EXCLUDED.discord_username,
                            event_date = EXCLUDED.event_date,
                            channel_id = EXCLUDED.channel_id,
                            channel_name = EXCLUDED.channel_name,
                            character_name = EXCLUDED.character_name,
                            character_class = EXCLUDED.character_class,
                            player_streak = EXCLUDED.player_streak,
                            cached_at = CURRENT_TIMESTAMP
                    `, [
                        player.discord_id,
                        username,
                        weekInfo.weekYear,
                        weekInfo.weekNumber,
                        eventId,
                        eventDate,
                        eventData.channelId,
                        channelDisplayName,
                        player.character_name,
                        player.character_class,
                        0 // Temporary value, will be updated below
                    ]);
                    
                    // Track which players we need to update streaks for
                    processedPlayers.add(player.discord_id);
                }
                
                // Update player streaks for all affected players
                for (const discordId of processedPlayers) {
                    await updatePlayerStreakForAllCharacters(client, discordId, weekInfo);
                }
                
                processedEvents++;
                console.log(`‚úÖ [ATTENDANCE] Processed event ${eventId} (${eventPlayers.length} players)`);
                
                // Add delay between API calls to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, rateLimitDelay));
                
            } catch (eventError) {
                console.error(`‚ùå [ATTENDANCE] Error processing event ${eventId}:`, eventError);
                skippedEvents++;
            }
        }
        
        console.log(`üéâ [ATTENDANCE] Cache rebuild complete! Processed: ${processedEvents}, Skipped: ${skippedEvents}`);
        
        res.json({
            success: true,
            message: 'Attendance cache rebuilt successfully',
            stats: {
                processed: processedEvents,
                skipped: skippedEvents,
                total: uniqueEvents.length
            }
        });
        
    } catch (error) {
        console.error('‚ùå [ATTENDANCE] Error rebuilding attendance cache:', error);
        res.status(500).json({
            success: false,
            message: 'Error rebuilding attendance cache',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Rebuild attendance cache for a specific week
app.post('/api/attendance/rebuild-week', async (req, res) => {
    let client;
    try {
        const { weekYear, weekNumber } = req.body;
        
        if (!weekYear || !weekNumber) {
            return res.status(400).json({
                success: false,
                message: 'Missing weekYear or weekNumber parameters'
            });
        }
        
        client = await pool.connect();
        
        console.log(`üîÑ [ATTENDANCE] Starting cache rebuild for Week ${weekNumber}, ${weekYear}...`);
        
        // Clear existing cache for this specific week
        await client.query(`
            DELETE FROM attendance_cache 
            WHERE week_year = $1 AND week_number = $2
        `, [weekYear, weekNumber]);
        
        console.log(`‚úÖ [ATTENDANCE] Cleared existing cache for Week ${weekNumber}, ${weekYear}`);
        
        // Calculate the date range for this week
        const firstMondayOfYear = getFirstMondayOfJanuary(weekYear);
        const weekStartDate = new Date(firstMondayOfYear);
        weekStartDate.setDate(firstMondayOfYear.getDate() + (weekNumber - 1) * 7);
        
        const weekEndDate = new Date(weekStartDate);
        weekEndDate.setDate(weekStartDate.getDate() + 6);
        
        console.log(`üìÖ [ATTENDANCE] Week ${weekNumber}, ${weekYear} date range: ${weekStartDate.toDateString()} to ${weekEndDate.toDateString()}`);
        
        // Get all log_data entries for events in this week (include rows missing discord_id for resolution)
        const logDataResult = await client.query(`
            SELECT DISTINCT ld.event_id, ld.discord_id, ld.character_name, ld.character_class
            FROM log_data ld
            JOIN raid_helper_events_cache rhec ON ld.event_id = rhec.event_id
            WHERE ld.event_id IS NOT NULL 
            AND rhec.event_data->>'date' IS NOT NULL
        `);
        
        console.log(`üìä [ATTENDANCE] Found ${logDataResult.rows.length} potential attendance records`);
        
        let processedEvents = 0;
        let skippedEvents = 0;
        let rateLimitDelay = 500; // Start with shorter delay for single week
        
        // Filter events that fall within the target week
        const weekEvents = new Map();
        
        for (const row of logDataResult.rows) {
            try {
                // Try to get event data from cache first
                const cacheResult = await client.query(`
                    SELECT event_data FROM raid_helper_events_cache 
                    WHERE event_id = $1 AND cached_at > NOW() - INTERVAL '7 days'
                `, [row.event_id]);
                
                let eventData = null;
                
                if (cacheResult.rows.length > 0) {
                    eventData = cacheResult.rows[0].event_data;
                } else {
                    // Fetch from API if not in cache or cache is old
                    const response = await fetch(`https://raid-helper.dev/api/v2/events/${row.event_id}`);
                    if (response.ok) {
                        eventData = await response.json();
                        
                        // Update cache
                        await client.query(`
                            INSERT INTO raid_helper_events_cache (event_id, event_data, cached_at, last_accessed)
                            VALUES ($1, $2, NOW(), NOW())
                            ON CONFLICT (event_id) DO UPDATE SET
                                event_data = EXCLUDED.event_data,
                                cached_at = EXCLUDED.cached_at,
                                last_accessed = EXCLUDED.last_accessed
                        `, [row.event_id, JSON.stringify(eventData)]);
                    }
                    
                    // Add delay only for API calls
                    await new Promise(resolve => setTimeout(resolve, rateLimitDelay));
                }
                
                if (!eventData || !eventData.date) {
                    continue;
                }
                
                // Parse event date
                const dateParts = eventData.date.split('-');
                if (dateParts.length !== 3) {
                    continue;
                }
                
                const eventDate = new Date(
                    parseInt(dateParts[2]), // year
                    parseInt(dateParts[1]) - 1, // month (0-based)
                    parseInt(dateParts[0]) // day
                );
                
                // Check if event falls within the target week
                if (eventDate >= weekStartDate && eventDate <= weekEndDate) {
                    if (!weekEvents.has(row.event_id)) {
                        weekEvents.set(row.event_id, {
                            eventData,
                            eventDate,
                            players: []
                        });
                    }
                    weekEvents.get(row.event_id).players.push(row);
                }
                
            } catch (error) {
                console.error(`‚ùå [ATTENDANCE] Error processing event ${row.event_id}:`, error);
            }
        }
        
        console.log(`üéØ [ATTENDANCE] Found ${weekEvents.size} events in Week ${weekNumber}, ${weekYear}`);
        
        // Process each event in the target week
        for (const [eventId, { eventData, eventDate, players }] of weekEvents) {
            try {
                // Calculate week info
                const weekInfo = getCustomWeekNumber(eventDate);
                
                // Clean up channel name for display
                let channelDisplayName = '#unknown-channel';
                if (eventData.channelName && 
                    eventData.channelName.trim() && 
                    eventData.channelName !== eventData.channelId &&
                    !eventData.channelName.match(/^\d+$/)) {
                    channelDisplayName = eventData.channelName.replace(/^üìÖ/, '').trim();
                } else if (eventData.channelId) {
                    channelDisplayName = `channel-${eventData.channelId.slice(-4)}`;
                }
                
                // Resolve missing discord IDs using guildies name+class mapping
                const guildiesRes = await client.query(`
                    SELECT LOWER(character_name) as name_lower, LOWER(character_class) as class_lower, discord_id
                    FROM guildies
                    WHERE discord_id IS NOT NULL
                `);
                const guildiesMap = new Map(guildiesRes.rows.map(r => [`${r.name_lower}|${r.class_lower}`, r.discord_id]));

                const resolvedPlayers = players.map(p => {
                    if (p.discord_id) return p;
                    const key = `${String(p.character_name||'').toLowerCase()}|${String(p.character_class||'').toLowerCase()}`;
                    const did = guildiesMap.get(key) || null;
                    return { ...p, discord_id: did };
                });

                // Get discord usernames for these players
                const discordIds = [...new Set(resolvedPlayers.filter(p=>p.discord_id).map(p => p.discord_id))];
                const usernameResult = await client.query(`
                    SELECT DISTINCT discord_id, character_name as username
                    FROM guildies
                    WHERE discord_id = ANY($1) AND character_name IS NOT NULL
                    LIMIT 1
                `, [discordIds]);
                
                const usernameMap = {};
                usernameResult.rows.forEach(row => {
                    usernameMap[row.discord_id] = row.username;
                });
                
                // Insert attendance records
                const processedPlayers = new Set();
                for (const player of resolvedPlayers) {
                    if (!player.discord_id) continue; // skip unresolved
                    const username = usernameMap[player.discord_id] || `user-${player.discord_id.slice(-4)}`;
                    
                    await client.query(`
                        INSERT INTO attendance_cache (
                            discord_id, discord_username, week_year, week_number,
                            event_id, event_date, channel_id, channel_name,
                            character_name, character_class, player_streak
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                        ON CONFLICT (discord_id, week_year, week_number, event_id) 
                        DO UPDATE SET
                            discord_username = EXCLUDED.discord_username,
                            event_date = EXCLUDED.event_date,
                            channel_id = EXCLUDED.channel_id,
                            channel_name = EXCLUDED.channel_name,
                            character_name = EXCLUDED.character_name,
                            character_class = EXCLUDED.character_class,
                            player_streak = EXCLUDED.player_streak,
                            cached_at = CURRENT_TIMESTAMP
                    `, [
                        player.discord_id,
                        username,
                        weekInfo.weekYear,
                        weekInfo.weekNumber,
                        eventId,
                        eventDate,
                        eventData.channelId,
                        channelDisplayName,
                        player.character_name,
                        player.character_class,
                        0 // Temporary value, will be updated below
                    ]);
                    
                    // Track which players we need to update streaks for
                    processedPlayers.add(player.discord_id);
                }
                
                // Update player streaks for all affected players
                for (const discordId of processedPlayers) {
                    await updatePlayerStreakForAllCharacters(client, discordId, weekInfo);
                }
                
                processedEvents++;
                console.log(`‚úÖ [ATTENDANCE] Processed event ${eventId} (${players.length} players) for Week ${weekNumber}, ${weekYear}`);
                
            } catch (eventError) {
                console.error(`‚ùå [ATTENDANCE] Error processing event ${eventId}:`, eventError);
                skippedEvents++;
            }
        }
        
        console.log(`üéâ [ATTENDANCE] Week ${weekNumber}, ${weekYear} cache rebuild complete! Processed: ${processedEvents}, Skipped: ${skippedEvents}`);
        
        res.json({
            success: true,
            message: `Attendance cache rebuilt successfully for Week ${weekNumber}, ${weekYear}`,
            stats: {
                processed: processedEvents,
                skipped: skippedEvents,
                total: weekEvents.size,
                weekYear,
                weekNumber
            }
        });
        
    } catch (error) {
        console.error(`‚ùå [ATTENDANCE] Error rebuilding attendance cache for specific week:`, error);
        res.status(500).json({
            success: false,
            message: 'Error rebuilding attendance cache for specific week',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Test endpoint for week calculation
app.get('/api/attendance/week-test', (req, res) => {
    const testDate = req.query.date ? new Date(req.query.date) : new Date();
    const weekInfo = getCustomWeekNumber(testDate);
    
    res.json({
        success: true,
        data: {
            inputDate: testDate.toISOString(),
            weekYear: weekInfo.weekYear,
            weekNumber: weekInfo.weekNumber,
            firstMondayOfYear: getFirstMondayOfJanuary(weekInfo.weekYear).toISOString()
        }
    });
});

// Get attendance channel filters
app.get('/api/admin/attendance-channel-filters', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        // Get all unique channels from attendance_cache with event counts
        const channelsResult = await client.query(`
            SELECT 
                channel_id,
                channel_name,
                COUNT(DISTINCT event_id) as event_count,
                COUNT(*) as attendance_records
            FROM attendance_cache
            WHERE channel_id IS NOT NULL AND channel_name IS NOT NULL
            GROUP BY channel_id, channel_name
            ORDER BY event_count DESC, channel_name ASC
        `);
        
        // Get current filter settings
        const filtersResult = await client.query(`
            SELECT channel_id, is_included
            FROM attendance_channel_filters
        `);
        
        const filterMap = {};
        filtersResult.rows.forEach(row => {
            filterMap[row.channel_id] = row.is_included;
        });
        
        // Combine channel data with filter settings
        const channels = channelsResult.rows.map(row => ({
            channel_id: row.channel_id,
            channel_name: row.channel_name,
            event_count: parseInt(row.event_count),
            attendance_records: parseInt(row.attendance_records),
            is_included: filterMap[row.channel_id] !== undefined ? filterMap[row.channel_id] : true
        }));
        
        res.json({
            success: true,
            channels: channels
        });
        
    } catch (error) {
        console.error('‚ùå [ATTENDANCE FILTERS] Error fetching channel filters:', error);
        res.status(500).json({
            success: false,
            message: 'Error fetching attendance channel filters',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Save attendance channel filters
app.post('/api/admin/attendance-channel-filters', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        const { filters } = req.body;
        
        if (!filters || !Array.isArray(filters)) {
            return res.status(400).json({
                success: false,
                message: 'Invalid filters data'
            });
        }
        
        console.log(`üîÑ [ATTENDANCE FILTERS] Saving filters for ${filters.length} channels...`);
        
        // Start transaction
        await client.query('BEGIN');
        
        for (const filter of filters) {
            // Get channel name
            const channelResult = await client.query(`
                SELECT channel_name FROM attendance_cache 
                WHERE channel_id = $1 
                LIMIT 1
            `, [filter.channelId]);
            
            const channelName = channelResult.rows[0]?.channel_name || 'Unknown Channel';
            
            // Upsert filter setting
            await client.query(`
                INSERT INTO attendance_channel_filters (channel_id, channel_name, is_included, updated_at)
                VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
                ON CONFLICT (channel_id) 
                DO UPDATE SET 
                    channel_name = EXCLUDED.channel_name,
                    is_included = EXCLUDED.is_included,
                    updated_at = CURRENT_TIMESTAMP
            `, [filter.channelId, channelName, filter.isIncluded]);
            
            console.log(`‚úÖ [ATTENDANCE FILTERS] ${filter.isIncluded ? 'Included' : 'Excluded'} channel: ${channelName}`);
        }
        
        await client.query('COMMIT');
        
        console.log(`üéâ [ATTENDANCE FILTERS] Filter settings saved successfully!`);
        
        res.json({
            success: true,
            message: 'Attendance channel filters updated successfully'
        });
        
    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error('‚ùå [ATTENDANCE FILTERS] Error saving channel filters:', error);
        res.status(500).json({
            success: false,
            message: 'Error saving attendance channel filters',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// ====================================
// CHANNEL BACKGROUNDS MANAGEMENT
// ====================================

// Configure Cloudinary storage for file uploads
const storage = new CloudinaryStorage({
    cloudinary: cloudinary,
    params: {
        folder: 'wow-manager/channel-backgrounds',
        allowed_formats: ['jpg', 'jpeg', 'png', 'gif', 'webp'],
        public_id: (req, file) => {
            // Create unique filename with timestamp
            const timestamp = Date.now();
            return `channel_bg_${timestamp}`;
        },
        transformation: [
            { width: 1920, height: 1080, crop: 'limit', quality: 'auto' }
        ]
    }
});

const upload = multer({
    storage: storage,
    limits: {
        fileSize: 10 * 1024 * 1024 // 10MB limit
    },
    fileFilter: function (req, file, cb) {
        // Only allow image files
        const allowedTypes = /\.(jpg|jpeg|png|gif|webp)$/i;
        if (allowedTypes.test(file.originalname)) {
            cb(null, true);
        } else {
            cb(new Error('Only image files are allowed (jpg, jpeg, png, gif, webp)'));
        }
    }
});

// Get all channel background mappings
app.get('/api/admin/channel-backgrounds', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Unauthorized' });
    }

    // Check if user has management role
  const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ success: false, message: 'Management role required' });
    }

    let client;
    try {
        client = await pool.connect();
        
        // Get all channel backgrounds
        const result = await client.query(`
            SELECT 
                channel_id,
                channel_name,
                background_image_url,
                created_at,
                updated_at
            FROM channel_backgrounds
            ORDER BY channel_name ASC
        `);
        
        res.json({
            success: true,
            backgrounds: result.rows
        });
        
    } catch (error) {
        console.error('‚ùå [CHANNEL BACKGROUNDS] Error loading backgrounds:', error);
        res.status(500).json({
            success: false,
            message: 'Error loading channel backgrounds',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Upload background image for a channel
app.post('/api/admin/channel-backgrounds/upload', upload.single('backgroundImage'), async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Unauthorized' });
    }

    // Check if user has management role
  const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ success: false, message: 'Management role required' });
    }

    if (!req.file) {
        return res.status(400).json({ success: false, message: 'No image file provided' });
    }

    const { channelId, channelName } = req.body;
    
    if (!channelId || !channelName) {
        return res.status(400).json({ success: false, message: 'Channel ID and name are required' });
    }

    let client;
    try {
        client = await pool.connect();
        
        // Get the Cloudinary URL from the uploaded file
        const imageUrl = req.file.path; // Cloudinary provides the full URL in req.file.path
        const publicId = req.file.filename; // Cloudinary public_id for deletion if needed
        
        // Check if this channel already has a background
        const existingResult = await client.query(`
            SELECT background_image_url, cloudinary_public_id FROM channel_backgrounds WHERE channel_id = $1
        `, [channelId]);
        
        // If there's an existing background, delete the old file from Cloudinary
        if (existingResult.rows.length > 0 && existingResult.rows[0].cloudinary_public_id) {
            try {
                await cloudinary.uploader.destroy(existingResult.rows[0].cloudinary_public_id);
                console.log(`üóëÔ∏è [CHANNEL BACKGROUNDS] Deleted old background from Cloudinary: ${existingResult.rows[0].cloudinary_public_id}`);
            } catch (deleteError) {
                console.warn(`‚ö†Ô∏è [CHANNEL BACKGROUNDS] Could not delete old Cloudinary image: ${deleteError.message}`);
            }
        }
        
        // Insert or update the channel background
        await client.query(`
            INSERT INTO channel_backgrounds (channel_id, channel_name, background_image_url, cloudinary_public_id)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (channel_id) DO UPDATE SET
                channel_name = EXCLUDED.channel_name,
                background_image_url = EXCLUDED.background_image_url,
                cloudinary_public_id = EXCLUDED.cloudinary_public_id,
                updated_at = CURRENT_TIMESTAMP
        `, [channelId, channelName, imageUrl, publicId]);
        
        console.log(`‚úÖ [CHANNEL BACKGROUNDS] Background uploaded for channel: ${channelName} (${channelId})`);
        
        res.json({
            success: true,
            message: 'Background image uploaded successfully',
            imageUrl: imageUrl,
            channelId: channelId,
            channelName: channelName
        });
        
    } catch (error) {
        console.error('‚ùå [CHANNEL BACKGROUNDS] Error uploading background:', error);
        
        // Clean up the uploaded file from Cloudinary if database operation failed
        if (req.file && req.file.filename) {
            try {
                await cloudinary.uploader.destroy(req.file.filename);
                console.log(`üóëÔ∏è [CHANNEL BACKGROUNDS] Cleaned up failed upload from Cloudinary: ${req.file.filename}`);
            } catch (cleanupError) {
                console.warn(`‚ö†Ô∏è [CHANNEL BACKGROUNDS] Could not clean up failed upload: ${cleanupError.message}`);
            }
        }
        
        res.status(500).json({
            success: false,
            message: 'Error uploading background image',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Delete background for a channel
app.delete('/api/admin/channel-backgrounds/:channelId', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Unauthorized' });
    }

    // Check if user has management role
  const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ success: false, message: 'Management role required' });
    }

    const { channelId } = req.params;
    
    let client;
    try {
        client = await pool.connect();
        
        // Get the current background to delete the file
        const existingResult = await client.query(`
            SELECT background_image_url, channel_name, cloudinary_public_id FROM channel_backgrounds WHERE channel_id = $1
        `, [channelId]);
        
        if (existingResult.rows.length === 0) {
            return res.status(404).json({ success: false, message: 'Channel background not found' });
        }
        
        const { background_image_url, channel_name, cloudinary_public_id } = existingResult.rows[0];
        
        // Delete from database
        await client.query(`DELETE FROM channel_backgrounds WHERE channel_id = $1`, [channelId]);
        
        // Delete the image file from Cloudinary
        if (cloudinary_public_id) {
            try {
                await cloudinary.uploader.destroy(cloudinary_public_id);
                console.log(`üóëÔ∏è [CHANNEL BACKGROUNDS] Deleted background from Cloudinary: ${cloudinary_public_id}`);
            } catch (deleteError) {
                console.warn(`‚ö†Ô∏è [CHANNEL BACKGROUNDS] Could not delete from Cloudinary: ${deleteError.message}`);
            }
        } else if (background_image_url && background_image_url.includes('/uploads/backgrounds/')) {
            // Handle old local files for backward compatibility
            const filename = path.basename(background_image_url);
            const filePath = path.join(__dirname, 'public', 'uploads', 'backgrounds', filename);
            
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
                console.log(`üóëÔ∏è [CHANNEL BACKGROUNDS] Deleted background file: ${filename}`);
            }
        }
        
        console.log(`‚úÖ [CHANNEL BACKGROUNDS] Background deleted for channel: ${channel_name} (${channelId})`);
        
        res.json({
            success: true,
            message: 'Background image deleted successfully'
        });
        
    } catch (error) {
        console.error('‚ùå [CHANNEL BACKGROUNDS] Error deleting background:', error);
        res.status(500).json({
            success: false,
            message: 'Error deleting background image',
            error: error.message
        });
    } finally {
        if (client) client.release();
    }
});

// Get background for a specific channel (used by frontend)
app.get('/api/channel-background/:channelId', async (req, res) => {
    const { channelId } = req.params;
    
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(`
            SELECT background_image_url FROM channel_backgrounds WHERE channel_id = $1
        `, [channelId]);
        
        if (result.rows.length > 0) {
            res.json({
                success: true,
                backgroundUrl: result.rows[0].background_image_url
            });
        } else {
            res.json({
                success: true,
                backgroundUrl: null // No custom background, use default
            });
        }
        
    } catch (error) {
        console.error('‚ùå [CHANNEL BACKGROUNDS] Error getting background:', error);
        res.status(500).json({
            success: false,
            message: 'Error getting background image'
        });
    } finally {
        if (client) client.release();
    }
});

// ====================================
// BACKGROUND BLUR SETTINGS
// ====================================

// Get current background blur setting
app.get('/api/ui/background-blur', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(`
            SELECT setting_value FROM reward_settings 
            WHERE setting_type = 'ui' AND setting_name = 'background_blur'
        `);
        
        const blurValue = result.rows.length > 0 ? parseFloat(result.rows[0].setting_value) : 0;
        
        res.json({
            success: true,
            blurValue: blurValue
        });
        
    } catch (error) {
        console.error('‚ùå [BACKGROUND BLUR] Error getting blur setting:', error);
        res.status(500).json({
            success: false,
            message: 'Error getting background blur setting'
        });
    } finally {
        if (client) client.release();
    }
});

// Update background blur setting
app.post('/api/admin/background-blur', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Unauthorized' });
    }

  const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ success: false, message: 'Management role required' });
    }

    const { blurValue } = req.body;
    
    // Validate blur value (0-10)
    if (typeof blurValue !== 'number' || blurValue < 0 || blurValue > 10) {
        return res.status(400).json({ 
            success: false, 
            message: 'Blur value must be a number between 0 and 10' 
        });
    }

    let client;
    try {
        client = await pool.connect();
        
        await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, description)
            VALUES ('ui', 'background_blur', $1, 'Background image blur intensity (0-10)')
            ON CONFLICT (setting_type, setting_name) DO UPDATE SET
                setting_value = EXCLUDED.setting_value,
                updated_at = CURRENT_TIMESTAMP
        `, [blurValue]);
        
        console.log(`‚úÖ [BACKGROUND BLUR] Updated blur setting to: ${blurValue}`);
        
        res.json({
            success: true,
            message: 'Background blur setting updated successfully',
            blurValue: blurValue
        });
        
    } catch (error) {
        console.error('‚ùå [BACKGROUND BLUR] Error updating blur setting:', error);
        res.status(500).json({
            success: false,
            message: 'Error updating background blur setting'
        });
    } finally {
        if (client) client.release();
    }
});

// Get current background darken setting
app.get('/api/ui/background-darken', async (req, res) => {
    let client;
    try {
        client = await pool.connect();
        
        const result = await client.query(`
            SELECT setting_value FROM reward_settings 
            WHERE setting_type = 'ui' AND setting_name = 'background_darken'
        `);
        
        const darkenValue = result.rows.length > 0 ? parseFloat(result.rows[0].setting_value) : 100;
        
        res.json({
            success: true,
            darkenValue: darkenValue
        });
        
    } catch (error) {
        console.error('‚ùå [BACKGROUND DARKEN] Error getting darken setting:', error);
        res.status(500).json({
            success: false,
            message: 'Error getting background darken setting'
        });
    } finally {
        if (client) client.release();
    }
});

// Update background darken setting
app.post('/api/admin/background-darken', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, message: 'Unauthorized' });
    }

  const hasRole = await hasManagementRoleById(req.user.id);
    if (!hasRole) {
        return res.status(403).json({ success: false, message: 'Management role required' });
    }

    const { darkenValue } = req.body;
    
    // Validate darken value (50-100, where 100 is no darkening, 50 is maximum darkening)
    if (typeof darkenValue !== 'number' || darkenValue < 50 || darkenValue > 100) {
        return res.status(400).json({ 
            success: false, 
            message: 'Darken value must be a number between 50 and 100' 
        });
    }

    let client;
    try {
        client = await pool.connect();
        
        await client.query(`
            INSERT INTO reward_settings (setting_type, setting_name, setting_value, description)
            VALUES ('ui', 'background_darken', $1, 'Background image brightness percentage (50-100, where 100 is no darkening)')
            ON CONFLICT (setting_type, setting_name) DO UPDATE SET
                setting_value = EXCLUDED.setting_value,
                updated_at = CURRENT_TIMESTAMP
        `, [darkenValue]);
        
        console.log(`‚úÖ [BACKGROUND DARKEN] Updated darken setting to: ${darkenValue}`);
        
        res.json({
            success: true,
            message: 'Background darken setting updated successfully',
            darkenValue: darkenValue
        });
        
    } catch (error) {
        console.error('‚ùå [BACKGROUND DARKEN] Error updating darken setting:', error);
        res.status(500).json({
            success: false,
            message: 'Error updating background darken setting'
        });
    } finally {
        if (client) client.release();
    }
});

// ====================================
// CATCH-ALL ROUTE (MUST BE LAST)
// ====================================

// Serve attendance page
app.get('/attendance', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'attendance.html'));
});

// API endpoint to verify imported data
app.get('/api/logs/verify-import/:eventId', async (req, res) => {
    try {
        const { eventId } = req.params;
        
        console.log(`üîç [VERIFY] Checking imported data for event: ${eventId}`);
        
        // Query for World Buffs data
        const worldBuffsQuery = `
            SELECT character_name, buff_name, buff_value, color_status, analysis_type
            FROM sheet_players_buffs 
            WHERE event_id = $1 AND analysis_type = 'world_buffs'
            ORDER BY character_name ASC
            LIMIT 50
        `;
        
        // Query for Frost Resistance data  
        const frostResQuery = `
            SELECT character_name, frost_resistance, analysis_type
            FROM sheet_players_frostres 
            WHERE event_id = $1 AND analysis_type = 'frost_resistance'
            ORDER BY character_name ASC
            LIMIT 50
        `;
        
        // Query for RPB data
        const rpbQuery = `
            SELECT character_name, character_class, ability_name, ability_value
            FROM sheet_player_abilities 
            WHERE event_id = $1 
            ORDER BY character_name ASC
            LIMIT 50
        `;
        
        const [worldBuffsResult, frostResResult, rpbResult] = await Promise.all([
            pool.query(worldBuffsQuery, [eventId]),
            pool.query(frostResQuery, [eventId]),
            pool.query(rpbQuery, [eventId])
        ]);
        
        res.json({
            success: true,
            eventId: eventId,
            data: {
                worldBuffs: worldBuffsResult.rows,
                frostResistance: frostResResult.rows,
                rpb: rpbResult.rows
            },
            counts: {
                worldBuffs: worldBuffsResult.rows.length,
                frostResistance: frostResResult.rows.length,
                rpb: rpbResult.rows.length
            }
        });
        
    } catch (error) {
        console.error('‚ùå [VERIFY] Error fetching imported data:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Quick fix endpoint to update wrong archive URL
app.post('/api/fix-archive-url/:eventId', async (req, res) => {
    try {
        const { eventId } = req.params;
        const { correctUrl, analysisType = 'world_buffs' } = req.body;
        
        console.log(`üîß [FIX] Updating ${analysisType} archive URL for event ${eventId} to: ${correctUrl}`);
        
        const result = await pool.query(
            `UPDATE rpb_tracking 
             SET archive_url = $1, 
                 updated_at = CURRENT_TIMESTAMP
             WHERE event_id = $2 AND analysis_type = $3`,
            [correctUrl, eventId, analysisType]
        );
        
        if (result.rowCount > 0) {
            console.log(`‚úÖ [FIX] Updated ${result.rowCount} record(s)`);
            res.json({ success: true, updatedRows: result.rowCount });
        } else {
            console.log(`‚ùå [FIX] No records found to update`);
            res.json({ success: false, message: 'No records found to update' });
        }
        
    } catch (error) {
        console.error('‚ùå [FIX] Error updating archive URL:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// --- Discord identity/players caching for Voice Monitor ---
const discordBotToken = process.env.DISCORD_BOT_TOKEN || null;
const discordGuildId = process.env.DISCORD_GUILD_ID || '777268886939893821';
const discordUserCache = new Map(); // userId -> { displayName, avatarUrl, cachedAt, expiresAt }
const DISCORD_ID_TTL_MS = 45 * 60 * 1000; // 45 minutes
let discordResolveCooldownUntil = 0; // epoch ms until which we avoid hitting Discord API

async function getDiscordUserIdentity(userId) {
    const key = String(userId);
    const now = Date.now();
    const cached = discordUserCache.get(key);
    if (cached && cached.expiresAt > now) return { id: key, displayName: cached.displayName, avatarUrl: cached.avatarUrl };
    // Respect global cooldown on rate limit
    if (now < discordResolveCooldownUntil || !discordBotToken || !discordGuildId) {
        return cached ? { id: key, displayName: cached.displayName, avatarUrl: cached.avatarUrl } : { id: key, displayName: null, avatarUrl: null };
    }
    try {
        const r = await fetch(`https://discord.com/api/v10/guilds/${discordGuildId}/members/${key}`, {
            headers: { 'Authorization': `Bot ${discordBotToken}` }
        });
        if (r.status === 429) {
            const retryAfter = Number(r.headers.get('retry-after'));
            const retryMs = isNaN(retryAfter) ? 5000 : Math.max(0, Math.floor(retryAfter * 1000));
            discordResolveCooldownUntil = now + retryMs;
            return cached ? { id: key, displayName: cached.displayName, avatarUrl: cached.avatarUrl } : { id: key, displayName: null, avatarUrl: null };
        }
        if (!r.ok) {
            return cached ? { id: key, displayName: cached.displayName, avatarUrl: cached.avatarUrl } : { id: key, displayName: null, avatarUrl: null };
        }
        const m = await r.json();
        const user = m.user || {};
        const displayName = m.nick || user.global_name || user.username || key;
        const buildCdn = (hash, base) => {
            if (!hash) return null;
            const isGif = String(hash).startsWith('a_');
            const ext = isGif ? 'gif' : 'png';
            return `${base}.${ext}?size=64`;
        };
        let avatarUrl = null;
        if (m.avatar) {
            avatarUrl = buildCdn(m.avatar, `https://cdn.discordapp.com/guilds/${discordGuildId}/users/${key}/avatars/${m.avatar}`);
        }
        if (!avatarUrl && user.avatar) {
            avatarUrl = buildCdn(user.avatar, `https://cdn.discordapp.com/avatars/${key}/${user.avatar}`);
        }
        if (!avatarUrl) avatarUrl = 'https://cdn.discordapp.com/embed/avatars/0.png';
        const rec = { displayName, avatarUrl, cachedAt: now, expiresAt: now + DISCORD_ID_TTL_MS };
        discordUserCache.set(key, rec);
        return { id: key, displayName, avatarUrl };
    } catch (_) {
        return cached ? { id: key, displayName: cached.displayName, avatarUrl: cached.avatarUrl } : { id: key, displayName: null, avatarUrl: null };
    }
}

const discordCharsCache = new Map(); // userId -> { chars: [], expiresAt }
const DISCORD_CHARS_TTL_MS = 5 * 60 * 1000; // 5 minutes

async function getCharactersByDiscordIds(ids, pool) {
    const now = Date.now();
    const resultMap = {};
    const toQuery = [];
    for (const raw of ids) {
        const id = String(raw);
        const cached = discordCharsCache.get(id);
        if (cached && cached.expiresAt > now) {
            resultMap[id] = cached.chars;
        } else {
            toQuery.push(id);
        }
    }
    if (toQuery.length) {
        let client;
        try {
            client = await pool.connect();
            const q = `SELECT discord_id, character_name, class FROM players WHERE discord_id = ANY($1::text[]) ORDER BY character_name`;
            const r = await client.query(q, [toQuery]);
            const grouped = toQuery.reduce((acc, id) => { acc[id] = []; return acc; }, {});
            for (const row of r.rows) {
                if (!grouped[row.discord_id]) grouped[row.discord_id] = [];
                grouped[row.discord_id].push({ character_name: row.character_name, class: row.class });
            }
            for (const id of toQuery) {
                const chars = grouped[id] || [];
                discordCharsCache.set(id, { chars, expiresAt: now + DISCORD_CHARS_TTL_MS });
                resultMap[id] = chars;
            }
        } catch (err) {
            console.error('Error fetching characters by IDs (cached):', err);
            // Fallback: ensure keys exist
            for (const id of toQuery) {
                resultMap[id] = [];
            }
        } finally {
            if (client) client.release();
        }
    }
    return resultMap;
}

// API to read current members in a given voice channel
app.get('/api/discord/voice/:channelId', (req, res) => {
    const { channelId } = req.params;
    const voiceStateMap = getActiveVoiceStateMap();
    const channelUsers = voiceStateMap.get(channelId);
    // channelUsers is Map(userId -> state) or undefined
    const userIds = channelUsers ? Array.from(channelUsers.keys()) : [];
    res.json({ ok: true, channelId, userIds });
});

// Debug endpoint to inspect all tracked channels
app.get('/api/discord/voice-debug', (req, res) => {
    const voiceStateMap = getActiveVoiceStateMap();
    const all = {};
    for (const [channelId, users] of voiceStateMap.entries()) {
        // users is a Map, so we convert to object with states
        const usersObj = {};
        for (const [userId, state] of users.entries()) {
            usersObj[userId] = state;
        }
        all[channelId] = usersObj;
    }
    res.json({ ok: true, channels: all });
});

// Get recent Discord member join/leave events
app.get('/api/discord/member-events', async (req, res) => {
    try {
        // Fetch from database (single source of truth)
        const limit = parseInt(req.query.limit) || 50;
        const dbResult = await pool.query(`
            SELECT event_type, discord_id, username, discriminator, tag, avatar_url, created_at
            FROM discord_member_events
            ORDER BY created_at DESC
            LIMIT $1
        `, [limit]);
        
        // Map database results to API format
        const events = dbResult.rows.map(row => ({
            eventType: row.event_type,
            userId: row.discord_id,
            username: row.username,
            discriminator: row.discriminator,
            tag: row.tag,
            avatarUrl: row.avatar_url,
            timestamp: row.created_at.toISOString()
        }));
        
        res.json({ ok: true, events });
    } catch (error) {
        console.error('‚ùå Error fetching member events:', error);
        res.status(500).json({ ok: false, error: error.message });
    }
});

// Resolve Discord usernames for a list of user IDs (guild-scoped)
app.post('/api/discord/resolve-users', async (req, res) => {
    try {
        const ids = Array.isArray(req.body?.userIds) ? req.body.userIds.map(String) : [];
        if (!ids.length) return res.json({ ok: true, users: {} });
        const results = {};
        for (const id of ids) {
            const rec = await getDiscordUserIdentity(id);
            results[id] = rec;
        }
        res.json({ ok: true, users: results });
    } catch (err) {
        res.status(500).json({ ok: false, error: err?.message || String(err) });
    }
});

// Batch fetch characters by Discord IDs
app.post('/api/players/by-discord-ids', async (req, res) => {
    const ids = Array.isArray(req.body?.ids) ? req.body.ids.map(String) : [];
    if (!ids.length) return res.json({ ok: true, map: {} });
    try {
        const map = await getCharactersByDiscordIds(ids, pool);
        res.json({ ok: true, map });
    } catch (err) {
        console.error('Error fetching characters by IDs:', err);
        res.status(500).json({ ok: false, error: err?.message || String(err) });
    }
});

// Resolve channel name by ID
app.get('/api/discord/channel/:channelId', async (req, res) => {
    try {
        const { channelId } = req.params;
        if (!discordBotToken) return res.status(500).json({ ok: false, error: 'Bot token not configured' });
        const r = await fetch(`https://discord.com/api/v10/channels/${channelId}`, {
            headers: { 'Authorization': `Bot ${discordBotToken}` }
        });
        if (!r.ok) {
            const text = await r.text();
            return res.status(r.status).json({ ok: false, error: text });
        }
        const ch = await r.json();
        return res.json({ ok: true, id: ch.id, name: ch.name || null });
    } catch (err) {
        res.status(500).json({ ok: false, error: err?.message || String(err) });
    }
});

// Enriched voice endpoint: returns users with cached Discord identities and character links (5s cache + ETag)
app.get('/api/discord/voice-enriched/:channelId', async (req, res) => {
    try {
        const { channelId } = req.params;
        const cacheKey = `voice_enriched:${channelId}`;
        if (!global.__voiceEnrichedCache) global.__voiceEnrichedCache = new Map();
        const now = Date.now();
        const cached = global.__voiceEnrichedCache.get(cacheKey);
        if (cached && (now - cached.ts) < 5000) {
            const inm = String(req.headers['if-none-match'] || '');
            if (inm && inm === cached.etag) { res.status(304).end(); return; }
            res.setHeader('ETag', cached.etag);
            res.setHeader('Cache-Control', 'no-cache');
            res.json(cached.body);
            return;
        }

        const voiceStateMap = getActiveVoiceStateMap();
        const channelUsers = voiceStateMap.get(channelId);
        // channelUsers is Map(userId -> state) or undefined
        const ids = [];
        const states = {};
        if (channelUsers) {
            for (const [userId, state] of channelUsers.entries()) {
                ids.push(userId);
                states[userId] = state || {};
            }
        }
        const identityMap = {};
        for (const id of ids) identityMap[id] = await getDiscordUserIdentity(id);
        const charsMap = await getCharactersByDiscordIds(ids, pool);
        const enriched = ids.map(id => ({ id, displayName: identityMap[id]?.displayName || null, avatarUrl: identityMap[id]?.avatarUrl || null, chars: Array.isArray(charsMap[id]) ? charsMap[id] : [], state: states[id] || {} }));
        const body = { ok: true, channelId, users: enriched };
        const etag = 'W/"' + Buffer.from(String(enriched.length) + ':' + ids.join(',')).toString('base64') + '"';
        global.__voiceEnrichedCache.set(cacheKey, { ts: now, etag, body });
        res.setHeader('ETag', etag);
        res.setHeader('Cache-Control', 'no-cache');
        res.json(body);
    } catch (err) {
        res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
});

// Voice Monitor shared configuration (global, editable by Management only)
app.get('/api/discord/voice-monitor/config', async (req, res) => {
    try {
        // Ensure table exists
        await pool.query(`
            CREATE TABLE IF NOT EXISTS app_settings (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_by TEXT
            )
        `);

        const result = await pool.query('SELECT value FROM app_settings WHERE key = $1', ['voice_monitor_channel_id']);
        const defaultId = '1400574971994181783';
        const channelId = (result.rows && result.rows[0] && result.rows[0].value) ? String(result.rows[0].value) : defaultId;
        res.json({ ok: true, channelId });
    } catch (err) {
        res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
});

app.post('/api/discord/voice-monitor/config', async (req, res) => {
    try {
        if (!req.isAuthenticated || !req.isAuthenticated()) return res.status(401).json({ ok: false, error: 'Authentication required' });
        const isMgmt = await hasManagementRoleById(req.user.id);
        if (!isMgmt) return res.status(403).json({ ok: false, error: 'Management role required' });

        const raw = String(req.body && req.body.channelId != null ? req.body.channelId : '');
        const m = raw.match(/\d{10,}/);
        if (!m) return res.status(400).json({ ok: false, error: 'Invalid channelId' });
        const channelId = m[0];

        // Ensure table exists
        await pool.query(`
            CREATE TABLE IF NOT EXISTS app_settings (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_by TEXT
            )
        `);

        await pool.query(
            `INSERT INTO app_settings (key, value, updated_at, updated_by)
             VALUES ($1, $2, CURRENT_TIMESTAMP, $3)
             ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = CURRENT_TIMESTAMP, updated_by = EXCLUDED.updated_by`,
            ['voice_monitor_channel_id', channelId, String(req.user && req.user.id ? req.user.id : '')]
        );
        res.json({ ok: true, channelId });
    } catch (err) {
        res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
});

// === Voice Check Diagnostic API ===
// Returns debug info about Discord bot and voice tracking status
app.get('/api/voice-check/status', async (req, res) => {
    try {
        const voiceStateMap = getActiveVoiceStateMap();
        const trackedChannels = [];
        for (const [channelId, users] of voiceStateMap.entries()) {
            trackedChannels.push({
                channelId,
                userCount: users.size,
                userIds: Array.from(users.keys())
            });
        }
        
        res.json({
            ok: true,
            voiceStateMapSize: voiceStateMap.size,
            trackedChannels,
            hasGetVoiceStateMap: !!getVoiceStateMap,
            timestamp: new Date().toISOString()
        });
    } catch (e) {
        res.json({
            ok: false,
            error: e?.message || String(e),
            timestamp: new Date().toISOString()
        });
    }
});

// === Voice Check API: "Who is not in Discord?" ===
// Combines roster data with voice channel presence
app.get('/api/voice-check', async (req, res) => {
    try {
        // Get the configured voice channel ID (or use default)
        let channelId = '1400574971994181783'; // Default voice channel
        try {
            const result = await pool.query('SELECT value FROM app_settings WHERE key = $1', ['voice_monitor_channel_id']);
            if (result.rows && result.rows[0] && result.rows[0].value) {
                channelId = String(result.rows[0].value);
            }
        } catch (_) {}

        // Get channel name
        let channelName = null;
        try {
            if (discordBotToken) {
                const r = await fetch(`https://discord.com/api/v10/channels/${channelId}`, {
                    headers: { 'Authorization': `Bot ${discordBotToken}` }
                });
                if (r.ok) {
                    const ch = await r.json();
                    channelName = ch.name || null;
                }
            }
        } catch (_) {}

        // Get event ID from query param or find next upcoming event
        let eventId = req.query.eventId;
        let eventTitle = null;
        let eventStartTime = null;

        // Event ID must be provided by the client (from localStorage or URL)
        if (!eventId) {
            return res.json({ 
                ok: true, 
                channelId, 
                channelName, 
                eventId: null, 
                eventTitle: null, 
                roster: [], 
                voice: [], 
                combined: [],
                message: 'No event selected. Please select an event from the roster page first.'
            });
        }

        // Get event info if not already retrieved
        if (!eventTitle) {
            try {
                const cachedResult = await pool.query(
                    `SELECT events_data FROM events_cache WHERE cache_key = $1 AND expires_at > NOW()`,
                    ['raid_helper_events']
                );
                if (cachedResult.rows.length > 0) {
                    const eventsBlob = cachedResult.rows[0].events_data || {};
                    const list = Array.isArray(eventsBlob.postedEvents) ? eventsBlob.postedEvents : (Array.isArray(eventsBlob) ? eventsBlob : []);
                    const event = list.find(e => String(e.id) === String(eventId));
                    if (event) {
                        eventTitle = event.title || event.templateTitle || null;
                        eventStartTime = event.startTime ? parseInt(event.startTime) * 1000 : null;
                    }
                }
            } catch (_) {}
        }

        // Get roster for the event - first try local overrides, then fallback to Raid Helper API
        let rosterPlayers = [];
        let rosterSource = 'none';
        
        // Try local roster_overrides first
        const rosterResult = await pool.query(
            `SELECT discord_user_id, assigned_char_name, assigned_char_class, party_id, slot_id, player_color
             FROM roster_overrides
             WHERE event_id = $1 AND party_id IS NOT NULL`,
            [eventId]
        );
        
        if (rosterResult.rows.length > 0) {
            rosterSource = 'database';
            rosterPlayers = rosterResult.rows.map(row => ({
                discordId: row.discord_user_id,
                characterName: row.assigned_char_name,
                characterClass: row.assigned_char_class,
                partyId: row.party_id,
                slotId: row.slot_id,
                color: row.player_color
            }));
        } else {
            // Fallback: fetch from Raid Helper API (roster hasn't been forked yet)
            try {
                const rosterData = await getRosterDataFromApi(eventId);
                if (rosterData && Array.isArray(rosterData.raidDrop)) {
                    rosterSource = 'raid-helper-api';
                    // Enrich with database to get proper character names
                    const enrichedRoster = await enrichRosterWithDbData(rosterData, pool);
                    rosterPlayers = enrichedRoster.raidDrop
                        .filter(p => p && p.userid && p.partyId !== undefined && p.partyId !== null)
                        .map(p => ({
                            discordId: p.userid,
                            // Prefer mainCharacterName (from DB enrichment) over signup name
                            characterName: p.mainCharacterName || p.name || null,
                            characterClass: p.class || null,
                            partyId: p.partyId,
                            slotId: p.slotId,
                            color: p.color || null
                        }));
                }
            } catch (apiErr) {
                console.warn('[VOICE-CHECK] Failed to fetch roster from Raid Helper API:', apiErr?.message || apiErr);
            }
        }
        
        const rosterDiscordIds = new Set(rosterPlayers.map(p => p.discordId).filter(Boolean));

        // Get voice channel users
        const voiceStateMap = getActiveVoiceStateMap();
        const channelUsers = voiceStateMap.get(channelId);
        const voiceUsers = [];
        const voiceDiscordIds = new Set();

        if (channelUsers) {
            for (const [userId, state] of channelUsers.entries()) {
                voiceDiscordIds.add(userId);
                voiceUsers.push({
                    discordId: userId,
                    state: state || {}
                });
            }
        }

        // Resolve Discord identities for all users
        const allDiscordIds = [...new Set([...rosterDiscordIds, ...voiceDiscordIds])];
        const identityMap = {};
        for (const id of allDiscordIds) {
            identityMap[id] = await getDiscordUserIdentity(id);
        }

        // Build combined list
        const combined = [];

        // Add users in roster
        for (const player of rosterPlayers) {
            const inVoice = voiceDiscordIds.has(player.discordId);
            const voiceUser = voiceUsers.find(v => v.discordId === player.discordId);
            const identity = identityMap[player.discordId] || {};
            combined.push({
                discordId: player.discordId,
                discordName: identity.displayName || null,
                avatarUrl: identity.avatarUrl || 'https://cdn.discordapp.com/embed/avatars/0.png',
                characterName: player.characterName,
                characterClass: player.characterClass,
                color: player.color,
                partyId: player.partyId,
                slotId: player.slotId,
                inRoster: true,
                inVoice: inVoice,
                voiceState: voiceUser?.state || null,
                status: inVoice ? 'online' : 'missing' // green vs red
            });
        }

        // Add users in voice but NOT in roster
        for (const voiceUser of voiceUsers) {
            if (!rosterDiscordIds.has(voiceUser.discordId)) {
                const identity = identityMap[voiceUser.discordId] || {};
                combined.push({
                    discordId: voiceUser.discordId,
                    discordName: identity.displayName || null,
                    avatarUrl: identity.avatarUrl || 'https://cdn.discordapp.com/embed/avatars/0.png',
                    characterName: null,
                    characterClass: null,
                    color: null,
                    partyId: null,
                    slotId: null,
                    inRoster: false,
                    inVoice: true,
                    voiceState: voiceUser.state || null,
                    status: 'extra' // yellow - in voice but not in roster
                });
            }
        }

        // Sort: online first, then missing, then extra
        const statusOrder = { online: 0, missing: 1, extra: 2 };
        combined.sort((a, b) => {
            const orderDiff = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
            if (orderDiff !== 0) return orderDiff;
            // Secondary sort by character name or discord name
            const nameA = (a.characterName || a.discordName || '').toLowerCase();
            const nameB = (b.characterName || b.discordName || '').toLowerCase();
            return nameA.localeCompare(nameB);
        });

        // Debug info - reuse voiceStateMap from above
        const trackedChannels = Array.from(voiceStateMap.keys());
        
        res.json({
            ok: true,
            channelId,
            channelName,
            eventId,
            eventTitle,
            eventStartTime,
            rosterCount: rosterPlayers.length,
            voiceCount: voiceUsers.length,
            onlineCount: combined.filter(p => p.status === 'online').length,
            missingCount: combined.filter(p => p.status === 'missing').length,
            extraCount: combined.filter(p => p.status === 'extra').length,
            combined,
            _debug: {
                trackedVoiceChannels: trackedChannels,
                rosterSource: rosterSource
            }
        });
    } catch (err) {
        console.error('‚ùå [VOICE-CHECK] Error:', err);
        res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
});

// Register rewards engine endpoints BEFORE catch-all
try {
  if (typeof registerRewardsEngine === 'function') {
    registerRewardsEngine(app, pool);
    console.log('‚úÖ Rewards engine endpoints registered');
  } else {
    console.log('‚ö†Ô∏è Rewards engine module not available, skipping registration');
  }
} catch (err) {
  console.error('‚ùå Failed to register rewards engine endpoints:', err && (err.message || String(err)));
}

// This route will handle both the root path ('/') AND any other unmatched paths,
// serving events.html. It MUST be the LAST route definition in your application.
// BUT exclude API routes to avoid interfering with API endpoints.
app.get('*', (req, res, next) => {
  // Let static assets, API routes, health checks, and Socket.IO pass through
  if (req.path.startsWith('/api/') || req.path === '/healthz' || req.path.startsWith('/socket.io') || req.path.includes('.')) {
    return next();
  }
  res.sendFile(path.join(__dirname, 'public', 'events.html'));
});

// --- Server Start ---
// Periodic cleanup for Raid-Helper event cache (runs every 24 hours)
setInterval(async () => {
    try {
        console.log('üßπ [SCHEDULED] Running periodic Raid-Helper cache cleanup...');
        const cleanedCount = await cleanupRaidHelperEventCache(365); // Clean entries older than 1 year
        if (cleanedCount > 0) {
            console.log(`üßπ [SCHEDULED] Cleaned up ${cleanedCount} old cache entries`);
        } else {
            console.log('üßπ [SCHEDULED] No old cache entries to clean up');
        }
    } catch (error) {
        console.error('‚ùå [SCHEDULED] Error during periodic cache cleanup:', error);
    }
}, 24 * 60 * 60 * 1000); // 24 hours in milliseconds

const server = app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  
  // Run initial cache cleanup on startup
  setTimeout(async () => {
      try {
          console.log('üßπ [STARTUP] Running initial Raid-Helper cache cleanup...');
          await cleanupRaidHelperEventCache(365);
      } catch (error) {
          console.error('‚ùå [STARTUP] Error during initial cache cleanup:', error);
      }
  }, 5000); // Wait 5 seconds after startup
});

// Set server timeout to 5 minutes (300 seconds) for long-running operations
server.timeout = 300000;

// Attach Socket.IO for chat after server starts
if (attachChatIo) {
  (async () => {
    try {
      const { io } = await attachChatIo(server);
      console.log('‚úÖ Site chat Socket.IO initialized');
      app.set('io', io);
    } catch (err) {
      console.error('‚ùå Failed to initialize Site chat Socket.IO:', err && err.message ? err.message : err);
    }
  })();
}

// Initialize Discord bridge separately (for voice tracking even if Socket.IO fails)
if (createDiscordBridge) {
  (async () => {
    try {
      // Create callback to persist member events to database
      const persistMemberEvent = async (event) => {
        try {
          await pool.query(`
            INSERT INTO discord_member_events (event_type, discord_id, username, discriminator, tag, avatar_url)
            VALUES ($1, $2, $3, $4, $5, $6)
          `, [event.eventType, event.userId, event.username, event.discriminator, event.tag, event.avatarUrl]);
        } catch (err) {
          console.error('‚ùå Failed to insert member event to DB:', err?.message || err);
        }
      };
      
      const bridge = createDiscordBridge({ persistMemberEvent });
      if (bridge && typeof bridge.start === 'function') {
        await bridge.start();
        // Set up text chat handler if available
        if (setOutboundHandler && typeof bridge.sendToDiscord === 'function') {
          setOutboundHandler(async (payload) => { await bridge.sendToDiscord(payload); });
        }
        console.log('‚úÖ Discord bridge initialized with member event tracking');
        try { console.log('[bridge] status', typeof bridge.getStatus === 'function' ? bridge.getStatus() : null); } catch(_) {}
      }
    } catch (err) {
      console.error('‚ùå Failed to initialize Discord bridge:', err && err.message ? err.message : err);
    }
  })();
}

// --- Graceful Shutdown ---
process.on('SIGINT', () => {
  console.log('Shutting down server...');
  pool.end(() => {
    console.log('Database pool has ended.');
    process.exit(0);
  });
});

// --- Global error handlers & health endpoint ---
process.on('unhandledRejection', (reason) => { try { console.error('Unhandled Rejection:', reason); } catch {} });
process.on('uncaughtException', (err) => { try { console.error('Uncaught Exception:', err); } catch {} });

app.get('/healthz', async (req, res) => {
  try {
    const t0 = Date.now();
    await pool.query('SELECT 1');
    const dbMs = Date.now() - t0;
    const discordConfigured = !!process.env.DISCORD_BOT_TOKEN && !!process.env.DISCORD_GUILD_ID;
    const redisConfigured = !!process.env.REDIS_URL;
    res.json({ ok: true, dbMs, discordConfigured, redisConfigured });
  } catch (err) {
    res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  }
});

// --- Site Chat: Image upload endpoint (Cloudinary) ---
try {
  const chatImageStorage = new CloudinaryStorage({
    cloudinary,
    params: {
      folder: 'site-chat',
      resource_type: 'image'
    }
  });
  const chatImageUpload = multer({
    storage: chatImageStorage,
    limits: { fileSize: 200 * 1024 },
    fileFilter: (req, file, cb) => {
      try {
        const allowed = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowed.includes(String(file.mimetype || ''))) return cb(new Error('Invalid file type'));
        return cb(null, true);
      } catch (e) { return cb(e); }
    }
  });

  app.post('/api/chat/upload', chatImageUpload.single('file'), (req, res) => {
    try {
      if (!req.isAuthenticated || !req.isAuthenticated()) return res.status(401).json({ ok: false, error: 'Not authenticated' });
      const url = req && req.file && (req.file.path || req.file.url);
      if (!url) return res.status(400).json({ ok: false, error: 'Upload failed' });
      const thumbUrl = String(url).replace('/upload/', '/upload/f_auto,q_auto,w_256/');
      res.json({ ok: true, url, thumbUrl });
    } catch (err) {
      res.status(400).json({ ok: false, error: err && err.message ? err.message : String(err) });
    }
  });
} catch (e) {
  console.warn('‚ö†Ô∏è Chat upload endpoint not initialized:', e && e.message ? e.message : e);
}

// --- Basic identity endpoint for chat widget ---
app.get('/api/auth/whoami', (req, res) => {
  try {
    if (!req.isAuthenticated || !req.isAuthenticated()) {
      return res.status(401).json({ ok: false, error: 'Not authenticated' });
    }
    const u = req.user || {};
    const userId = String(u.id || '') || null;
    const userName = u.global_name || u.username || 'Unknown';
    const avatarUrl = u.avatar ? `https://cdn.discordapp.com/avatars/${userId}/${u.avatar}.png` : null;
    const roles = [];
    return res.json({ ok: true, userId, userName, avatarUrl, roles });
  } catch (err) {
    res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  }
});

// --- Admin toggle and user prefs (placeholders) ---
let CHAT_ENABLED = true;
app.get('/api/chat/config', (req, res) => {
  try { res.json({ ok: true, enabled: !!CHAT_ENABLED, userDisabled: false }); } catch (err) { res.status(500).json({ ok: false, error: err?.message || String(err) }); }
});

app.post('/api/chat/config', requireManagement, express.json(), (req, res) => {
  try { CHAT_ENABLED = !!(req.body && req.body.enabled); res.json({ ok: true, enabled: !!CHAT_ENABLED }); } catch (err) { res.status(500).json({ ok: false, error: err?.message || String(err) }); }
});

app.post('/api/chat/prefs', express.json(), (req, res) => {
  // Placeholder: store per-user preference later
  try { res.json({ ok: true }); } catch (err) { res.status(500).json({ ok: false, error: err?.message || String(err) }); }
});

// Chat moderation: delete message (Management only). Emits over Socket.IO to all clients
app.post('/api/chat/mod/delete', requireManagement, express.json(), async (req, res) => {
  try {
    const id = req.body && req.body.id;
    if (!id) return res.status(400).json({ ok: false, error: 'Missing id' });
    try {
      const store = require('./scripts/chat-store.cjs');
      await store.deleteMessage(id);
    } catch(_) {}
    try {
      const io = req.app.get('io');
      if (io) io.of('/site-chat').to('global').emit('message:delete', { id, deletedBy: 'management' });
    } catch(_) {}
    res.json({ ok: true });
  } catch (err) {
    res.status(500).json({ ok: false, error: err && err.message ? err.message : String(err) });
  }
});

// Voice monitor removed per request
// Voice monitor removed per request