<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raid Logs Viewer</title>
  <link rel="stylesheet" href="/style.css?v=frsync-4">
  <link rel="stylesheet" href="/raidlogs.css?v=frsync-4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="raidlogs raidlogs-view has-raid-bar">
  <div class="top-bar">
    <div class="top-bar-left">
      <img src="/images/1p_logo.png" alt="1Principles" class="app-logo" width="110" height="30">
      <nav class="top-nav">
        <a href="/" class="top-nav-link">Home</a>
        <div class="top-nav-dropdown">
          <button class="top-nav-link dropdown-toggle" id="upcoming-raids-dropdown">
            Upcoming Raids <i class="fas fa-chevron-down"></i>
          </button>
          <div class="dropdown-menu" id="upcoming-raids-menu">
            <div class="dropdown-loading">Loading raids...</div>
          </div>
        </div>
        <a href="/guild-members" class="top-nav-link">Guild Members</a>
        <a href="/attendance" class="top-nav-link">Regular Attendance</a>
      </nav>
    </div>
    <div id="auth-container">
      <!-- Auth content is loaded by top-bar.js -->
    </div>
  </div>

  <!-- Active Raid Bar (shown when raid is selected) -->
  <div class="raid-bar" id="raid-bar" style="display: none;">
    <div class="raid-bar-left">
      <span class="raid-title" id="raid-title">Loading...</span>
      <nav class="raid-nav">
        <a href="#" class="raid-nav-link" id="raid-roster-link">
          <i class="fas fa-users"></i> Roster
        </a>
        <a href="#" class="raid-nav-link" id="raid-assignments-link">
          <i class="fas fa-tasks"></i> Assignments
        </a>
        <a href="/raidlogs" class="raid-nav-link active" id="raid-logs-link">
          <i class="fas fa-chart-line"></i> Raid Logs
        </a>
        <a href="/gold" class="raid-nav-link" id="raid-goldpot-link">
          <i class="fas fa-coins"></i> Gold Pot
        </a>
        <a href="/loot" class="raid-nav-link" id="raid-loot-link">
          <i class="fas fa-shield-alt"></i> Loot
        </a>
      </nav>
    </div>
    <div class="raid-bar-right">
      <button class="raid-close-btn" onclick="localStorage.removeItem('activeEventSession'); location.reload();">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
  <div class="container">
    <!-- Floating Admin Actions (Public view) - Only "Go to Admin view" button visible -->
    <nav class="floating-admin-actions" id="floating-admin-actions" style="display:none;">
      <div class="faa-buttons" id="faa-buttons-public">
        <button class="faa-btn" id="faa-switch-admin" title="Go to admin view"><i class="fas fa-user-shield"></i> Go to Admin view</button>
        <button class="faa-btn" id="faa-publish" title="Publish data" style="display:none;"><i class="fas fa-cloud-upload-alt"></i> Publish data</button>
        <button class="faa-btn" id="faa-refresh" title="Refresh published snapshot" style="display:none;"><i class="fas fa-sync-alt"></i> Refresh logs</button>
        <button class="faa-btn" id="faa-revert" title="Revert to computed" style="display:none;"><i class="fas fa-undo"></i> Revert to computed</button>
        <button class="faa-btn" id="faa-upload-logs" title="Upload logs" style="display:none;"><i class="fas fa-upload"></i> Upload logs</button>
      </div>
    </nav>
    <div class="page-header" style="display:none;">
      <h1>Raid Logs</h1>
      <p id="view-subtitle">Published snapshot</p>
    </div>

    <div class="loading-indicator" id="loading" style="display:block">
      <div class="spinner"></div>
      <p>Loading published raid data...</p>
    </div>

    <div class="raid-logs-container" id="content" style="display:none">
      <div class="stats-section scroll-target" id="stats-dashboard">
        <div class="stats-dashboard" id="dashboard-panel">
          <div class="stat-card raid-duration">
            <i class="fas fa-clock stat-icon"></i>
            <div class="stat-label">Raid Duration</div>
            <div class="stat-value" id="raid-duration-value">--</div>
            <div class="stat-detail">Minutes</div>
          </div>
          <div class="stat-card bosses-killed">
            <i class="fas fa-skull stat-icon"></i>
            <div class="stat-label">Bosses Killed</div>
            <div class="stat-value" id="bosses-killed-value">--</div>
            <div class="stat-detail">Boss encounters</div>
          </div>
          <div class="stat-card last-boss">
            <i class="fas fa-trophy stat-icon"></i>
            <div class="stat-label">Last Boss</div>
            <div class="stat-value" id="last-boss-value">--</div>
            <div class="stat-detail" id="last-boss-detail">—</div>
          </div>
          <div class="stat-card wow-logs">
            <i class="fas fa-chart-line stat-icon"></i>
            <div class="stat-label">WoW Logs</div>
            <div class="stat-value"><button class="wow-logs-button" id="wow-logs-button" disabled>View Logs</button></div>
            <div class="stat-detail" id="wow-logs-detail">—</div>
          </div>
          <div class="stat-card rpb-archive" id="rpb-archive-card">
            <i class="fas fa-external-link-alt stat-icon"></i>
            <div class="stat-label">RPB Archive</div>
            <div class="stat-value"><button class="rpb-button" id="rpb-archive-button" disabled>View RPB</button></div>
            <div class="stat-detail" id="rpb-archive-detail">—</div>
          </div>
        </div>
      </div>

      <!-- Manual Rewards and Deductions Panel (viewer) -->
      <div class="manual-rewards-section scroll-target" id="manual-rewards-section" style="display:none">
        <div class="section-header">
          <h2><i class="fas fa-balance-scale"></i> Manual Rewards and Deductions</h2>
          <p>Published manual rewards and deductions for this event</p>
        </div>
        <div class="manual-rewards-content">
          <div class="manual-rewards-columns">
            <div class="manual-col" id="manual-rewards-list-rewards"></div>
            <div class="manual-col" id="manual-rewards-list-deductions"></div>
          </div>
          <div class="no-entries-message" id="manual-no-entries" style="display:none">
            <i class="fas fa-inbox"></i>
            <p>No manual rewards or deductions have been published yet.</p>
          </div>
        </div>
      </div>

      <div class="rankings-container" id="panels"></div>
    </div>
  </div>

  <script>
  // Party mapping for tank group detection in Totems panel (viewer) - GLOBAL SCOPE
  let nameToPartyMap = new Map();
  async function fetchRosterPartyMap(eventId){
    try{
      const res = await fetch(`/api/roster/${eventId}`);
      if(!res.ok) return;
      const data = await res.json();
      console.log('[VIEWER DEBUG] Roster API response:', data);
      console.log('[VIEWER DEBUG] raidDrop:', data.raidDrop);
      console.log('[VIEWER DEBUG] bench:', data.bench);
      console.log('[VIEWER DEBUG] unmatchedPlayers:', data.unmatchedPlayers);
      if (data.raidDrop && data.raidDrop[0]) {
        console.log('[VIEWER DEBUG] First raidDrop item:', data.raidDrop[0]);
        console.log('[VIEWER DEBUG] First raidDrop item keys:', Object.keys(data.raidDrop[0]));
      }
      const map = new Map();
      const add = (arr)=>Array.isArray(arr)&&arr.forEach(p=>{
        const k = String(p.mainCharacterName||'').toLowerCase();
        const partyId = Number(p.partyId||0);
        console.log('[VIEWER DEBUG] Processing:', p.mainCharacterName, '→ party', partyId);
        if(k) map.set(k, partyId);
      });
      add(data.raidDrop); add(data.bench); add(data.unmatchedPlayers);
      nameToPartyMap = map;
      console.log('[VIEWER DEBUG] Party map loaded:', Array.from(map.entries()));
    }catch(err){
      console.error('[VIEWER DEBUG] Failed to load party map:', err);
    }
  }
  
  // Viewer layout helpers to emulate admin sizing
  (function(){
    // Panel info overlays (copied from admin behavior)
    window.attachPanelInfoOverlay = function(section){
      if (!section || section.__panelInfoAttached) return;
      section.__panelInfoAttached = true;
      try { section.style.position = section.style.position || 'relative'; } catch {}

      const overlay = document.createElement('div');
      overlay.className = 'panel-info-overlay';

      // Default copy and per-panel content mapping
      let infoTitle = 'Panel Details';
      let infoSubtitle = '';
      let infoBody = 'Detailed explanation is missing for this panel';
      let infoList = null;

      const has = (cls) => section.classList.contains(cls);

      if (has('sunder-section')) {
        infoTitle = 'Sunder Armor Points';
        infoSubtitle = 'Points are awarded based on each DPS warrior\'s use of Sunder Armor compared to the raid average.';
        infoBody = '';
        infoList = [
          '<strong>Less than 25% of the average</strong>: -20 points',
          '<strong>25–49% of the average</strong>: -15 points',
          '<strong>50–74% of the average</strong>: -10 points',
          '<strong>75–89% of the average</strong>: -5 points',
          '<strong>90–109% of the average</strong>: 0 points',
          '<strong>110–124% of the average</strong>: +5 points',
          '<strong>125% or more of the average</strong>: +10 points'
        ];
      } else if (has('windfury-section')) {
        infoTitle = 'Totems Points — How this panel works';
        infoSubtitle = 'We know this is complicated, but the short version is: keep Windfury up, weave in Grace of Air, and cast Strength of Earth when it helps — do that and you\'ll earn lots of points.' + '<br><br>' + 'Below is a quick overview of how each totem earns points. For details per player, hover the text under a name to see who contributed to the average, who was excluded, and the exact numbers.';
        infoBody = '<strong>Party average</strong>: Warriors only; anyone below 50% of the top Warrior in your party is excluded from the average and shown in red in the hover list. The Tank group is labeled "(Tank group)".';
        infoList = [
          '<strong>Windfury Totem (WF)</strong>: Your party\'s average "extra WF attacks" (Warriors only) is compared to the raid baseline. Tiers: <em><75%</em>=0 pts, <em>75–99%</em>=10 pts, <em>100–125%</em>=15 pts, <em>>125%</em>=20 pts. Tank group has half the normal requirement; very low Warriors (below 50% of the party\'s top Warrior) are excluded from the average (still shown in red).',
          '<strong>Grace of Air Totem</strong>: To qualify, drop ≥10 totems and have party WF average ≥75% of baseline (Tank group: half requirement). Points = +1 per 10 totems, up to 20.',
          '<strong>Strength of Earth Totem</strong>: To qualify, drop ≥10 totems and have party WF average ≥75% of baseline (Tank group: half requirement). Points = +1 per 10 totems, up to 10.',
          '<strong>Tranquil Air Totem</strong>: No WF requirement. Points = +1 per 10 totems, up to 5.'
        ];
      } else if (has('rocket-helmet-section')) {
        infoTitle = 'Goblin Rocket Helmet';
        infoBody = 'On Kel\'Thuzad in Naxxramas, you can earn 5 bonus points by using a Goblin Rocket Helmet to stun an add during Phase 3.';
      } else if (has('interrupts-section')) {
        infoTitle = 'Interrupted spells';
        infoSubtitle = 'Ranked by points (1 pt per 2 interrupts, max 5)';
        infoBody = 'We count how many enemy casts you interrupted. Every 2 interrupts = 1 point, capped at 5 points. Tooltip shows your total interrupts.';
      } else if (has('disarms-section')) {
        infoTitle = 'Disarmed enemies';
        infoSubtitle = 'Ranked by points (1 pt per 3 disarms, max 5)';
        infoBody = 'We count how many Disarms you used. Every 3 disarms = 1 point, capped at 5 points. Tooltip shows your total disarms.';
      } else if (has('abilities-section')) {
        infoTitle = 'Engineering & Holywater';
        infoSubtitle = 'Calculated points (configurable)';
        infoBody = 'Points = floor((Total used × Avg targets) ÷ N), capped at Max. Defaults: N=10, Max=20. We track Dense Dynamite, Goblin Sapper, and Stratholme Holy Water. Hover a name to see your breakdown and the exact calculation.';
      } else if (has('runes-section')) {
        infoTitle = 'Dark or Demonic runes';
        infoBody = 'Points are awarded by usage: you gain points for every set of runes used based on the division in the header (e.g., 1 point per 2 runes), up to the panel\'s maximum. Hover a name to see your total Dark/Demonic runes and divisions.';
      } else if (has('mana-potions-section')) {
        infoTitle = 'Major Mana Potions';
        infoBody = 'Points are awarded for potions used above the threshold shown in the header. Every N potions above the threshold = 1 point (see header for N), capped at the maximum. Hover a name to see your total potions and how many counted for points.';
      } else if (has('streak-section')) {
        infoTitle = 'Attendance Streak Champions';
        infoBody = 'Points are awarded for consistent weekly attendance: 4 weeks = 3 pts, 5 = 6 pts, 6 = 9 pts, 7 = 12 pts, and 8+ weeks = 15 pts.';
      } else if (has('guild-section')) {
        infoTitle = 'Guild Members';
        infoBody = 'Every confirmed guild member present in the raid earns a flat +10 points.';
      } else if (has('god-gamer-dps-section')) {
        infoTitle = 'God Gamer DPS';
        infoSubtitle = 'Exceptional damage performance is rewarded as follows:';
        infoBody = '';
        infoList = [
          '30 points if you are #1 on damage and exceed #2 by at least 250,000 damage.',
          '20 points if you are #1 on damage and exceed #2 by at least 150,000 damage.'
        ];
      } else if (has('god-gamer-healer-section')) {
        infoTitle = 'God Gamer HPS';
        infoSubtitle = 'Exceptional healing performance is rewarded as follows:';
        infoBody = '';
        infoList = [
          '20 points if you are #1 on healing and exceed #2 by at least 250,000 healing.',
          '15 points if you are #1 on healing and exceed #2 by at least 150,000 healing.'
        ];
      } else if (has('curse-recklessness-section')) {
        infoTitle = 'Curse of Recklessness';
        infoSubtitle = 'Ranked by points (>70% uptime earns points)';
        infoBody = 'We measure how long your Curse of Recklessness was active when it mattered. Maintain high uptime to earn points; below the threshold earns 0.';
      } else if (has('curse-shadow-section')) {
        infoTitle = 'Curse of Shadow';
        infoSubtitle = 'Ranked by points (>70% uptime earns points)';
        infoBody = 'Warlocks are credited when Curse of Shadow is maintained. Keep it up for most of the fight to earn points; low uptime earns 0.';
      } else if (has('curse-elements-section')) {
        infoTitle = 'Curse of the Elements';
        infoSubtitle = 'Ranked by points (>70% uptime earns points)';
        infoBody = 'We credit uptime for Curse of the Elements. Aim for strong, consistent uptime across encounters to earn points.';
      } else if (has('faerie-fire-section')) {
        infoTitle = 'Faerie Fire';
        infoSubtitle = 'Ranked by points (>70% uptime earns points)';
        infoBody = 'Druids (or other valid sources) earn points for keeping Faerie Fire up. The higher the uptime, the better.';
      } else if (has('scorch-section')) {
        infoTitle = 'Scorch';
        infoSubtitle = 'Ranked by tiers (0–99: 0 pts, 100–199: 5 pts, 200+: 10 pts)';
        infoBody = 'We count total Scorches applied. Hitting 100 grants points; 200+ grants the maximum.';
      } else if (has('demo-shout-section')) {
        infoTitle = 'Demoralizing Shout';
        infoSubtitle = 'Ranked by tiers (0–99: 0 pts, 100–199: 5 pts, 200+: 10 pts)';
        infoBody = 'We count the number of Demo Shouts used. Reach the thresholds to earn 5 or 10 points.';
      } else if (has('polymorph-section')) {
        infoTitle = 'Polymorph';
        infoSubtitle = 'Ranked by points (1 pt per 2 polymorphs, max 5)';
        infoBody = 'Polymorphs help crowd control. Every two successful casts award a point, up to five points total.';
      } else if (has('power-infusion-section')) {
        infoTitle = 'Power Infusion';
        infoSubtitle = 'Ranked by points (1 pt per 2 infusions, max 10, excludes self-casts)';
        infoBody = 'Priests earn points for buffing teammates with Power Infusion. Self-casts do not count.';
      } else if (has('decurses-section')) {
        infoTitle = 'Decurses';
        infoSubtitle = 'Ranked by average-based points (vs raid average, -10 to +10)';
        infoBody = 'We compare your decurse count against the raid average: every 3 above average adds points, every 3 below average deducts, within the -10 to +10 range.';
      } else if (has('void-damage-section')) {
        infoTitle = 'Avoidable Void Damage';
        infoSubtitle = 'Penalties for standing in bad';
        infoBody = 'Taking damage from Void Blast or Void Zone costs points. Avoid the effects to keep your score clean. The panel shows totals and a breakdown by source.';
      } else if (has('big-buyer-section')) {
        infoTitle = 'Big Buyer Bonus';
        infoSubtitle = 'Top 3 spenders (≥25,000 gold) earn bonus points';
        infoBody = 'The highest spenders receive extra points, up to 20, based on gold spent thresholds. Only purchases ≥ 25,000 gold qualify.';
      } else if (has('damage')) {
        infoTitle = 'Damage Dealers';
        infoSubtitle = 'Rank-based points (configurable)';
        infoBody = 'Points are awarded by rank using a configured points array. By default: 1st=80, 2nd=70, 3rd=55, then 40, 35, 30, 25, 20, 15, 10, 8, 6, 5, 4, 3. Players ranked beyond the configured list receive 0 points.';
        infoList = null;
      } else if (has('healing')) {
        infoTitle = 'Healers';
        infoSubtitle = 'Rank-based points (configurable)';
        infoBody = 'Points are awarded by rank using a configured points array. By default: 1st=80, 2nd=65, 3rd=60, 4th=55, then 40, 35, 30, 20, 15, 10. Players beyond the configured list receive 0 points.';
        infoList = null;
      } else if (has('too-low-damage-section')) {
        infoTitle = 'Too Low Damage';
        infoSubtitle = 'Penalties based on DPS vs active fight time';
        infoList = [
          '&lt;150 DPS = -100',
          '150–199.9 DPS = -50',
          '200–249.9 DPS = -25'
        ];
        infoBody = 'Only primary-role DPS are considered. Support assignments may be excluded via primary role data.';
      } else if (has('too-low-healing-section')) {
        infoTitle = 'Too Low Healing';
        infoSubtitle = 'Penalties based on HPS vs active fight time';
        infoList = [
          'Very low HPS incurs deductions (same scale as low DPS)'
        ];
        infoBody = 'Only primary-role Healers are considered. Support assignments may be excluded via primary role data.';
      } else if (has('frost-resistance-section')) {
        infoTitle = 'Frost Resistance';
        infoSubtitle = 'This rule applies to Sapphiron and affects DPS players only. Insufficient frost resistance results in penalties:';
        infoBody = '';
        infoList = [
          '<strong>Warriors, Rogues, Hunters</strong>',
          '30 frost resistance',
          '-10 points if below 80 frost resistance',
          '',
          '<strong>Mages, Warlocks</strong>',
          '-5 points if below 150 frost resistance',
          '-10 points if below 80 frost resistance',
          '',
          'Only frost resistance from items and enchants is counted. Class abilities, racial abilities, buffs, and consumables are not included — you are expected to use those in addition to the required gear.'
        ];
      } else if (has('world-buffs-section')) {
        infoTitle = 'World Buffs';
        infoBody = 'Points are deducted for missing key world buffs. Default: -10 per missing buff when below 4/6; thresholds may be configured.';
      }

      const parts = [];
      parts.push('<div class="panel-info-overlay-content">');
      parts.push(`<h4 class="panel-info-title">${infoTitle}</h4>`);
      if (infoSubtitle) parts.push(`<p class="panel-info-subtitle">${infoSubtitle}</p>`);
      if (Array.isArray(infoList) && infoList.length) {
        parts.push('<ul class="panel-info-list">');
        infoList.forEach(item => parts.push(`<li>${item}</li>`));
        parts.push('</ul>');
      }
      if (infoBody) parts.push(`<p class="panel-info-body">${infoBody}</p>`);
      parts.push('</div>');
      overlay.innerHTML = parts.join('');
      section.appendChild(overlay);

      const closeX = document.createElement('div');
      closeX.className = 'panel-info-close-x';
      closeX.innerHTML = '<i class="fas fa-times-circle" aria-hidden="true"></i>';
      try { closeX.setAttribute('title', 'Close'); } catch {}
      overlay.appendChild(closeX);

      const header = section.querySelector('.section-header');
      if (!header) return;
      header.style.position = header.style.position || 'relative';
      const icon = document.createElement('div');
      icon.className = 'panel-info-icon';
      icon.textContent = '?';
      header.appendChild(icon);

      let timerId = null;
      let lastX = 0, lastY = 0;
      let isLocked = false;
      const threshold = 3;
      const delayMs = 1000;

      const clearTimer = () => { if (timerId) { clearTimeout(timerId); timerId = null; } };
      const showOverlayLocked = (locked) => {
        if (locked) overlay.classList.add('locked'); else overlay.classList.remove('locked');
        overlay.classList.add('show');
      };
      const startTimer = () => {
        clearTimer();
        timerId = setTimeout(() => { showOverlayLocked(false); }, delayMs);
      };
      const onEnter = (e) => {
        if (isLocked) return;
        lastX = e.clientX; lastY = e.clientY;
        startTimer();
      };
      const onMove = (e) => {
        if (isLocked) return;
        const dx = Math.abs(e.clientX - lastX);
        const dy = Math.abs(e.clientY - lastY);
        if (dx > threshold || dy > threshold) {
          lastX = e.clientX; lastY = e.clientY;
          startTimer();
        }
      };
      const hideOverlay = () => { overlay.classList.remove('show'); overlay.classList.remove('locked'); };

      icon.addEventListener('mouseenter', onEnter);
      icon.addEventListener('mousemove', onMove);
      icon.addEventListener('mouseleave', () => { clearTimer(); if (!isLocked) hideOverlay(); });
      icon.addEventListener('click', () => { clearTimer(); isLocked = true; showOverlayLocked(true); });
      overlay.addEventListener('mouseleave', () => { if (!isLocked) hideOverlay(); });
      overlay.addEventListener('click', () => { if (!isLocked) hideOverlay(); });
      closeX.addEventListener('click', (e) => { e.stopPropagation(); isLocked = false; hideOverlay(); });
    }

    window.initializePanelInfoOverlays = function(){
      try {
        const sections = Array.from(document.querySelectorAll('.rankings-section'));
        sections.forEach(section => window.attachPanelInfoOverlay(section));
      } catch {}
    }

    // Wire floating admin actions (public view: switch to admin, and upload logs)
    try {
    const faa = document.getElementById('floating-admin-actions');
    if (faa) {
      // Show only for users with management role
      try {
        fetch('/user').then(r=>r.json()).then(u=>{
          const canManage = !!(u && u.hasManagementRole);
          faa.style.display = canManage ? 'block' : 'none';
        }).catch(()=>{ faa.style.display='none'; });
      } catch { faa.style.display='none'; }
    }
      const getEventId = () => {
        try { const parts = window.location.pathname.split('/').filter(Boolean); const idx = parts.indexOf('event'); if (idx>=0 && parts[idx+1]) return parts[idx+1]; } catch {}
        return localStorage.getItem('activeEventSession');
      };
      const eid = getEventId();
      const toAdmin = document.getElementById('faa-switch-admin');
      if (toAdmin) toAdmin.onclick = () => { const url = eid ? `/event/${eid}/raidlogs_admin` : '/raidlogs_admin'; window.location.href = url; };
      const uploadBtn = document.getElementById('faa-upload-logs');
      if (uploadBtn) uploadBtn.onclick = () => { const tgt = eid ? `/event/${eid}/logs` : '/logs'; window.location.href = tgt; };

      // Publish/unpublish/refresh/revert buttons are hidden on viewer page (only "Go to Admin view" is shown)
      // Kept for reference but functionality disabled
      const publishBtn = document.getElementById('faa-publish');
      const refreshBtn = document.getElementById('faa-refresh');
      const revertBtn = document.getElementById('faa-revert');
      const updatePublishUi = (pub)=>{
        // Disabled on viewer page - buttons are hidden
        return;
      };
      // Removed button state checks and event handlers for viewer page
      // All buttons except "Go to Admin view" are hidden via display:none
      // No functionality needed for hidden buttons
    } catch {}
    const style = document.createElement('style');
    style.textContent = `
      body.raidlogs-view .rankings-container { display:flex; gap: 0px 30px; row-gap: 0px; column-gap: 30px; justify-content:center; flex-wrap:wrap; }
      body.raidlogs-view .rankings-container .rankings-section { flex: 1 1 420px; }
      /* Viewer-specific icon sizing for all panels */
      body.raidlogs-view .rankings-section .spec-icon { width: 43px !important; height: 43px !important; }
      /* Ensure header is positioned for overlay icon and has padding for the icon */
      body.raidlogs-view .rankings-section .section-header { position: relative; padding-right: 32px; }
      /* Panel info icon (top-right) */
      body.raidlogs-view .rankings-section .section-header .panel-info-icon { position: absolute; top: 10px; right: 12px; width: 18px; height: 18px; border-radius: 50%; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.25); color: #fff; font-size: 12px; line-height: 18px; text-align: center; cursor: help; transition: all .2s ease; z-index: 3; }
      body.raidlogs-view .rankings-section .section-header .panel-info-icon:hover { background: rgba(0,0,0,0.5); transform: translateY(-1px); }
      /* Panel dark overlay */
      body.raidlogs-view .rankings-section .panel-info-overlay { position: absolute; inset: 0; background: rgba(11, 18, 32, 0.95); color: #f8fafc; display: flex; align-items: flex-start; justify-content: center; opacity: 0; pointer-events: none; transition: opacity .35s ease; z-index: 50; padding: 20px; overflow: auto; }
      body.raidlogs-view .rankings-section .panel-info-overlay.show { opacity: 1; pointer-events: auto; }
      body.raidlogs-view .rankings-section .panel-info-overlay .panel-info-close-x { display: none; position: absolute; top: 10px; right: 12px; color: #f8fafc; font-size: 16px; cursor: pointer; z-index: 60; opacity: .85; background: transparent; border: none; }
      body.raidlogs-view .rankings-section .panel-info-overlay.locked .panel-info-close-x { display: block; }
      body.raidlogs-view .rankings-section .panel-info-overlay .panel-info-close-x:hover { opacity: 1; }
      body.raidlogs-view .rankings-section .panel-info-overlay-content { max-width: 720px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 18px 20px; box-shadow: 0 10px 28px rgba(0,0,0,0.45); }
      /* God Gamer row spans full width with two equal panels */
      .god-gamer-row { display:flex; gap:30px; width: 100%; }
      .god-gamer-row .rankings-section { flex: 0 0 calc((100% - 30px) / 2); }
      /* Triple row spans full width with three equal panels */
      .triple-row { display:flex; gap:30px; width: 100%; }
      .triple-row .rankings-section { flex: 0 0 calc((100% - 60px) / 3); }
    `;
    document.head.appendChild(style);
  })();
  (function(){
    function slugToTitle(slug){
      if (String(slug) === 'windfury_totems') return 'Totems';
      return slug.replace(/_/g,' ').replace(/\b\w/g, c=>c.toUpperCase());
    }

    function getIconForPanel(key){
      // Returns icon HTML (FontAwesome icon or WoW image) for each panel type
      // Matches the icons from raidlogs.html (admin page)
      const iconStyle = 'width: 24px; height: 24px;';
      switch(String(key||'')){
        case 'god_gamer_dps': return '<i class="fas fa-crown"></i> ';
        case 'god_gamer_healer': return '<i class="fas fa-crown"></i> ';
        case 'damage': return `<img src="https://wow.zamimg.com/images/wow/icons/medium/ability_marksmanship.jpg" alt="Damage" style="${iconStyle}"> `;
        case 'healing': return `<img src="https://wow.zamimg.com/images/wow/icons/medium/spell_holy_holybolt.jpg" alt="Healing" style="${iconStyle}"> `;
        case 'shaman_healers': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_nature_healingwavegreater.jpg" alt="Shaman Healers" style="${iconStyle}"> `;
        case 'priest_healers': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_holy_renew.jpg" alt="Priest Healers" style="${iconStyle}"> `;
        case 'druid_healers': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_nature_resistnature.jpg" alt="Druid Healers" style="${iconStyle}"> `;
        case 'too_low_damage': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_sword_04.jpg" alt="Too Low Damage" style="${iconStyle}"> `;
        case 'too_low_healing': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_potion_49.jpg" alt="Too Low Healing" style="${iconStyle}"> `;
        case 'frost_resistance': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_frost_frostarmor.jpg" alt="Frost Resistance" style="${iconStyle}"> `;
        case 'world_buffs_copy': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_arcane_teleportorgrimmar.jpg" alt="World Buffs" style="${iconStyle}"> `;
        case 'attendance_streaks': return `<img src="https://wow.zamimg.com/images/wow/icons/large/ability_hunter_beastcall.jpg" alt="Attendance Streaks" style="${iconStyle}"> `;
        case 'guild_members': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_shirt_guildtabard_01.jpg" alt="Guild Members" style="${iconStyle}"> `;
        case 'abilities': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_misc_bomb_06.jpg" alt="Explosives" style="${iconStyle}"> `;
        case 'mana_potions': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_potion_76.jpg" alt="Major Mana Potion" style="${iconStyle}"> `;
        case 'runes': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_shadow_sealofkings.jpg" alt="Dark/Demonic Runes" style="${iconStyle}"> `;
        case 'interrupts': return `<img src="https://wow.zamimg.com/images/wow/icons/large/ability_kick.jpg" alt="Interrupted spells" style="${iconStyle}"> `;
        case 'disarms': return `<img src="https://wow.zamimg.com/images/wow/icons/large/ability_warrior_disarm.jpg" alt="Disarmed enemies" style="${iconStyle}"> `;
        case 'windfury_totems': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_nature_windfury.jpg" alt="Totems" style="${iconStyle}"> `;
        case 'sunder': return `<img src="https://wow.zamimg.com/images/wow/icons/large/ability_warrior_sunder.jpg" alt="Sunder Armor" style="${iconStyle}"> `;
        case 'rocket_helmet': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_helmet_49.jpg" alt="Goblin Rocket Helmet" style="${iconStyle}"> `;
        case 'curse_recklessness': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_shadow_unholystrength.jpg" alt="Curse of Recklessness" style="${iconStyle}"> `;
        case 'curse_shadow': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_shadow_curseofachimonde.jpg" alt="Curse of Shadow" style="${iconStyle}"> `;
        case 'curse_elements': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_shadow_chilltouch.jpg" alt="Curse of the Elements" style="${iconStyle}"> `;
        case 'faerie_fire': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_nature_faeriefire.jpg" alt="Faerie Fire" style="${iconStyle}"> `;
        case 'scorch': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_fire_soulburn.jpg" alt="Scorch" style="${iconStyle}"> `;
        case 'demo_shout': return `<img src="https://wow.zamimg.com/images/wow/icons/large/ability_warrior_warcry.jpg" alt="Demoralizing Shout" style="${iconStyle}"> `;
        case 'polymorph': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_nature_polymorph.jpg" alt="Polymorph" style="${iconStyle}"> `;
        case 'power_infusion': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_holy_powerinfusion.jpg" alt="Power Infusion" style="${iconStyle}"> `;
        case 'decurses': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_nature_removecurse.jpg" alt="Remove Lesser Curse" style="${iconStyle}"> `;
        case 'void_damage': return `<img src="https://wow.zamimg.com/images/wow/icons/large/spell_shadow_shadowwordpain.jpg" alt="Void Damage" style="${iconStyle}"> `;
        case 'big_buyer': return `<img src="https://wow.zamimg.com/images/wow/icons/large/inv_misc_bag_10.jpg" alt="Big Buyer" style="${iconStyle}"> `;
        default: return '';
      }
    }

    function panelClassForKey(key){
      switch(String(key||'')){
        case 'damage': return 'damage';
        case 'healing': return 'healing';
        case 'god_gamer_dps': return 'god-gamer-dps-section';
        case 'god_gamer_healer': return 'god-gamer-healer-section';
        case 'abilities': return 'abilities-section';
        case 'mana_potions': return 'mana-potions-section';
        case 'runes': return 'runes-section';
        case 'windfury_totems': return 'windfury-section';
        case 'interrupts': return 'interrupts-section';
        case 'disarms': return 'disarms-section';
        case 'sunder': return 'sunder-section';
        case 'curse_recklessness': return 'curse-section curse-recklessness-section';
        case 'curse_shadow': return 'curse-section curse-shadow-section';
        case 'curse_elements': return 'curse-section curse-elements-section';
        case 'faerie_fire': return 'curse-section faerie-fire-section';
        case 'scorch': return 'scorch-section';
        case 'demo_shout': return 'demo-shout-section';
        case 'polymorph': return 'polymorph-section';
        case 'power_infusion': return 'power-infusion-section';
        case 'decurses': return 'decurses-section';
        case 'void_damage': return 'void-damage-section';
        case 'frost_resistance': return 'frost-resistance-section';
        case 'world_buffs_copy': return 'world-buffs-section';
        case 'too_low_damage': return 'too-low-damage-section';
        case 'too_low_healing': return 'too-low-healing-section';
        case 'attendance_streaks': return 'streak-section';
        case 'guild_members': return 'guild-section';
        case 'big_buyer': return 'big-buyer-section';
        default: return '';
      }
    }

    function lower(s){ return String(s||'').trim().toLowerCase(); }

    function getCanonicalClass(className){
      const c = lower(className);
      if (c.includes('warrior')) return 'warrior';
      if (c.includes('paladin')) return 'paladin';
      if (c.includes('hunter')) return 'hunter';
      if (c.includes('rogue')) return 'rogue';
      if (c.includes('priest')) return 'priest';
      if (c.includes('shaman')) return 'shaman';
      if (c.includes('mage')) return 'mage';
      if (c.includes('warlock')) return 'warlock';
      if (c.includes('druid')) return 'druid';
      return '';
    }

    function classIconUrl(cls){
      const k = String(cls||'').toLowerCase();
      const map = {
        'warrior':'classicon_warrior','paladin':'classicon_paladin','hunter':'classicon_hunter',
        'rogue':'classicon_rogue','priest':'classicon_priest','shaman':'classicon_shaman',
        'mage':'classicon_mage','warlock':'classicon_warlock','druid':'classicon_druid'
      };
      const key = map[k] || null;
      return key ? `https://wow.zamimg.com/images/wow/icons/medium/${key}.jpg` : null;
    }

    function detectTotemKey(row){
      try {
        const k = row && row.aux_json && (row.aux_json.item_key || row.aux_json['item_key']);
        if (k) {
          const normalized = String(k).toLowerCase();
          // Normalize backend's full names to short form
          if (normalized.includes('grace')) return 'grace';
          if (normalized.includes('strength')) return 'strength';
          if (normalized.includes('tranquil')) return 'tranquil';
          return normalized; // 'windfury' or fallback
        }
        const d = String((row.character_details_edited ?? row.character_details ?? row.character_details_original) || '').toLowerCase();
        if (d.includes('grace')) return 'grace';
        if (d.includes('strength')) return 'strength';
        if (d.includes('tranquil') || d.includes('brilliance')) return 'tranquil';
      } catch {}
      return 'windfury';
    }

    function emptyStateHtml(msg){
      return `<div class="rankings-empty"><p>${msg || 'No one qualify'}</p></div>`;
    }

    function isValidWoWName(name){
      try {
        const s = String(name||'');
        if (/\d/.test(s)) return false;
        if (/\s/.test(s)) return false;
        return true;
      } catch { return false; }
    }

    // Hide explicit non-player entities in the public viewer
    // This MUST match the backend shouldIgnorePlayer function exactly
    function shouldIgnoreViewerName(name){
      try {
        const n = String(name || '').trim();
        // Filter out names with spaces (e.g., "Windfury Totem", "Battle Chicken")
        // but allow names ending with (tank grp)
        if (n.includes(' ') && !n.endsWith('(tank grp)')) return true;
        // Exact match filter (case-insensitive)
        const lower = n.toLowerCase();
        const exactMatches = ['zzold', 'totem', 'trap', 'dummy', 'battlechicken'];
        return exactMatches.includes(lower);
      } catch { return false; }
    }

    function normalizeSnapshotName(name){
      try {
        const raw = String(name||'').trim();
        // Remove (tank grp) label if present
        let s = raw.replace(/\s*\(tank grp\)\s*$/i, '');
        s = s.replace(/^[\s•\u2022\u00B7\-–—]+/, '');
        s = s.replace(/\s*\((?:tank\s*)?group\s*\d*\)\s*$/i, '');
        return s.trim();
      } catch { return String(name||'').trim(); }
    }

    function applyFillPercentages(){
      try {
        const sections = document.querySelectorAll('.rankings-section');
        sections.forEach(section => {
          const items = Array.from(section.querySelectorAll('.ranking-item'));
          if (!items.length) return;
          const values = items.map(item => {
            try {
              const details = String(item.querySelector('.character-details')?.textContent || '').replace(/[,\s]/g,'');
              const matches = details.match(/-?\d+/g);
              if (!matches || !matches.length) return 0;
              const val = parseInt(matches[matches.length-1], 10);
              return isNaN(val) ? 0 : val;
            } catch { return 0; }
          });
          const max = Math.max(1, ...values);
          items.forEach((item, idx) => {
            const v = values[idx] || 0;
            const pct = Math.max(5, Math.round(v / max * 100));
            const info = item.querySelector('.character-info');
            if (info) info.style.setProperty('--fill-percentage', pct + '%');
          });
        });
      } catch {}
    }

    function renderTotemsSection(section, rows){
      const groups = { windfury: [], grace: [], strength: [], tranquil: [] };
      (rows||[]).forEach(r=>{
        // Normalize name so grouped variants still render
        r.character_name = normalizeSnapshotName(r.character_name);
        const g=detectTotemKey(r);
        (groups[g]||(groups[g]=[])).push(r);
      });
      const headerHtml = (title, iconUrl, typeKey) => `
        <div class="totem-subheader">
          <div class="left"><img src="${iconUrl}" alt="${title}" width="20" height="20"> <span>${title}</span></div>
          <div class="right"><span class="totem-info-icon" data-info-key="${typeKey}" aria-label="Info" role="button" tabindex="0">?</span></div>
        </div>`;
      const iconForType = (k)=>{
        switch(k){
          case 'grace': return 'https://wow.zamimg.com/images/wow/icons/large/spell_nature_invisibilitytotem.jpg';
          case 'strength': return 'https://wow.zamimg.com/images/wow/icons/large/spell_nature_earthbindtotem.jpg';
          case 'tranquil': return 'https://wow.zamimg.com/images/wow/icons/large/spell_nature_brilliance.jpg';
          default: return 'https://wow.zamimg.com/images/wow/icons/large/spell_nature_windfury.jpg';
        }
      };
      const titleForType = (k)=>{
        switch(k){
          case 'grace': return 'Grace of Air Totem';
          case 'strength': return 'Strength of Earth Totem';
          case 'tranquil': return 'Tranquil Air Totem';
          default: return 'Windfury Totem';
        }
      };
      const buildRow = (row, index, pct, totemType)=>{
        const clsName = String(row.character_class||'').toLowerCase();
        const details = (row.character_details_edited ?? row.character_details ?? row.character_details_original) || '';
        const rawPts = (row.point_value_edited ?? row.points ?? row.point_value_original) || 0;
        const points = Math.round(Number(rawPts||0));
        const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
        // Use totem icon instead of class icon
        const icon = iconForType(totemType);
        const nmKey = String(row.character_name||'').toLowerCase();
        let partyId = null; try { if (nameToPartyMap && typeof nameToPartyMap.get === 'function') partyId = nameToPartyMap.get(nmKey); } catch {}
        const isTankGrp = (partyId === 1 || String(partyId) === '1');
        const grpLabel = isTankGrp ? ' <span class="group-label" style="color:#9aa0a6; font-weight:500; font-size:0.85em;">(tank grp)</span>' : '';
        console.log('[VIEWER DEBUG] Totem row:', row.character_name, '| nmKey:', nmKey, '| partyId:', partyId, '| isTankGrp:', isTankGrp);
        return `
          <div class="ranking-item" data-item-key="${totemType}">
            <div class="ranking-number">#${index+1}</div>
            <div class="character-info ${clsName?('class-'+clsName):'class-unknown'}" style="--fill-percentage: ${pct || 100}%;">
              ${icon?`<img src="${icon}" class="spec-icon" alt="${totemType}" width="47" height="47">`:''}
              <div class="character-name ${clsName?('class-'+clsName):''}">${row.character_name||''}${grpLabel}</div>
              <div class="character-details">${details}</div>
            </div>
            <div class="performance-amount"><span class="amount-value ${amtClass}">${points}</span></div>
          </div>`;
      };
      const container = document.createElement('div');
      container.className = 'rankings-list';
      const order = ['windfury','grace','strength','tranquil'];
      let renderedCount = 0;
      order.forEach(key=>{
        const arr = groups[key]||[];
        if (!arr.length) return;
        container.insertAdjacentHTML('beforeend', headerHtml(titleForType(key), iconForType(key), key));
        
        // Extract metric value (extra attacks for Windfury, totem count for others) for sorting
        const extractMetric = (r) => {
          try{
            const details = String((r.character_details_edited ?? r.character_details ?? r.character_details_original) || '');
            // Extract last numeric token (supports decimals)
            const m = details.match(/(-?\d+(?:\.\d+)?)(?!.*-?\d)/);
            if (m) return parseFloat(m[1]) || 0;
          }catch{}
          return Number(r.points||0) || 0;
        };
        
        // Sort by actual metric value (highest first), then by name
        const sorted = arr.slice().sort((a,b)=>{
          const aVal = extractMetric(a);
          const bVal = extractMetric(b);
          if (bVal !== aVal) return bVal - aVal;
          return String(a.character_name||'').localeCompare(String(b.character_name||''));
        });
        
        // Compute relative fill percentages by the same metric
        const values = sorted.map(r => extractMetric(r));
        const max = Math.max(1, ...values);
        sorted.forEach((row, idx)=>{
          const v = values[idx] || 0;
          const pct = Math.max(5, Math.min(100, Math.round((v / max) * 100)));
          container.insertAdjacentHTML('beforeend', buildRow(row, idx, pct, key)); renderedCount++; 
        });
      });
      if (renderedCount === 0) {
        container.innerHTML = emptyStateHtml();
      }
      section.appendChild(container);
    }

    function ensureTotemInfoTooltipSetup() {
      if (window._totemInfoSetup) return;
      window._totemInfoSetup = true;
      const tip = document.createElement('div');
      tip.id = 'totem-info-tooltip';
      tip.className = 'totem-info-tooltip';
      tip.style.display = 'none';
      document.body.appendChild(tip);

      const getText = (key) => {
        const k = String(key||'').toLowerCase();
        if (k === 'windfury') {
          return (
`Windfury Totem – how to earn points\n\n` +
`We compare how many "extra Windfury attacks" your party gets on average to the overall baseline for the raid.\n` +
`Your points depend on how your party's average stacks up against that baseline:\n` +
`- Less than 75% of the baseline: 0 points\n` +
`- 75% to 99% of the baseline: 10 points\n` +
`- 100% to 125% of the baseline: 15 points\n` +
`- Above 125% of the baseline: 20 points\n\n` +
`In plain terms: keep Windfury up where your party can use it and make sure your melee are close enough to benefit. The better your party's extra attacks compared to everyone else, the more points you earn.`
          );
        }
        if (k === 'grace') {
          return (
`Grace of Air Totem – how to earn points\n\n` +
`First, you must meet BOTH conditions:\n` +
`- Use at least 10 Grace of Air totems in the raid.\n` +
`- Your party's average extra Windfury attacks is at least 75% of the Windfury baseline (same baseline used above).\n\n` +
`If you meet those two, you earn points based on how many Grace of Air totems you placed:\n` +
`- Every 10 totems = 1 point\n` +
`- Capped at 20 points (so 200+ totems = 20 points)\n\n` +
`In plain terms: make sure your Windfury performance is solid (at least the 75% minimum), then drop lots of Grace of Air to climb the point ladder.`
          );
        }
        if (k === 'strength') {
          return (
`Strength of Earth Totem – how to earn points\n\n` +
`First, you must meet BOTH conditions:\n` +
`- Use at least 10 Strength of Earth totems in the raid.\n` +
`- Your party's average extra Windfury attacks is at least 75% of the Windfury baseline (same baseline used above).\n\n` +
`If you meet those two, you earn points based on how many Strength of Earth totems you placed:\n` +
`- Every 10 totems = 1 point\n` +
`- Capped at 10 points (so 100+ totems = 10 points)\n\n` +
`In plain terms: qualify via Windfury baseline, then drop Strength of Earth consistently to rack up points.`
          );
        }
        if (k === 'tranquil') {
          return (
`Tranquil Air Totem – how to earn points\n\n` +
`Points here are purely about how many Tranquil Air totems you use.\n` +
`- Every 10 totems = 1 point, up to a maximum of 5 points (so 50+ totems = 5 points).\n` +
`- No Windfury performance check applies to Tranquil Air.`
          );
        }
        return '';
      };

      let active = null;
      const show = (el, e) => {
        const key = el.getAttribute('data-info-key');
        tip.innerHTML = `<pre>${getText(key)}</pre>`;
        tip.style.display = 'block';
        move(e);
      };
      const hide = () => { tip.style.display = 'none'; };
      const move = (e) => {
        const x = (e.pageX || (e.clientX + window.scrollX)) + 14;
        const y = (e.pageY || (e.clientY + window.scrollY)) + 14;
        tip.style.left = x + 'px';
        tip.style.top = y + 'px';
      };

      document.addEventListener('mouseover', (e) => {
        const t = e.target.closest('.totem-info-icon');
        if (!t) return;
        active = t;
        show(t, e);
      });
      document.addEventListener('mousemove', (e) => { if (active) move(e); });
      document.addEventListener('mouseout', (e) => {
        if (e.target.closest('.totem-info-icon') !== active) return;
        active = null;
        hide();
      });
      document.addEventListener('focusin', (e) => {
        const t = e.target.closest('.totem-info-icon');
        if (!t) return;
        active = t;
        const rect = t.getBoundingClientRect();
        show(t, { pageX: rect.right + window.scrollX, pageY: rect.bottom + window.scrollY });
      });
      document.addEventListener('focusout', (e) => {
        if (!active) return;
        const related = e.relatedTarget && e.relatedTarget.closest && e.relatedTarget.closest('.totem-info-icon');
        if (related === active) return;
        active = null;
        hide();
      });
    }

    function getEventId(){
      try{
        const parts = window.location.pathname.split('/').filter(Boolean);
        const idx = parts.indexOf('event');
        if (idx>=0 && parts[idx+1]) return parts[idx+1];
      }catch{}
      return localStorage.getItem('activeEventSession');
    }

    function classIconUrl(cls){
      const k = String(cls||'').toLowerCase();
      const map = {
        'warrior':'classicon_warrior','paladin':'classicon_paladin','hunter':'classicon_hunter',
        'rogue':'classicon_rogue','priest':'classicon_priest','shaman':'classicon_shaman',
        'mage':'classicon_mage','warlock':'classicon_warlock','druid':'classicon_druid'
      };
      const key = map[k] || null;
      return key ? `https://wow.zamimg.com/images/wow/icons/medium/${key}.jpg` : null;
    }

    // Global map populated from published entries: name(lower) -> canonical class
    let nameToClassMap = new Map();

    function renderManualRewards(manualEntries){
      try{
        const section = document.getElementById('manual-rewards-section');
        const rewardsEl = document.getElementById('manual-rewards-list-rewards');
        const dedsEl = document.getElementById('manual-rewards-list-deductions');
        const noneEl = document.getElementById('manual-no-entries');
        if (!section || !rewardsEl || !dedsEl) return;
        const items = (Array.isArray(manualEntries) ? manualEntries : [])
          .map(e => { e.character_name = normalizeSnapshotName(e.character_name); return e; })
          .filter(e=> {
              // For published snapshots, trust the admin's curation - only filter out obvious non-players
              if (!e.character_name || !String(e.character_name).trim()) return false;
              return !shouldIgnoreViewerName(e.character_name);
          });
        if (items.length === 0){
          section.style.display='block';
          rewardsEl.innerHTML='';
          dedsEl.innerHTML='';
          if (noneEl) noneEl.style.display='block';
          return;
        }
        if (noneEl) noneEl.style.display='none';
        // Split rewards/deductions (enrich class from nameToClassMap when missing)
        const positives = [];
        const negatives = [];
        items.forEach(e=>{
          const pts = Math.round(Number(e.points||0));
          const isGold = !!(e.aux_json && (e.aux_json.is_gold===true || e.aux_json.is_gold==='true'));
          const nm = e.character_name || '';
          const clsResolved = (e.character_class||'') ? getCanonicalClass(e.character_class) : (nameToClassMap.get(lower(nm)) || '');
          const row = {
            name: nm,
            cls: clsResolved,
            details: e.character_details || '',
            pts,
            isGold
          };
          if (pts < 0) negatives.push(row); else positives.push(row);
        });
        const itemHtml = (row, index)=>{
          const amtClass = row.pts>0 ? 'positive' : row.pts<0 ? 'negative' : 'zero';
          const goldClass = row.isGold ? ' gold-amount' : '';
          const icon = classIconUrl(row.cls);
          return `
            <div class="ranking-item">
              <div class="ranking-position">#${index+1}</div>
              <div class="character-info ${row.cls?('class-'+row.cls):'class-unknown'}">
                ${icon?`<img src="${icon}" class="spec-icon" alt="${row.cls}" width="47" height="47">`:''}
                <div class="character-name ${row.cls?('class-'+row.cls):''}">${row.name}</div>
                <div class="character-details">${row.details||''}</div>
              </div>
              <div class="performance-amount"><span class="amount-value ${amtClass}${goldClass}">${row.pts>0?('+'+row.pts):row.pts}</span></div>
            </div>`;
        };
        rewardsEl.innerHTML = positives.map((r,i)=>itemHtml(r,i)).join('');
        dedsEl.innerHTML = negatives.map((r,i)=>itemHtml(r,i)).join('');
        section.style.display='block';
      }catch(e){ console.warn('[VIEWER] renderManualRewards failed', e); }
    }

    // Helper: apply background fill percentages per section
    function applyFillPercentages(){
      try {
        const sections = document.querySelectorAll('.rankings-section');
        sections.forEach(section => {
          const items = Array.from(section.querySelectorAll('.ranking-item'));
          if (!items.length) return;
          const cls = section.className;
          const has = (k)=> cls.includes(k);
          // Explicit mapping for World Buffs: fixed discrete steps
          if (has('world-buffs-section')) {
            const worldBuffsPercent = (n)=>{
              const v = Math.max(0, Math.floor(Number(n)||0));
              if (v >= 6) return 100;
              if (v === 5) return 90;
              if (v === 4) return 70;
              if (v === 3) return 50;
              if (v === 2) return 30;
              if (v === 1) return 10;
              return 0;
            };
            // Sort by buff count desc and set fill explicitly
            try {
              const list = section.querySelector('.rankings-list');
              const tuples = items.map(el => {
                const txt = String(el.querySelector('.character-details')?.textContent||'');
                const m = txt.match(/(\d+)/);
                const v = m ? Number(m[1])||0 : 0;
                return { el, v };
              });
              tuples.sort((a,b)=> b.v - a.v);
              tuples.forEach((t, i)=>{
                list.appendChild(t.el);
                const num = t.el.querySelector('.ranking-number'); if (num) num.textContent = `#${i+1}`;
                const pct = worldBuffsPercent(t.v);
                const info = t.el.querySelector('.character-info');
                if (info) info.style.setProperty('--fill-percentage', `${pct}%`);
              });
            } catch {}
            return; // Skip generic handling
          }
          let extractor = null;
          let cap100 = false;
          let fixedMax = null;
          let forceAll100 = false;
          let sortDesc = false;
          let mappingName = null;
          if (has('damage')) extractor = (item)=> extractLastInt(item);
          else if (has('healing')) extractor = (item)=> extractLastInt(item);
          else if (has('too-low-damage-section')) extractor = (item)=> extractLastInt(item);
          else if (has('too-low-healing-section')) extractor = (item)=> extractLastInt(item);
          else if (has('guild-section')) forceAll100 = true;
          else if (has('abilities-section')) { extractor = (item)=> extractPoints(item); mappingName = 'abilities'; sortDesc = true; }
          else if (has('streak-section')) { extractor = (item)=> extractLastInt(item); fixedMax = 15; sortDesc = true; }
          else if (has('interrupts-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('curse-recklessness-section') || has('curse-elements-section') || has('curse-shadow-section') || has('faerie-fire-section')) { extractor = (item)=> extractPercent(item); cap100 = true; sortDesc = true; }
          else if (has('mana-potions-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('decurses-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('demo-shout-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('runes-section')) return; // Runes section handles its own sorting and fill in the initial render
          else if (has('rocket-helmet-section')) forceAll100 = true;
          else if (has('sunder-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('disarms-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('big-buyer-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('frost-resistance-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('power-infusion-section')) { extractor = (item)=> extractLastInt(item); sortDesc = true; }
          else if (has('world-buffs-section')) { extractor = (item)=> extractLastInt(item); mappingName = 'worldBuffs'; sortDesc = true; }
          else if (has('windfury-section')) extractor = null;
          if (forceAll100) { items.forEach(item => { const info=item.querySelector('.character-info'); if (info) info.style.setProperty('--fill-percentage','100%'); }); return; }
          if (!extractor) return;
          const values = items.map(item => { try { return extractor(item); } catch { return 0; } });
          const worldBuffsPercent = (n)=>{
            const v = Math.max(0, Math.floor(Number(n)||0));
            if (v >= 6) return 100;
            if (v === 5) return 90;
            if (v === 4) return 70;
            if (v === 3) return 50;
            if (v === 2) return 30;
            if (v === 1) return 10;
            return 0;
          };
          const abilitiesPercent = (pts)=>{
            const p = Math.max(0, Math.floor(Number(pts)||0));
            if (p >= 15) return 100;
            if (p === 14) return 95;
            if (p === 13) return 90;
            if (p === 12) return 85;
            if (p === 11) return 80;
            if (p === 10) return 75;
            if (p === 9) return 70;
            if (p === 8) return 65;
            if (p === 7) return 60;
            if (p === 6) return 55;
            if (p === 5) return 50;
            if (p === 4) return 45;
            if (p === 3) return 40;
            if (p === 2) return 35;
            if (p === 1) return 30;
            return 0;
          };
          let max = fixedMax != null ? fixedMax : Math.max(1, ...values);
          if (sortDesc) {
            try {
              const list = section.querySelector('.rankings-list');
              const tuples = items.map((el, i)=>({ el, v: values[i]||0 }));
              tuples.sort((a,b)=> (b.v - a.v));
              tuples.forEach((t, i)=>{
                list.appendChild(t.el);
                const num = t.el.querySelector('.ranking-number'); if (num) num.textContent = `#${i+1}`;
                let pct = 0;
                if (mappingName === 'worldBuffs') pct = worldBuffsPercent(t.v);
                else if (mappingName === 'abilities') pct = abilitiesPercent(t.v);
                else if (cap100) pct = Math.min(100, Math.round(t.v));
                else pct = Math.round((t.v / max) * 100);
                pct = Math.max(5, Math.min(100, pct));
                const info = t.el.querySelector('.character-info');
                if (info) info.style.setProperty('--fill-percentage', pct + '%');
              });
              return;
            } catch {}
          }
          items.forEach((item, idx) => {
            const v = values[idx] || 0;
            let pct = 0;
            if (mappingName === 'worldBuffs') pct = worldBuffsPercent(v);
            else if (mappingName === 'abilities') pct = abilitiesPercent(v);
            else if (cap100) pct = Math.min(100, Math.round(v));
            else pct = Math.round((v / max) * 100);
            pct = Math.max(5, Math.min(100, pct));
            const info = item.querySelector('.character-info');
            if (info) info.style.setProperty('--fill-percentage', pct + '%');
          });
        });
      } catch {}
    }

    function extractLastInt(item){
      const details = String(item.querySelector('.character-details')?.textContent || '');
      // Remove percent tokens to avoid picking them for non-% panels
      const cleaned = details.replace(/\d+(?:\.\d+)?\s*%/g, ' ');
      // Find last number with optional K/M/B suffix
      const re = /(-?\d[\d,]*(?:\.\d+)?)(?:\s*([kmbKMB]))?/g;
      let match, lastNum = null, lastSuf = null;
      while ((match = re.exec(cleaned)) !== null) {
        lastNum = match[1];
        lastSuf = match[2] || null;
      }
      if (!lastNum) return 0;
      const base = parseFloat(String(lastNum).replace(/[,]/g, ''));
      if (isNaN(base)) return 0;
      let mul = 1;
      if (lastSuf) {
        const s = lastSuf.toLowerCase();
        if (s === 'k') mul = 1e3; else if (s === 'm') mul = 1e6; else if (s === 'b') mul = 1e9;
      }
      return base * mul;
    }

    function extractPercent(item){
      const details = String(item.querySelector('.character-details')?.textContent || '');
      const m = details.match(/(\d+(?:\.\d+)?)%/);
      if (!m) return 0;
      const val = parseFloat(m[1]);
      return isNaN(val) ? 0 : val;
    }
    function extractPoints(item){
      // points are displayed in the right column; read the numeric value
      try {
        const txt = String(item.querySelector('.performance-amount .amount-value')?.textContent||'');
        const m = txt.match(/-?\d+/);
        if (!m) return 0;
        return Math.abs(parseInt(m[0],10))||0;
      } catch { return 0; }
    }

    async function load(){
      const eventId = getEventId();
      if (!eventId){
        document.getElementById('loading').style.display='none';
        document.getElementById('view-subtitle').textContent = 'No event selected';
        return;
      }
      try { localStorage.setItem('activeEventSession', eventId); } catch {}
      // Update raid bar links via top-bar.js if available
      try { if (typeof updateRaidBar === 'function') setTimeout(()=>updateRaidBar(), 0); } catch {}
      
      // First, try to fetch raid stats (available as soon as logs are uploaded, even if not published)
      let statsAvailable = false;
      try {
        const statsRes = await fetch(`/api/raid-stats/${eventId}`);
        if (statsRes.ok) {
          const statsData = await statsRes.json();
          if (statsData.success && statsData.data && statsData.data.stats) {
            const stats = statsData.data.stats;
            const rpb = statsData.data.rpb;
            console.log('[VIEWER] Stats data available:', stats);
            
            // Show stats dashboard immediately if we have data
            if (stats.totalTime || stats.bossesKilled || stats.lastBoss || stats.logUrl || rpb) {
              statsAvailable = true;
              document.getElementById('stats-dashboard').style.display = 'block';
              
              // Populate stat cards
              if (stats.totalTime) {
                const hours = Math.floor(stats.totalTime / 60);
                const minutes = stats.totalTime % 60;
                document.getElementById('raid-duration-value').textContent = hours > 0 ? `${hours}h ${minutes}m` : `${stats.totalTime}m`;
              }
              if (stats.bossesKilled) {
                document.getElementById('bosses-killed-value').textContent = stats.bossesKilled;
              }
              if (stats.lastBoss) {
                document.getElementById('last-boss-value').textContent = stats.lastBoss;
                document.getElementById('last-boss-detail').textContent = 'Final boss defeated';
              }
              if (stats.logUrl) {
                const btn = document.getElementById('wow-logs-button');
                btn.disabled = false;
                btn.onclick = () => window.open(stats.logUrl, '_blank');
                document.getElementById('wow-logs-detail').textContent = 'View detailed logs';
              }
              if (rpb && rpb.archiveUrl) {
                const btn = document.getElementById('rpb-archive-button');
                btn.disabled = false;
                btn.onclick = () => window.open(rpb.archiveUrl, '_blank');
                document.getElementById('rpb-archive-detail').textContent = 'Archive available';
              }
            }
          }
        }
      } catch (statsError) {
        console.warn('[VIEWER] Could not fetch stats:', statsError);
      }
      
      // Now fetch published data for the rest of the content
      const res = await fetch(`/api/raidlogs/published/${eventId}`);
      const data = await res.json();
      console.log('[VIEWER] Published fetch', data);
      document.getElementById('loading').style.display='none';
      let header = data && data.header ? data.header : null;
      let entries = Array.isArray(data && data.entries) ? data.entries : [];
      // Publish/unpublish button functionality removed from viewer page (buttons are hidden)
      // Build name -> class map from published entries
      try {
        const votes = new Map(); // name -> Map(class->count)
        (entries||[]).forEach(r=>{
          const nm = lower(r.character_name||'');
          const cls = getCanonicalClass(r.character_class||'');
          if (!nm || !cls) return;
          const m = votes.get(nm) || new Map();
          m.set(cls, (m.get(cls)||0)+1);
          votes.set(nm, m);
        });
        nameToClassMap = new Map();
        votes.forEach((m, nm)=>{
          let bestCls = '', bestCnt = -1;
          m.forEach((cnt, cls)=>{ if (cnt>bestCnt) { bestCnt = cnt; bestCls = cls; } });
          if (bestCls) nameToClassMap.set(nm, bestCls);
        });
      } catch {}
      
      // Handle display based on what data is available
      if (!header){
        // No published data yet - show message and only stats if available
        if (statsAvailable) {
          const pageHeader = document.querySelector('.page-header');
          if (pageHeader) pageHeader.style.display = 'block';
          document.getElementById('view-subtitle').textContent = 'Stats available - logs not yet published';
          document.getElementById('content').style.display='block'; // Show container for stats
        } else {
          document.getElementById('view-subtitle').textContent = 'No published data yet';
          document.getElementById('content').style.display='none'; // Hide everything
        }
        // Don't render rankings/panels when not published
        return;
      }
      
      // Published data exists - show everything
      const pageHeader = document.querySelector('.page-header');
      if (pageHeader) pageHeader.style.display = 'block';
      // Fetch party mapping used by totems renderer (must await to populate before rendering)
      console.log('[VIEWER DEBUG] About to fetch party map for eventId:', eventId);
      try { 
        await fetchRosterPartyMap(eventId); 
        console.log('[VIEWER DEBUG] Party map fetch complete, map size:', nameToPartyMap.size);
      } catch (err) {
        console.error('[VIEWER DEBUG] Party map fetch error:', err);
      }
      document.getElementById('content').style.display='block';
      document.getElementById('view-subtitle').textContent = 'Published snapshot';

      const h = header;
      // Header cards from published data (will override stats data if present)
      const durMin = Number(h.raid_duration_minutes);
      if (Number.isFinite(durMin) && durMin >= 0){
        const hours = Math.floor(durMin/60);
        const minutes = durMin % 60;
        document.getElementById('raid-duration-value').textContent = hours>0 ? `${hours}h ${minutes}m` : `${durMin}m`;
      }
      const bosses = Number(h.bosses_killed);
      if (Number.isFinite(bosses)){
        document.getElementById('bosses-killed-value').textContent = bosses;
      }
      if (String(h.last_boss||'').length){
        document.getElementById('last-boss-value').textContent = h.last_boss;
        document.getElementById('last-boss-detail').textContent = 'Final boss defeated';
      }
      if (String(h.wow_logs_url||'').length){
        const btn = document.getElementById('wow-logs-button');
        btn.disabled = false;
        btn.onclick = ()=> window.open(h.wow_logs_url, '_blank');
        document.getElementById('wow-logs-detail').textContent = 'View detailed logs';
      }
      if (String(h.rpb_archive_url||'').length){
        const btn = document.getElementById('rpb-archive-button');
        btn.disabled = false;
        btn.onclick = ()=> window.open(h.rpb_archive_url, '_blank');
        document.getElementById('rpb-archive-detail').textContent = 'Archive available';
      }

      // Panels
      const panelsDiv = document.getElementById('panels');
      // Extract manual entries and render at top
      const manual = (entries||[]).filter(r=> String(r.panel_key||'') === 'manual_points');
      renderManualRewards(manual);
      let otherEntries = (entries||[])
          .filter(r=> String(r.panel_key||'') !== 'manual_points')
          .map(r => { r.character_name = normalizeSnapshotName(r.character_name); return r; })
          .filter(r => {
              // For published snapshots, trust the admin's curation - only filter out obvious non-players
              // Don't filter by isValidWoWName as it's too strict (rejects spaces/digits)
              if (!r.character_name || !String(r.character_name).trim()) return false;
              return !shouldIgnoreViewerName(r.character_name);
          });
      // Adjust details text for Guild Members panel: strike-through "Cult Memeber" before "Guild Member"
      otherEntries = otherEntries.map(r=>{
        if (String(r.panel_key||'') === 'guild_members'){
          const base = 'Guild Member';
          const prefix = '<span style="text-decoration: line-through; opacity:.8; margin-right:6px; color: #000;">Cult Memeber</span>';
          const details = (r.character_details_edited ?? r.character_details ?? r.character_details_original) || '';
          const out = `${prefix}${base}`;
          r.character_details_edited = out;
        }
        return r;
      });
      const byPanel = {};
      otherEntries.forEach(r=>{
        const key = String(r.panel_key||'');
        const name = (r.panel_name != null && String(r.panel_name).length) ? r.panel_name : slugToTitle(key);
        (byPanel[key] = byPanel[key] || { name, rows: [] }).rows.push(r);
      });

      // First row: God Gamer DPS and Healer
      const godKeys = ['god_gamer_dps','god_gamer_healer'];
      const godRow = document.createElement('div');
      godRow.className = 'rankings-container god-gamer-row';
      godKeys.forEach((key)=>{
        const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
        const section = document.createElement('div');
        const cls = panelClassForKey(key);
        section.className = 'rankings-section' + (cls? (' '+cls) : '');
        const header = document.createElement('div');
        header.className = 'section-header';
        const h2 = document.createElement('h2');
        h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
        header.appendChild(h2);
        section.appendChild(header);
        const list = document.createElement('div');
        list.className = 'rankings-list';
        const rows = (obj.rows||[]).slice();
          if (!rows.length) {
          list.innerHTML = emptyStateHtml();
        } else {
            const isScorch = (key === 'scorch');
            if (isScorch) {
              const extract = (r)=>{ try{ const d=String((r.character_details_edited ?? r.character_details ?? r.character_details_original) || ''); const m=d.match(/(\d+)(?!.*\d)/); return m?parseInt(m[1],10):0; }catch{return 0;} };
              rows.sort((a,b)=> (extract(b)-extract(a)) || String(a.character_name).localeCompare(String(b.character_name)));
            } else {
              rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            }
          rows.forEach((row, idx)=>{
            const item = document.createElement('div');
            item.className = 'ranking-item';
            const clsName = (row.character_class||'').toString().toLowerCase();
            const details = (row.character_details_edited != null ? row.character_details_edited : (row.character_details != null ? row.character_details : (row.character_details_original != null ? row.character_details_original : '')));
            const rawPts = (row.point_value_edited != null ? row.point_value_edited : (row.points != null ? row.points : (row.point_value_original != null ? row.point_value_original : 0)));
            const points = Math.round(Number(rawPts||0));
            const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
            const iconUrlPub = row.aux_json && (row.aux_json.icon_url || row.aux_json['icon_url']);
            const icon = iconUrlPub || classIconUrl(clsName);
            // God Gamers always show at 100% fill
            const fillPct = 100;
            item.innerHTML = `
              <div class=\"ranking-number\">#${idx+1}</div>
              <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${row.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
            list.appendChild(item);
          });
        }
        section.appendChild(list);
        godRow.appendChild(section);
        delete byPanel[key];
      });
      panelsDiv.appendChild(godRow);

      // Second row: Damage Dealers, Healers, Totems
      const tripleKeys = ['damage','healing','windfury_totems'];
      const tripleRow = document.createElement('div');
      tripleRow.className = 'rankings-container triple-row';
      tripleKeys.forEach((key)=>{
        const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
        const section = document.createElement('div');
        const cls = panelClassForKey(key);
        section.className = 'rankings-section' + (cls? (' '+cls) : '');
        const header = document.createElement('div');
        header.className = 'section-header';
        const h2 = document.createElement('h2');
        h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
        header.appendChild(h2);
        section.appendChild(header);
        if (key === 'windfury_totems') {
          renderTotemsSection(section, obj.rows || []);
          ensureTotemInfoTooltipSetup();
        } else {
          const list = document.createElement('div');
          list.className = 'rankings-list';
          let rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            // For Decurses, fill by relative decurse count and sort by that count desc
            const isDecurses = (key === 'decurses');
            let sortedRows = rows.slice();
            if (isDecurses) {
              // Extract decurse count from details (last integer)
              const extract = (r)=>{ try{ const d=String((r.character_details_edited ?? r.character_details ?? r.character_details_original) || ''); const m=d.match(/(\d+)(?!.*\d)/); return m?parseInt(m[1],10):0; }catch{return 0;} };
              sortedRows.sort((a,b)=> (extract(b)-extract(a)) || String(a.character_name).localeCompare(String(b.character_name)));
              const vals = sortedRows.map(extract); const max = Math.max(1, ...vals);
              list.innerHTML = '';
              sortedRows.forEach((row, idx)=>{
                const item = document.createElement('div');
                item.className = 'ranking-item';
                const clsName = (row.character_class||'').toString().toLowerCase();
                const details = (row.character_details_edited != null ? row.character_details_edited : (row.character_details != null ? row.character_details : (row.character_details_original != null ? row.character_details_original : '')));
                const rawPts = (row.point_value_edited != null ? row.point_value_edited : (row.points != null ? row.points : (row.point_value_original != null ? row.point_value_original : 0)));
                const points = Math.round(Number(rawPts||0));
                const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
                const iconUrlPub = row.aux_json && (row.aux_json.icon_url || row.aux_json['icon_url']);
                const icon = iconUrlPub || classIconUrl(clsName);
                const v = vals[idx] || 0; const pct = Math.max(5, Math.min(100, Math.round((v / max) * 100)));
                item.innerHTML = `
                  <div class="ranking-number">#${idx+1}</div>
                  <div class="character-info ${clsName?('class-'+clsName):'class-unknown'}" style="--fill-percentage: ${pct}%">
                    ${icon?`<img src="${icon}" class="spec-icon" alt="${clsName}" width="47" height="47">`:''}
                    <div class="character-name ${clsName?('class-'+clsName):''}">${row.character_name||''}</div>
                    <div class="character-details">${details}</div>
                  </div>
                  <div class="performance-amount"><span class="amount-value ${amtClass}">${points}</span></div>`;
                list.appendChild(item);
              });
              section.appendChild(list);
              row.appendChild(section);
              delete byPanel[key];
              return;
            }
            rows = sortedRows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages based on points
            const pointsValues = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPoints = Math.max(1, ...pointsValues);
            rows.forEach((row, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (row.character_class||'').toString().toLowerCase();
              const details = (row.character_details_edited != null ? row.character_details_edited : (row.character_details != null ? row.character_details : (row.character_details_original != null ? row.character_details_original : '')));
              const rawPts = (row.point_value_edited != null ? row.point_value_edited : (row.points != null ? row.points : (row.point_value_original != null ? row.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub2 = row.aux_json && (row.aux_json.icon_url || row.aux_json['icon_url']);
              const icon = iconUrlPub2 || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((pointsValues[idx] / maxPoints) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${row.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
        }
        tripleRow.appendChild(section);
        delete byPanel[key];
      });
      if (tripleRow.children.length > 0) panelsDiv.appendChild(tripleRow);

      // Third row: Top Shaman Healers, Top Priest Healers, Top Druid Healer
      (function(){
        const keys = ['shaman_healers','priest_healers','druid_healers'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            const isPolymorph = (key === 'polymorph');
            if (isPolymorph) {
              const extract = (r)=>{ try{ const d=String((r.character_details_edited ?? r.character_details ?? r.character_details_original) || ''); const m=d.match(/(\d+)(?!.*\d)/); return m?parseInt(m[1],10):0; }catch{return 0;} };
              rows.sort((a,b)=> (extract(b)-extract(a)) || String(a.character_name).localeCompare(String(b.character_name)));
            } else {
              rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            }
            // Calculate fill percentages based on points
            const pointsVals = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPts = Math.max(1, ...pointsVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Fourth row: Too Low Damage, Too Low Healing
      (function(){
        const keys = ['too_low_damage','too_low_healing'];
        const row = document.createElement('div');
        row.className = 'rankings-container god-gamer-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages based on points (for negative values, use absolute value for visual consistency)
            const pointsVals = rows.map(r => Math.abs(Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPts = Math.max(1, ...pointsVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Fifth row: Guild Members, Attendance Streak Champions
      (function(){
        const keys = ['guild_members','attendance_streaks'];
        const row = document.createElement('div');
        row.className = 'rankings-container god-gamer-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages - Guild Members and Attendance all show as 100% or relative to their points
            const isGuildMembers = (key === 'guild_members');
            const pointsVals = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPts = Math.max(1, ...pointsVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = isGuildMembers ? 100 : Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Sixth row: Engineering & Holywater, Interrupted spells, World Buffs
      (function(){
        const keys = ['abilities','interrupts','world_buffs_copy'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages based on points
            const pointsVals = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPts = Math.max(1, ...pointsVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Seventh row: Curse Recklessness, Curse of the Elements, Curse of Shadow
      (function(){
        const keys = ['curse_recklessness','curse_elements','curse_shadow'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages based on uptime % for curses
            const fillVals = rows.map(r => {
              // Extract uptime percentage from character_details (e.g. "85%" or "85.5%")
              const details = (r.character_details_edited != null ? r.character_details_edited : (r.character_details != null ? r.character_details : (r.character_details_original != null ? r.character_details_original : '')));
              const match = String(details).match(/(\d+(?:\.\d+)?)\s*%/);
              if (match) return Math.max(0, Number(match[1]));
              return 0;
            });
            const maxVal = Math.max(1, ...fillVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((fillVals[idx] / maxVal) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      

      // Eighth row: Faerie Fire, Decurses, Demoralizing Shout
      (function(){
        const keys = ['faerie_fire','decurses','demo_shout'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages: for Decurses, use decurse count (primary_numeric); for Faerie Fire, use uptime %; otherwise use points
            const isDecurses = (key === 'decurses');
            const isFaerieFire = (key === 'faerie_fire');
            const fillValues = rows.map(r => {
              if (isDecurses && r.primary_numeric_original != null) {
                return Math.max(0, Number(r.primary_numeric_original));
              }
              if (isFaerieFire) {
                // Extract uptime percentage from character_details (e.g. "85%" or "85.5%")
                const details = (r.character_details_edited != null ? r.character_details_edited : (r.character_details != null ? r.character_details : (r.character_details_original != null ? r.character_details_original : '')));
                const match = String(details).match(/(\d+(?:\.\d+)?)\s*%/);
                if (match) return Math.max(0, Number(match[1]));
              }
              return Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0));
            });
            // For Faerie Fire uptime, use 100% as max (not relative to highest player)
            const maxVal = isFaerieFire ? 100 : Math.max(1, ...fillValues);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((fillValues[idx] / maxVal) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Ninth row: Major Mana Potions, Dark or Demonic runes, Goblin Rocket Helmet
      (function(){
        const keys = ['mana_potions','runes','rocket_helmet'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            // Runes panel: use actual rune count from details for sorting and fill
            // Others: use points
            const isRunes = (key === 'runes');
            
            const extractRuneCount = (r)=>{ 
              try{ 
                const d=String((r.character_details_edited ?? r.character_details ?? r.character_details_original) || ''); 
                // Try to extract from "(X total)" first
                let m = d.match(/\((\d+)\s+total\)/);
                if (m) return parseInt(m[1], 10) || 0;
                
                // Otherwise sum "X Dark, Y Demonic" 
                let total = 0;
                const darkMatch = d.match(/(\d+)\s+Dark/);
                const demonicMatch = d.match(/(\d+)\s+Demonic/);
                if (darkMatch) total += parseInt(darkMatch[1], 10) || 0;
                if (demonicMatch) total += parseInt(demonicMatch[1], 10) || 0;
                return total;
              }catch{return 0;} 
            };
            
            if (isRunes) {
              // Sort by rune count (highest first)
              rows.sort((a,b)=> (extractRuneCount(b)-extractRuneCount(a)) || String(a.character_name).localeCompare(String(b.character_name)));
              // Calculate fill percentages based on actual rune count
              const runeCounts = rows.map(r => extractRuneCount(r));
              const maxRunes = Math.max(1, ...runeCounts);
              rows.forEach((rowItem, idx)=>{
                const item = document.createElement('div');
                item.className = 'ranking-item';
                const clsName = (rowItem.character_class||'').toString().toLowerCase();
                const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
                const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
                const points = Math.round(Number(rawPts||0));
                const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
                const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
                const icon = iconUrlPub || classIconUrl(clsName);
                // Rank #1 gets 100%, others scale proportionally
                let fillPct = (runeCounts[idx] / maxRunes) * 100;
                if (idx === 0) fillPct = 100;
                fillPct = Math.max(5, Math.min(100, Math.round(fillPct)));
                item.innerHTML = `
                  <div class=\"ranking-number\">#${idx+1}</div>
                  <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                    ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                    <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                    <div class=\"character-details\">${details}</div>
                  </div>
                  <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
                list.appendChild(item);
              });
            } else {
              // Mana potions and Rocket Helmet: use points-based sorting and fill
              rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
              const pointsVals = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
              const maxPts = Math.max(1, ...pointsVals);
              rows.forEach((rowItem, idx)=>{
                const item = document.createElement('div');
                item.className = 'ranking-item';
                const clsName = (rowItem.character_class||'').toString().toLowerCase();
                const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
                const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
                const points = Math.round(Number(rawPts||0));
                const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
                const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
                const icon = iconUrlPub || classIconUrl(clsName);
                const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
                item.innerHTML = `
                  <div class=\"ranking-number\">#${idx+1}</div>
                  <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                    ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                    <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                    <div class=\"character-details\">${details}</div>
                  </div>
                  <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
                list.appendChild(item);
              });
            }
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Tenth row: Sunder Armor, Scorch, Polymorph
      (function(){
        const keys = ['sunder','scorch','polymorph'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            // For Scorch and Polymorph, use actual count from details for sorting and fill
            // For Sunder, use points
            const isScorch = (key === 'scorch');
            const isPolymorph = (key === 'polymorph');
            
            const extractCount = (r)=>{ 
              try{ 
                const d=String((r.character_details_edited ?? r.character_details ?? r.character_details_original) || ''); 
                const m=d.match(/(\d+)(?!.*\d)/); 
                return m?parseInt(m[1],10):0; 
              }catch{return 0;} 
            };
            
            if (isScorch || isPolymorph) {
              // Sort by count (highest first)
              rows.sort((a,b)=> (extractCount(b)-extractCount(a)) || String(a.character_name).localeCompare(String(b.character_name)));
              // Calculate fill percentages based on actual count
              const countVals = rows.map(r => extractCount(r));
              const maxCount = Math.max(1, ...countVals);
              rows.forEach((rowItem, idx)=>{
                const item = document.createElement('div');
                item.className = 'ranking-item';
                const clsName = (rowItem.character_class||'').toString().toLowerCase();
                const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
                const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
                const points = Math.round(Number(rawPts||0));
                const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
                const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
                const icon = iconUrlPub || classIconUrl(clsName);
                const fillPct = Math.max(5, Math.min(100, Math.round((countVals[idx] / maxCount) * 100)));
                item.innerHTML = `
                  <div class=\"ranking-number\">#${idx+1}</div>
                  <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                    ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                    <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                    <div class=\"character-details\">${details}</div>
                  </div>
                  <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
                list.appendChild(item);
              });
            } else {
              // Sunder: use points-based sorting and fill
              rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
              const pointsVals = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
              const maxPts = Math.max(1, ...pointsVals);
              rows.forEach((rowItem, idx)=>{
                const item = document.createElement('div');
                item.className = 'ranking-item';
                const clsName = (rowItem.character_class||'').toString().toLowerCase();
                const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
                const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
                const points = Math.round(Number(rawPts||0));
                const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
                const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
                const icon = iconUrlPub || classIconUrl(clsName);
                const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
                item.innerHTML = `
                  <div class=\"ranking-number\">#${idx+1}</div>
                  <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                    ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                    <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                    <div class=\"character-details\">${details}</div>
                  </div>
                  <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
                list.appendChild(item);
              });
            }
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Eleventh row: Disarmed enemies, Avoidable Void Damage
      (function(){
        const keys = ['disarms','void_damage'];
        const row = document.createElement('div');
        row.className = 'rankings-container god-gamer-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: (key==='void_damage' ? 'Avoidable Void Damage' : slugToTitle(key)), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || (key==='void_damage' ? 'Avoidable Void Damage' : slugToTitle(key)));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = (key==='void_damage') ? emptyStateHtml('No players took avoidable void damage!') : emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages based on points (for negative values, use absolute value)
            const pointsVals = rows.map(r => Math.abs(Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPts = Math.max(1, ...pointsVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
              item.innerHTML = `
                <div class="ranking-number">#${idx+1}</div>
                <div class="character-info ${clsName?('class-'+clsName):'class-unknown'}" style="--fill-percentage: ${fillPct}%">
                  ${icon?`<img src="${icon}" class="spec-icon" alt="${clsName}" width="47" height="47">`:''}
                  <div class="character-name ${clsName?('class-'+clsName):''}">${rowItem.character_name||''}</div>
                  <div class="character-details">${details}</div>
                </div>
                <div class="performance-amount"><span class="amount-value ${amtClass}">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Twelfth row: Power Infusion, Frost Resistance, Big Buyer Bonus
      (function(){
        const keys = ['power_infusion','frost_resistance','big_buyer'];
        const row = document.createElement('div');
        row.className = 'rankings-container triple-row';
        keys.forEach((key)=>{
          const obj = byPanel[key] || { name: slugToTitle(key), rows: [] };
          const section = document.createElement('div');
          const cls = panelClassForKey(key);
          section.className = 'rankings-section' + (cls? (' '+cls) : '');
          const header = document.createElement('div');
          header.className = 'section-header';
          const h2 = document.createElement('h2');
          h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
          header.appendChild(h2);
          section.appendChild(header);
          const list = document.createElement('div');
          list.className = 'rankings-list';
          const rows = (obj.rows||[]).slice();
          if (!rows.length) {
            list.innerHTML = emptyStateHtml();
          } else {
            rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
            // Calculate fill percentages based on points
            const pointsVals = rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
            const maxPts = Math.max(1, ...pointsVals);
            rows.forEach((rowItem, idx)=>{
              const item = document.createElement('div');
              item.className = 'ranking-item';
              const clsName = (rowItem.character_class||'').toString().toLowerCase();
              const details = (rowItem.character_details_edited != null ? rowItem.character_details_edited : (rowItem.character_details != null ? rowItem.character_details : (rowItem.character_details_original != null ? rowItem.character_details_original : '')));
              const rawPts = (rowItem.point_value_edited != null ? rowItem.point_value_edited : (rowItem.points != null ? rowItem.points : (rowItem.point_value_original != null ? rowItem.point_value_original : 0)));
              const points = Math.round(Number(rawPts||0));
              const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
              const iconUrlPub = rowItem.aux_json && (rowItem.aux_json.icon_url || rowItem.aux_json['icon_url']);
              const icon = iconUrlPub || classIconUrl(clsName);
              const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
              item.innerHTML = `
                <div class=\"ranking-number\">#${idx+1}</div>
                <div class=\"character-info ${clsName?('class-'+clsName):'class-unknown'}\" style="--fill-percentage: ${fillPct}%">\n                  ${icon?`<img src=\"${icon}\" class=\"spec-icon\" alt=\"${clsName}\" width=\"47\" height=\"47\">`:''}
                  <div class=\"character-name ${clsName?('class-'+clsName):''}\">${rowItem.character_name||''}</div>
                  <div class=\"character-details\">${details}</div>
                </div>
                <div class=\"performance-amount\"><span class=\"amount-value ${amtClass}\">${points}</span></div>`;
              list.appendChild(item);
            });
          }
          section.appendChild(list);
          row.appendChild(section);
          delete byPanel[key];
        });
        panelsDiv.appendChild(row);
      })();

      // Remaining panels
      Object.entries(byPanel).forEach(([key, obj])=>{
        if (key === 'base') return; // hide Base panel visually
        const section = document.createElement('div');
        const cls = panelClassForKey(key);
        section.className = 'rankings-section' + (cls? (' '+cls) : '');
        const header = document.createElement('div');
        header.className = 'section-header';
        const h2 = document.createElement('h2');
        h2.innerHTML = getIconForPanel(key) + (obj.name || slugToTitle(key));
        header.appendChild(h2);
        section.appendChild(header);
        const list = document.createElement('div');
        list.className = 'rankings-list';
        obj.rows.sort((a,b)=> (b.points||0)-(a.points||0) || String(a.character_name).localeCompare(String(b.character_name)));
        // Calculate fill percentages based on points
        const pointsVals = obj.rows.map(r => Math.max(0, Number((r.point_value_edited != null ? r.point_value_edited : (r.points != null ? r.points : r.point_value_original)) || 0)));
        const maxPts = Math.max(1, ...pointsVals);
        obj.rows.forEach((row, idx)=>{
          const item = document.createElement('div');
          item.className = 'ranking-item';
          const clsName = (row.character_class||'').toString().toLowerCase();
          // Prefer edited values when present; fall back to original
          const details = (row.character_details_edited != null ? row.character_details_edited : (row.character_details != null ? row.character_details : (row.character_details_original != null ? row.character_details_original : '')));
          const rawPts = (row.point_value_edited != null ? row.point_value_edited : (row.points != null ? row.points : (row.point_value_original != null ? row.point_value_original : 0)));
          const points = Math.round(Number(rawPts||0));
          const amtClass = points>0 ? 'positive' : points<0 ? 'negative' : 'zero';
          const icon = classIconUrl(clsName);
          const iconUrl = row.aux_json && (row.aux_json.icon_url || row.aux_json['icon_url']) ? String(row.aux_json.icon_url || row.aux_json['icon_url']) : '';
          const fillPct = Math.max(5, Math.min(100, Math.round((pointsVals[idx] / maxPts) * 100)));
          item.innerHTML = `
            <div class="ranking-number">#${idx+1}</div>
            <div class="character-info ${clsName?('class-'+clsName):'class-unknown'}" style="--fill-percentage: ${fillPct}%">
              ${icon?`<img src="${icon}" class="spec-icon" alt="${clsName}" width="43" height="43">`:''}
              <div class="character-name ${clsName?('class-'+clsName):''}">${row.character_name||''}</div>
              <div class="character-details">${details}</div>
            </div>
            <div class="performance-amount"><span class="amount-value ${amtClass}">${points}</span></div>`;
          list.appendChild(item);
        });
        section.appendChild(list);
        panelsDiv.appendChild(section);
      });
      // Apply background fill percentages per panel rules
      applyFillPercentages();
      // Attach panel info overlays and icons
      initializePanelInfoOverlays();
    }
    load();
  })();
  </script>
  <script src="/top-bar.js?v=frsync-3"></script>
</body>
</html>

